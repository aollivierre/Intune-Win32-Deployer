diff --git a/.claude/settings.local.json b/.claude/settings.local.json
new file mode 100644
index 0000000..be5b34d
--- /dev/null
+++ b/.claude/settings.local.json
@@ -0,0 +1,28 @@
+{
+  "permissions": {
+    "allow": [
+      "Bash(mkdir:*)",
+      "Bash(ls:*)",
+      "Bash(pwsh ./test-icon-path.ps1)",
+      "Bash(powershell.exe:*)",
+      "Bash(find:*)",
+      "Bash(cp:*)",
+      "Bash(powershell:*)",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -ExecutionPolicy Bypass -File Test-Authentication.ps1)",
+      "Bash(/mnt/c/Program Files/PowerShell/7/pwsh.exe -NoProfile -File Get-AuthTokenPS7.ps1)",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -ExecutionPolicy Bypass -File Use-SavedAuthToken.ps1)",
+      "Bash(cat:*)",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -ExecutionPolicy Bypass -File Test-IntegratedAuth.ps1)",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -Command \"Write-Host ''''Testing authentication in main script...'''' -ForegroundColor Yellow; . .\\Intune-Win32-Deployer-ALPHAv1.ps1\")",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -ExecutionPolicy Bypass -File Test-AuthOnly.ps1)",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -ExecutionPolicy Bypass -File Fix-DateTimeError.ps1)",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -ExecutionPolicy Bypass -File Reload-AuthToken.ps1)",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -ExecutionPolicy Bypass -File Test-DateTimeFix.ps1)",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -ExecutionPolicy Bypass -File Debug-TokenStructure.ps1)",
+      "Bash(rm:*)",
+      "Bash(/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -NoProfile -Command \"cd ''''C:\\Code\\Intune-Win32-Deployer''''; .\\Intune-Win32-Deployer-ALPHAv1.ps1\")",
+      "Bash(timeout:*)"
+    ],
+    "deny": []
+  }
+}
\ No newline at end of file
diff --git a/.scaffolding/Save-GitDiff-txt.ps1 b/.scaffolding/Save-GitDiff-txt.ps1
new file mode 100644
index 0000000..fe666f4
--- /dev/null
+++ b/.scaffolding/Save-GitDiff-txt.ps1
@@ -0,0 +1,203 @@
+#requires -Version 5.1
+
+<#
+.SYNOPSIS
+    Saves git diff output to a file.
+
+.DESCRIPTION
+    This script runs 'git add --all' to stage all changes, then runs 'git diff --cached' 
+    and saves the output to a specified file. The script confirms the repository and branch
+    with the user before proceeding.
+
+.PARAMETER OutputFile
+    The path to the file where the git diff output will be saved.
+    Default is 'git-diff.txt' in the current directory.
+
+.PARAMETER SkipConfirmation
+    If specified, skips the confirmation step.
+
+.EXAMPLE
+    .\Save-GitDiff.ps1
+    Saves the git diff output to git-diff.txt in the current directory.
+
+.EXAMPLE
+    .\Save-GitDiff.ps1 -OutputFile "C:\temp\my-changes.diff"
+    Saves the git diff output to the specified file path.
+
+.EXAMPLE
+    .\Save-GitDiff.ps1 -SkipConfirmation
+    Skips the confirmation step and proceeds directly.
+#>
+
+[CmdletBinding()]
+param (
+    [Parameter(Position = 0)]
+    [string]$OutputFile = "git-diff.txt",
+    
+    [Parameter()]
+    [switch]$SkipConfirmation
+)
+
+# Verify git is installed
+try {
+    $null = Get-Command git -ErrorAction Stop
+}
+catch {
+    Write-Error "Git is not installed or not in the PATH. Please install Git or add it to your PATH."
+    exit 1
+}
+
+# Verify we're in a git repository
+if (-not (Test-Path -Path ".git" -PathType Container)) {
+    Write-Error "This directory is not a git repository. Please run this script from a git repository."
+    exit 1
+}
+
+# Get repository and branch information
+try {
+    $repoName = Split-Path -Path (git rev-parse --show-toplevel) -Leaf
+    $currentBranch = git rev-parse --abbrev-ref HEAD
+}
+catch {
+    Write-Error "Failed to get repository information: $_"
+    exit 1
+}
+
+# Confirm with user
+if (-not $SkipConfirmation) {
+    Write-Host "Current repository: $repoName" -ForegroundColor Cyan
+    Write-Host "Current branch: $currentBranch" -ForegroundColor Cyan
+    
+    # Get list of staged and unstaged changes
+    $allChanges = git status --porcelain
+    
+    # Filter for unstaged changes (those not fully staged)
+    $unstagedChanges = $allChanges | Where-Object { 
+        $_ -match '^.[MADRCU?]' -or $_ -match '^\?\?' 
+    }
+    
+    # Filter for already staged changes
+    $stagedChanges = $allChanges | Where-Object { 
+        $_ -match '^[MADRCU]' -and $_ -notmatch '^.[MADRCU?]' 
+    }
+    
+    $unstagedCount = ($unstagedChanges | Measure-Object).Count
+    $stagedCount = ($stagedChanges | Measure-Object).Count
+    
+    # Show already staged changes
+    if ($stagedCount -gt 0) {
+        Write-Host "`nAlready staged changes ($stagedCount):" -ForegroundColor Green
+        $stagedChanges | ForEach-Object {
+            $status = $_.Substring(0, 2)
+            $file = $_.Substring(3)
+            
+            $statusText = switch -Regex ($status) {
+                '^M.'   { "Modified:   " }
+                '^A.'   { "Added:      " }
+                '^D.'   { "Deleted:    " }
+                '^R.'   { "Renamed:    " }
+                '^C.'   { "Copied:     " }
+                default { "Changed:    " }
+            }
+            
+            Write-Host "  $statusText$file" -ForegroundColor DarkGreen
+        }
+    }
+    
+    # Show new changes to be staged
+    Write-Host "`nNew changes to be staged ($unstagedCount):" -ForegroundColor Yellow
+    if ($unstagedCount -gt 0) {
+        $unstagedChanges | ForEach-Object {
+            $status = $_.Substring(0, 2)
+            $file = $_.Substring(3)
+            
+            $statusText = switch -Regex ($status) {
+                '^\?\?' { "Untracked:  " }
+                '^.M'   { "Modified:   " }
+                '^.A'   { "Added:      " }
+                '^.D'   { "Deleted:    " }
+                '^.R'   { "Renamed:    " }
+                '^.C'   { "Copied:     " }
+                default { "Changed:    " }
+            }
+            
+            Write-Host "  $statusText$file"
+        }
+    } else {
+        Write-Host "  No new changes to stage" -ForegroundColor Gray
+    }
+    
+    # If no changes at all
+    if ($stagedCount -eq 0 -and $unstagedCount -eq 0) {
+        Write-Host "  No changes detected in this repository" -ForegroundColor Gray
+    }
+    
+    Write-Host "`nThis script will stage all changes with 'git add --all' and save the diff to $OutputFile" -ForegroundColor Yellow
+    
+    $confirmation = Read-Host -Prompt "Do you want to proceed? (Y/N)"
+    if ($confirmation -ne 'Y' -and $confirmation -ne 'y') {
+        Write-Host "Operation cancelled by user." -ForegroundColor Red
+        exit 0
+    }
+}
+
+# Stage all changes
+try {
+    Write-Verbose "Staging all changes with 'git add --all'"
+    git add --all
+    
+    # Unstage the output file if it was staged
+    # This prevents the output file from being part of the diff
+    if (Test-Path -Path $OutputFile) {
+        Write-Verbose "Unstaging output file: $OutputFile"
+        git reset HEAD $OutputFile
+    }
+    
+    Write-Host "All changes have been staged (except the output file)" -ForegroundColor Green
+}
+catch {
+    Write-Error "An error occurred while staging changes: $_"
+    exit 1
+}
+
+# Get the git diff and save it to the file
+try {
+    Write-Verbose "Running 'git diff --cached' and saving to $OutputFile"
+    
+    # First, remove the file if it exists - with extra verification
+    if (Test-Path -Path $OutputFile) {
+        try {
+            Remove-Item -Path $OutputFile -Force -ErrorAction Stop
+            Write-Verbose "Removed existing file: $OutputFile"
+            # Verify removal
+            if (Test-Path -Path $OutputFile) {
+                Write-Error "Failed to remove existing file: $OutputFile"
+                exit 1
+            }
+        }
+        catch {
+            Write-Error "Error removing file: $_"
+            exit 1
+        }
+    }
+    
+    # Get the diff content
+    $diffOutput = git diff --cached
+    
+    # Create a new file with the diff content
+    if ($null -eq $diffOutput -or $diffOutput -eq '') {
+        Write-Warning "No staged changes found. The output file will be empty."
+        # Create an empty file
+        Set-Content -Path $OutputFile -Value "" -Force
+    } else {
+        # Restore original behavior but ensure we're creating a new file
+        # This preserves line breaks properly
+        Set-Content -Path $OutputFile -Value $diffOutput -Encoding UTF8 -Force
+    }
+    
+    Write-Host "Git diff output saved to $OutputFile"
+}
+catch {
+    Write-Error "An error occurred while running git diff: $_"
+    exit 1
+} 
\ No newline at end of file
diff --git a/AUTHENTICATION_FIX_COMPLETE.md b/AUTHENTICATION_FIX_COMPLETE.md
new file mode 100644
index 0000000..df9b93c
--- /dev/null
+++ b/AUTHENTICATION_FIX_COMPLETE.md
@@ -0,0 +1,92 @@
+# IntuneWin32App Authentication Fix - COMPLETE Γ£à
+
+## Summary
+Successfully implemented a hybrid PowerShell 7/5 authentication solution that resolves the CNG certificate compatibility issue with the IntuneWin32App module.
+
+## What Was Fixed
+
+### Original Problem
+- Error: "The property 'ClientId' cannot be found on this object"
+- Root cause: CNG certificates don't work properly with .NET Framework 4.6 (used by PowerShell 5.1)
+- The IntuneWin32App module's `Connect-MSIntuneGraph` function failed with certificate authentication
+
+### Solution Implemented
+1. **Automatic PowerShell 7 Detection**: The script now checks if PS7 is available
+2. **Hybrid Authentication**: Uses PS7 for token acquisition (handles CNG certs), then passes token to PS5
+3. **Seamless Integration**: No changes needed to the rest of your script
+4. **Fallback Support**: If PS7 isn't available, falls back to direct MSAL (with warning about CNG)
+
+## Test Results Γ£à
+
+### Authentication Test Results:
+- PowerShell 7 authentication: **SUCCESS**
+- Token acquisition: **SUCCESS**
+- Token loading in PS5: **SUCCESS**
+- Graph API connection: **SUCCESS** (Connected to: Lion's Housing Centres)
+- IntuneWin32App module compatibility: **SUCCESS**
+
+### Key Success Indicators:
+```
+Global:AuthenticationHeader exists: True
+Global:AccessToken exists: True
+Global:AccessTokenTenantID: f8e714f5-f15a-435d-b51e-9c93d637a9c4
+```
+
+## Files Modified
+
+1. **Intune-Win32-Deployer-ALPHAv1.ps1**
+   - Updated authentication block to use PS7 when available
+   - Added automatic token handoff between PS7 and PS5
+   - Maintains backward compatibility
+
+2. **Ensure-IntuneAuthentication.ps1**
+   - Updated to use the same PS7 authentication approach
+   - Handles both certificate file and thumbprint scenarios
+
+## How It Works
+
+1. Script detects PowerShell 7 is available
+2. Creates a temporary PS7 script with authentication logic
+3. PS7 loads the CNG certificate without issues
+4. PS7 gets token from Azure AD using MSAL.PS
+5. Token is saved to a temporary JSON file
+6. PS5 loads the token from the file
+7. Global variables are set in the format IntuneWin32App expects
+8. All IntuneWin32App functions work normally
+
+## Usage
+
+No changes required! Just run your script as normal:
+```powershell
+.\Intune-Win32-Deployer-ALPHAv1.ps1
+```
+
+The script will automatically:
+- Detect PS7 and use it for authentication
+- Handle the token handoff transparently
+- Continue with all Win32 app deployment operations
+
+## Prerequisites
+
+- PowerShell 7 installed (for CNG certificate support)
+- MSAL.PS module installed
+- IntuneWin32App module installed
+- Valid certificate and secrets.json file
+
+## Troubleshooting
+
+If authentication fails:
+1. Ensure PowerShell 7 is installed: `winget install Microsoft.PowerShell`
+2. Check certificate has private key
+3. Verify secrets.json has correct values
+4. Check temp token file: `$env:TEMP\intune_auth_token.json`
+
+## Backup
+
+Original script backed up to: `Intune-Win32-Deployer-ALPHAv1.ps1.backup`
+
+---
+
+**Status: RESOLVED** ≡ƒÄë
+
+The CNG certificate authentication issue has been successfully resolved using a PowerShell 7 hybrid approach.
\ No newline at end of file
diff --git a/AUTHENTICATION_FIX_SUMMARY.md b/AUTHENTICATION_FIX_SUMMARY.md
new file mode 100644
index 0000000..70b7be9
--- /dev/null
+++ b/AUTHENTICATION_FIX_SUMMARY.md
@@ -0,0 +1,85 @@
+# IntuneWin32App Authentication Fix Summary
+
+## Problem
+The IntuneWin32App module's `Connect-MSIntuneGraph` function was failing with the error:
+"The property 'ClientId' cannot be found on this object"
+
+This occurred because:
+1. The IntuneWin32App module expects older MSAL library object types
+2. MSAL.PS returns different object structures
+3. The `New-AuthenticationHeader` function tries to call methods that don't exist on MSAL.PS tokens
+
+## Solution Implemented
+
+### 1. Main Script Update (Intune-Win32-Deployer-ALPHAv1.ps1)
+- Replaced `Connect-MSIntuneGraph` calls with direct MSAL.PS authentication
+- Manually creates the `$Global:AuthenticationHeader` in the format IntuneWin32App expects
+- Sets all required global variables that IntuneWin32App module functions use
+
+### 2. Module Update (Ensure-IntuneAuthentication.ps1)
+- Updated to use direct MSAL.PS authentication
+- Handles both certificate file and thumbprint scenarios
+- Creates compatible authentication headers
+
+## Changes Made
+
+1. **Direct MSAL Authentication**: Instead of using `Connect-MSIntuneGraph`, we now:
+   ```powershell
+   # Get token directly from MSAL.PS
+   $msalToken = Get-MsalToken -TenantId $tenantId -ClientId $clientId -ClientCertificate $cert
+   
+   # Manually set global variables
+   $Global:AccessToken = $msalToken
+   $Global:AccessTokenTenantID = $tenantId
+   $Global:AuthenticationHeader = @{
+       "Content-Type" = "application/json"
+       "Authorization" = "Bearer $($msalToken.AccessToken)"
+       "ExpiresOn" = $msalToken.ExpiresOn.UtcDateTime
+   }
+   ```
+
+2. **Compatibility Layer**: The authentication header is created manually to match what IntuneWin32App functions expect
+
+3. **Error Handling**: Added verification steps to test the authentication immediately
+
+## Testing Instructions
+
+1. **Run the test script first**:
+   ```powershell
+   # In PowerShell 5.1 (as admin)
+   cd C:\Code\Intune-Win32-Deployer
+   .\Test-Authentication.ps1
+   ```
+
+2. **If test passes, run the main script**:
+   ```powershell
+   .\Intune-Win32-Deployer-ALPHAv1.ps1
+   ```
+
+3. **Expected Output**:
+   - Should see "Direct MSAL authentication successful"
+   - Should see "Authentication verified - connected to tenant: [Your Tenant Name]"
+   - Should NOT see "The property 'ClientId' cannot be found on this object" error
+
+## Rollback Instructions
+
+If needed, restore the original script:
+```powershell
+Copy-Item "Intune-Win32-Deployer-ALPHAv1.ps1.backup" "Intune-Win32-Deployer-ALPHAv1.ps1" -Force
+```
+
+## What This Fix Does
+
+1. Bypasses the incompatible `Connect-MSIntuneGraph` function
+2. Uses MSAL.PS directly to get authentication tokens
+3. Manually creates the authentication header structure that IntuneWin32App expects
+4. Maintains compatibility with all other IntuneWin32App module functions
+
+## Verification
+
+After authentication, the IntuneWin32App module functions like:
+- `Get-IntuneWin32App`
+- `Add-IntuneWin32App`
+- `New-IntuneWin32AppDetectionRule`
+
+Should all work correctly with the manually created authentication header.
\ No newline at end of file
diff --git a/Debug-TokenStructure.ps1 b/Debug-TokenStructure.ps1
new file mode 100644
index 0000000..6e6119d
--- /dev/null
+++ b/Debug-TokenStructure.ps1
@@ -0,0 +1,89 @@
+# Debug script to understand what token structure IntuneWin32App expects
+
+Write-Host "Analyzing IntuneWin32App module expectations..." -ForegroundColor Yellow
+
+# First, let's see what a real MSAL token looks like when obtained directly
+Write-Host "`nGetting a fresh MSAL token to examine its structure..." -ForegroundColor Cyan
+
+# Load secrets
+$secretsPath = "C:\Code\Intune-Win32-Deployer\secrets\Lion's Housing Centres\secrets.json"
+$secrets = Get-Content $secretsPath -Raw | ConvertFrom-Json
+
+# Try to get a token using MSAL.PS directly in PS5
+try {
+    Import-Module MSAL.PS -ErrorAction Stop
+    
+    # This will fail with CNG cert, but we want to see the error
+    $certPath = "C:\Code\GraphAppwithCert\Graph\Lion's Housing Centres\GraphCert-Lion's Housing Centres-$($secrets.ClientId).pfx"
+    
+    Write-Host "Attempting direct MSAL in PS5 (expected to fail with CNG)..." -ForegroundColor Yellow
+    
+    try {
+        $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certPath, $secrets.CertPassword)
+        $token = Get-MsalToken -TenantId $secrets.TenantID -ClientId $secrets.ClientId -ClientCertificate $cert
+    }
+    catch {
+        Write-Host "Expected CNG error: $_" -ForegroundColor Gray
+    }
+}
+catch {
+    Write-Host "MSAL.PS error: $_" -ForegroundColor Red
+}
+
+# Now let's create what we think the module expects
+Write-Host "`n`nCreating mock token structure that IntuneWin32App might expect..." -ForegroundColor Yellow
+
+# The module's Test-AccessToken tries to access:
+# $Global:AccessToken.ExpiresOn.ToUniversalTime().UtcDateTime
+
+# This suggests ExpiresOn should be a DateTimeOffset that has these methods
+$now = Get-Date
+$expiresIn1Hour = $now.AddHours(1)
+
+# Create different variations to test
+Write-Host "`nVariation 1: ExpiresOn as DateTime" -ForegroundColor Cyan
+$token1 = [PSCustomObject]@{
+    AccessToken = "dummy-token"
+    ExpiresOn = $expiresIn1Hour
+    TokenType = "Bearer"
+}
+Write-Host "ExpiresOn type: $($token1.ExpiresOn.GetType().FullName)" -ForegroundColor Gray
+try {
+    $test = $token1.ExpiresOn.ToUniversalTime().UtcDateTime
+    Write-Host "Can call .ToUniversalTime().UtcDateTime: NO (DateTime doesn't have UtcDateTime property)" -ForegroundColor Red
+}
+catch {
+    Write-Host "Error: $_" -ForegroundColor Red
+}
+
+Write-Host "`nVariation 2: ExpiresOn as DateTimeOffset" -ForegroundColor Cyan
+$token2 = [PSCustomObject]@{
+    AccessToken = "dummy-token"
+    ExpiresOn = [DateTimeOffset]::new($expiresIn1Hour)
+    TokenType = "Bearer"
+}
+Write-Host "ExpiresOn type: $($token2.ExpiresOn.GetType().FullName)" -ForegroundColor Gray
+try {
+    $test = $token2.ExpiresOn.ToUniversalTime().UtcDateTime
+    Write-Host "Can call .ToUniversalTime().UtcDateTime: YES" -ForegroundColor Green
+    Write-Host "Result: $test" -ForegroundColor Gray
+}
+catch {
+    Write-Host "Error: $_" -ForegroundColor Red
+}
+
+Write-Host "`nVariation 3: What MSAL.PS actually returns" -ForegroundColor Cyan
+# MSAL.PS returns a Microsoft.Identity.Client.AuthenticationResult
+# which has ExpiresOn as DateTimeOffset
+
+# Let's see what properties the module actually needs
+Write-Host "`nChecking IntuneWin32App module's Test-AccessToken function..." -ForegroundColor Yellow
+$testAccessTokenPath = "C:\Program Files\WindowsPowerShell\Modules\IntuneWin32App\1.4.4\Public\Test-AccessToken.ps1"
+$content = Get-Content $testAccessTokenPath -Raw
+if ($content -match 'ExpiresOn\.(\w+)\.(\w+)') {
+    Write-Host "Found: Module expects ExpiresOn.$($Matches[1]).$($Matches[2])" -ForegroundColor Cyan
+}
+
+Write-Host "`n`nRECOMMENDATION:" -ForegroundColor Green
+Write-Host "The Global:AccessToken.ExpiresOn must be a DateTimeOffset object" -ForegroundColor Yellow
+Write-Host "because the module calls: .ToUniversalTime().UtcDateTime on it" -ForegroundColor Yellow
\ No newline at end of file
diff --git a/Enhanced-Authentication-Block.ps1 b/Enhanced-Authentication-Block.ps1
new file mode 100644
index 0000000..b94bfd5
--- /dev/null
+++ b/Enhanced-Authentication-Block.ps1
@@ -0,0 +1,108 @@
+# Enhanced Authentication Block for Intune-Win32-Deployer
+# This replaces the existing authentication section in your main script
+
+#region ENHANCED AUTHENTICATION
+try {
+    Write-EnhancedLog -Message "Starting enhanced authentication process..." -Level "INFO"
+    
+    # Clear any existing authentication state
+    $Global:AccessToken = $null
+    $Global:AuthenticationHeader = $null
+    $Global:AccessTokenTenantID = $null
+    
+    # Load certificate
+    $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certPath, $CertPassword)
+    $certThumbprint = $cert.Thumbprint
+    Write-EnhancedLog -Message "Certificate loaded. Thumbprint: $certThumbprint" -Level "INFO"
+    
+    # Store certificate globally
+    $Global:CertObject = $cert
+    
+    # Method 1: Try using IntuneWin32App module's authentication
+    $authSuccess = $false
+    try {
+        Write-EnhancedLog -Message "Attempting IntuneWin32App module authentication..." -Level "INFO"
+        Connect-MSIntuneGraph -TenantID $tenantId -ClientID $clientId -ClientCert $cert -ErrorAction Stop
+        
+        # Verify authentication
+        if ($Global:AuthenticationHeader) {
+            Write-EnhancedLog -Message "IntuneWin32App authentication successful" -Level "INFO"
+            $authSuccess = $true
+        }
+    }
+    catch {
+        Write-EnhancedLog -Message "IntuneWin32App authentication failed: $($_.Exception.Message)" -Level "WARNING"
+    }
+    
+    # Method 2: If IntuneWin32App auth fails, try direct MSAL authentication
+    if (-not $authSuccess) {
+        Write-EnhancedLog -Message "Attempting direct MSAL authentication..." -Level "INFO"
+        
+        try {
+            # Import MSAL.PS module
+            Import-Module MSAL.PS -ErrorAction Stop
+            
+            # Create token request parameters
+            $tokenParams = @{
+                TenantId = $tenantId
+                ClientId = $clientId
+                ClientCertificate = $cert
+            }
+            
+            # Get access token
+            $token = Get-MsalToken @tokenParams
+            
+            if ($token) {
+                # Manually set the global variables that IntuneWin32App expects
+                $Global:AccessToken = $token
+                $Global:AccessTokenTenantID = $tenantId
+                
+                # Create authentication header in the format IntuneWin32App expects
+                $Global:AuthenticationHeader = @{
+                    "Authorization" = "Bearer $($token.AccessToken)"
+                    "Content-Type" = "application/json"
+                    "ExpiresOn" = $token.ExpiresOn.DateTime
+                }
+                
+                Write-EnhancedLog -Message "Direct MSAL authentication successful" -Level "INFO"
+                $authSuccess = $true
+            }
+        }
+        catch {
+            Write-EnhancedLog -Message "Direct MSAL authentication failed: $($_.Exception.Message)" -Level "ERROR"
+        }
+    }
+    
+    # Method 3: If all else fails, try interactive authentication
+    if (-not $authSuccess) {
+        Write-EnhancedLog -Message "Attempting interactive authentication as last resort..." -Level "WARNING"
+        try {
+            Connect-MSIntuneGraph -TenantID $tenantId -Interactive
+            
+            if ($Global:AuthenticationHeader) {
+                Write-EnhancedLog -Message "Interactive authentication successful" -Level "INFO"
+                $authSuccess = $true
+            }
+        }
+        catch {
+            Write-EnhancedLog -Message "Interactive authentication failed: $($_.Exception.Message)" -Level "ERROR"
+            throw "All authentication methods failed. Cannot proceed."
+        }
+    }
+    
+    # Store authentication parameters globally for reconnection
+    if ($authSuccess) {
+        $Global:TenantId = $tenantId
+        $Global:ClientId = $clientId
+        $Global:CertPath = $certPath
+        $Global:CertPassword = $CertPassword
+        
+        Write-EnhancedLog -Message "Authentication completed successfully" -Level "INFO"
+        Write-EnhancedLog -Message "Access token expires at: $($Global:AccessToken.ExpiresOn)" -Level "INFO"
+    }
+}
+catch {
+    Write-EnhancedLog -Message "Critical authentication error: $($_.Exception.Message)" -Level "ERROR"
+    throw
+}
+#endregion ENHANCED AUTHENTICATION
\ No newline at end of file
diff --git a/Fix-DateTimeError.ps1 b/Fix-DateTimeError.ps1
new file mode 100644
index 0000000..5cb3657
--- /dev/null
+++ b/Fix-DateTimeError.ps1
@@ -0,0 +1,74 @@
+# Fix for the DateTime conversion error in Add-IntuneWin32App
+
+Write-Host "Checking current authentication state..." -ForegroundColor Yellow
+
+# Check the current global variables
+Write-Host "`nGlobal:AccessToken type: $($Global:AccessToken.GetType().FullName)" -ForegroundColor Cyan
+Write-Host "Global:AccessToken properties:" -ForegroundColor Cyan
+$Global:AccessToken | Get-Member -MemberType Properties | Format-Table
+
+Write-Host "`nGlobal:AuthenticationHeader:" -ForegroundColor Cyan
+$Global:AuthenticationHeader | Format-Table
+
+# The issue is that the IntuneWin32App module might be expecting additional properties
+# Let's check what Add-IntuneWin32App is actually receiving
+
+# Test creating a minimal app to see what fails
+Write-Host "`nTesting minimal Add-IntuneWin32App call..." -ForegroundColor Yellow
+
+try {
+    # First, let's see if we can query existing apps
+    $existingApps = Get-IntuneWin32App -ErrorAction SilentlyContinue
+    if ($existingApps) {
+        Write-Host "Found $($existingApps.Count) existing apps" -ForegroundColor Green
+    }
+    else {
+        Write-Host "No existing apps found or unable to query" -ForegroundColor Yellow
+    }
+}
+catch {
+    Write-Host "Error querying apps: $_" -ForegroundColor Red
+}
+
+# The real issue might be that we need to ensure the module has the correct internal state
+# Let's check the module's internal variables
+Write-Host "`nChecking IntuneWin32App module internal state..." -ForegroundColor Yellow
+
+# Get the module
+$module = Get-Module IntuneWin32App
+if ($module) {
+    Write-Host "Module version: $($module.Version)" -ForegroundColor Cyan
+    
+    # Check if there are any internal functions we can use
+    $commands = Get-Command -Module IntuneWin32App
+    Write-Host "Available commands: $($commands.Count)" -ForegroundColor Cyan
+}
+
+# Potential fix: Ensure the AccessToken has all required properties
+Write-Host "`nApplying DateTime fix..." -ForegroundColor Yellow
+
+# The issue might be that ExpiresOn needs to be a specific type
+if ($Global:AccessToken.ExpiresOn -is [string]) {
+    Write-Host "Converting ExpiresOn from string to DateTime..." -ForegroundColor Yellow
+    
+    # Create a new token object with proper DateTime
+    $fixedToken = [PSCustomObject]@{
+        AccessToken = $Global:AccessToken.AccessToken
+        TokenType = $Global:AccessToken.TokenType
+        ExpiresOn = [DateTime]::Parse($Global:AccessToken.ExpiresOn)
+        TenantId = $Global:AccessTokenTenantID
+    }
+    
+    # Replace the global token
+    $Global:AccessToken = $fixedToken
+    Write-Host "AccessToken fixed with proper DateTime" -ForegroundColor Green
+}
+
+# Also ensure the authentication header has proper format
+if ($Global:AuthenticationHeader.ExpiresOn -is [string]) {
+    $Global:AuthenticationHeader.ExpiresOn = [DateTime]::Parse($Global:AuthenticationHeader.ExpiresOn).ToString()
+}
+
+Write-Host "`nAuthentication state after fix:" -ForegroundColor Green
+Write-Host "AccessToken.ExpiresOn type: $($Global:AccessToken.ExpiresOn.GetType().FullName)" -ForegroundColor Cyan
+Write-Host "AccessToken.ExpiresOn value: $($Global:AccessToken.ExpiresOn)" -ForegroundColor Cyan
\ No newline at end of file
diff --git a/Fix-IntuneWin32AppAuth.ps1 b/Fix-IntuneWin32AppAuth.ps1
new file mode 100644
index 0000000..b1fae98
--- /dev/null
+++ b/Fix-IntuneWin32AppAuth.ps1
@@ -0,0 +1,136 @@
+function Initialize-IntuneWin32AppAuthentication {
+    <#
+    .SYNOPSIS
+    Establishes authentication for IntuneWin32App module using certificate authentication
+    
+    .DESCRIPTION
+    This function bypasses the IntuneWin32App module's Connect-MSIntuneGraph function
+    and directly sets up the required global variables using MSAL.PS
+    #>
+    [CmdletBinding()]
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$TenantID,
+        
+        [Parameter(Mandatory = $true)]
+        [string]$ClientID,
+        
+        [Parameter(Mandatory = $true)]
+        [string]$CertPath,
+        
+        [Parameter(Mandatory = $true)]
+        [string]$CertPassword
+    )
+    
+    try {
+        Write-Host "Initializing IntuneWin32App authentication..." -ForegroundColor Yellow
+        
+        # Clear any existing authentication
+        $Global:AccessToken = $null
+        $Global:AuthenticationHeader = $null
+        $Global:AccessTokenTenantID = $null
+        
+        # Load certificate
+        $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($CertPath, $CertPassword)
+        Write-Host "Certificate loaded. Thumbprint: $($cert.Thumbprint)" -ForegroundColor Green
+        
+        # Import MSAL.PS module
+        Import-Module MSAL.PS -ErrorAction Stop
+        
+        # Get token using MSAL.PS
+        $msalToken = Get-MsalToken -TenantId $TenantID -ClientId $ClientID -ClientCertificate $cert
+        
+        if ($msalToken) {
+            # The IntuneWin32App module expects these specific global variables
+            # We need to create a compatible object structure
+            
+            # Store the raw MSAL token
+            $Global:AccessToken = $msalToken
+            $Global:AccessTokenTenantID = $TenantID
+            
+            # Create the authentication header that IntuneWin32App functions expect
+            # This is the key - we create the header manually in the format expected
+            $Global:AuthenticationHeader = @{
+                "Content-Type" = "application/json"
+                "Authorization" = "Bearer $($msalToken.AccessToken)"
+                "ExpiresOn" = $msalToken.ExpiresOn.UtcDateTime
+            }
+            
+            # Store certificate info for potential re-authentication
+            $Global:TenantId = $TenantID
+            $Global:ClientId = $ClientID
+            $Global:CertPath = $CertPath
+            $Global:CertPassword = $CertPassword
+            $Global:CertObject = $cert
+            
+            Write-Host "Authentication successful!" -ForegroundColor Green
+            Write-Host "Token expires at: $($msalToken.ExpiresOn)" -ForegroundColor Cyan
+            
+            # Test the authentication by making a simple Graph call
+            try {
+                $testUri = "https://graph.microsoft.com/v1.0/organization"
+                $testResult = Invoke-RestMethod -Uri $testUri -Headers $Global:AuthenticationHeader -Method Get -ErrorAction Stop
+                Write-Host "Authentication verified - successfully connected to tenant: $($testResult.value[0].displayName)" -ForegroundColor Green
+            }
+            catch {
+                Write-Warning "Authentication test failed: $_"
+            }
+            
+            return $true
+        }
+        else {
+            throw "Failed to obtain access token from MSAL.PS"
+        }
+    }
+    catch {
+        Write-Host "Authentication initialization failed: $($_.Exception.Message)" -ForegroundColor Red
+        Write-Host "Full error: $_" -ForegroundColor Red
+        return $false
+    }
+}
+
+# Updated version of your main script's authentication section
+function Invoke-UpdatedAuthentication {
+    param(
+        [string]$TenantId,
+        [string]$ClientId,
+        [string]$CertPath,
+        [string]$CertPassword
+    )
+    
+    Write-EnhancedLog -Message "Starting updated authentication process..." -Level "INFO"
+    
+    # First, try the direct MSAL approach
+    $authParams = @{
+        TenantID = $TenantId
+        ClientID = $ClientId
+        CertPath = $CertPath
+        CertPassword = $CertPassword
+    }
+    
+    $authSuccess = Initialize-IntuneWin32AppAuthentication @authParams
+    
+    if (-not $authSuccess) {
+        Write-EnhancedLog -Message "Primary authentication failed. Attempting fallback to interactive..." -Level "WARNING"
+        
+        # Try interactive as fallback
+        try {
+            # Load the IntuneWin32App module if not already loaded
+            Import-Module IntuneWin32App -ErrorAction Stop
+            
+            # Use interactive authentication
+            Connect-MSIntuneGraph -TenantID $TenantId -Interactive
+            
+            if ($Global:AuthenticationHeader) {
+                Write-EnhancedLog -Message "Interactive authentication successful" -Level "INFO"
+                $authSuccess = $true
+            }
+        }
+        catch {
+            Write-EnhancedLog -Message "All authentication methods failed: $_" -Level "ERROR"
+            throw "Cannot establish authentication with Microsoft Graph"
+        }
+    }
+    
+    return $authSuccess
+}
\ No newline at end of file
diff --git a/Fix-MSIntuneGraphAuth.ps1 b/Fix-MSIntuneGraphAuth.ps1
new file mode 100644
index 0000000..6bcfc43
--- /dev/null
+++ b/Fix-MSIntuneGraphAuth.ps1
@@ -0,0 +1,114 @@
+function Connect-MSIntuneGraphFixed {
+    [CmdletBinding()]
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$TenantID,
+        
+        [Parameter(Mandatory = $true)]
+        [string]$ClientID,
+        
+        [Parameter(Mandatory = $true)]
+        [System.Security.Cryptography.X509Certificates.X509Certificate2]$ClientCert
+    )
+    
+    try {
+        Write-Host "Attempting fixed authentication with MSAL.PS..." -ForegroundColor Yellow
+        
+        # Import MSAL.PS module
+        Import-Module MSAL.PS -ErrorAction Stop
+        
+        # Create parameters with exact casing that MSAL.PS expects
+        $msalParams = @{
+            TenantId         = $TenantID
+            ClientId         = $ClientID
+            ClientCertificate = $ClientCert
+        }
+        
+        # Get the access token directly using MSAL.PS
+        $token = Get-MsalToken @msalParams
+        
+        # Set global variables that IntuneWin32App module expects
+        $Global:AccessToken = $token
+        $Global:AccessTokenTenantID = $TenantID
+        
+        # Create authentication header
+        $Global:AuthenticationHeader = @{
+            "Authorization" = "Bearer $($token.AccessToken)"
+            "Content-Type" = "application/json"
+            "ExpiresOn" = $token.ExpiresOn.DateTime
+        }
+        
+        Write-Host "Authentication successful!" -ForegroundColor Green
+        return $true
+    }
+    catch {
+        Write-Host "Authentication failed: $_" -ForegroundColor Red
+        return $false
+    }
+}
+
+# Alternative: Direct MSAL authentication bypassing IntuneWin32App's Connect function
+function Set-IntuneAuthenticationDirect {
+    [CmdletBinding()]
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$TenantID,
+        
+        [Parameter(Mandatory = $true)]
+        [string]$ClientID,
+        
+        [Parameter(Mandatory = $true)]
+        [string]$CertPath,
+        
+        [Parameter(Mandatory = $true)]
+        [string]$CertPassword
+    )
+    
+    try {
+        # Load certificate
+        $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($CertPath, $CertPassword)
+        Write-Host "Certificate loaded successfully. Thumbprint: $($cert.Thumbprint)" -ForegroundColor Green
+        
+        # Import required module
+        Import-Module MSAL.PS -ErrorAction Stop
+        
+        # Get token with explicit parameter construction
+        $tokenParams = @{}
+        $tokenParams['TenantId'] = $TenantID
+        $tokenParams['ClientId'] = $ClientID
+        $tokenParams['ClientCertificate'] = $cert
+        
+        Write-Host "Requesting token from Azure AD..." -ForegroundColor Yellow
+        $token = Get-MsalToken @tokenParams
+        
+        if ($token) {
+            # Set all the global variables that IntuneWin32App module expects
+            $Global:AccessToken = $token
+            $Global:AccessTokenTenantID = $TenantID
+            $Global:AuthenticationHeader = @{
+                "Authorization" = "Bearer $($token.AccessToken)"
+                "Content-Type" = "application/json"
+                "ExpiresOn" = $token.ExpiresOn.DateTime
+            }
+            
+            Write-Host "Authentication successful! Token expires at: $($token.ExpiresOn)" -ForegroundColor Green
+            
+            # Store for reconnection
+            $Global:TenantId = $TenantID
+            $Global:ClientId = $ClientID
+            $Global:CertPath = $CertPath
+            $Global:CertPassword = $CertPassword
+            $Global:CertObject = $cert
+            
+            return $true
+        }
+        else {
+            throw "Failed to obtain access token"
+        }
+    }
+    catch {
+        Write-Host "Direct authentication failed: $_" -ForegroundColor Red
+        Write-Host "Error details: $($_.Exception.Message)" -ForegroundColor Red
+        return $false
+    }
+}
\ No newline at end of file
diff --git a/Get-AuthTokenPS7.ps1 b/Get-AuthTokenPS7.ps1
new file mode 100644
index 0000000..3167d5e
--- /dev/null
+++ b/Get-AuthTokenPS7.ps1
@@ -0,0 +1,73 @@
+# This script runs in PowerShell 7 to get the authentication token
+# It saves the token to a file that the main PS5 script can read
+
+param(
+    [string]$SecretsPath = "C:\Code\Intune-Win32-Deployer\secrets\Lion's Housing Centres\secrets.json"
+)
+
+# Ensure we're running in PowerShell 7
+if ($PSVersionTable.PSVersion.Major -lt 7) {
+    Write-Host "This script must run in PowerShell 7 or higher" -ForegroundColor Red
+    Write-Host "Current version: $($PSVersionTable.PSVersion)" -ForegroundColor Yellow
+    exit 1
+}
+
+Write-Host "Running in PowerShell $($PSVersionTable.PSVersion)" -ForegroundColor Green
+
+# Import MSAL.PS
+Import-Module MSAL.PS -ErrorAction Stop
+
+# Load secrets
+$secrets = Get-Content $SecretsPath -Raw | ConvertFrom-Json
+$tenantId = $secrets.TenantID
+$clientId = $secrets.ClientId
+$certPassword = $secrets.CertPassword
+
+# Construct certificate path
+$outputPath = $secrets.OutputPath
+$certName = $secrets.CertName
+$certPath = Join-Path $outputPath "$certName-$clientId.pfx"
+
+Write-Host "Loading certificate from: $certPath" -ForegroundColor Cyan
+
+# Load certificate - PS7 handles CNG certificates better
+$cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new($certPath, $certPassword)
+Write-Host "Certificate loaded. Thumbprint: $($cert.Thumbprint)" -ForegroundColor Green
+
+# Get token
+Write-Host "Requesting token from Azure AD..." -ForegroundColor Yellow
+$msalToken = Get-MsalToken -TenantId $tenantId -ClientId $clientId -ClientCertificate $cert
+
+if ($msalToken) {
+    Write-Host "Token obtained successfully!" -ForegroundColor Green
+    
+    # Create a simplified token object that PS5 can use
+    $tokenData = @{
+        AccessToken = $msalToken.AccessToken
+        ExpiresOn = $msalToken.ExpiresOn.ToString("o")  # ISO 8601 format
+        TenantId = $tenantId
+        ClientId = $clientId
+        TokenType = "Bearer"
+    }
+    
+    # Save to a temporary file
+    $tokenFile = Join-Path $env:TEMP "intune_auth_token.json"
+    $tokenData | ConvertTo-Json | Set-Content $tokenFile -Force
+    
+    Write-Host "Token saved to: $tokenFile" -ForegroundColor Green
+    Write-Host "Token expires at: $($msalToken.ExpiresOn)" -ForegroundColor Cyan
+    
+    # Test the token
+    $headers = @{
+        "Authorization" = "Bearer $($msalToken.AccessToken)"
+        "Content-Type" = "application/json"
+    }
+    
+    $testUri = "https://graph.microsoft.com/v1.0/organization"
+    $testResult = Invoke-RestMethod -Uri $testUri -Headers $headers -Method Get
+    Write-Host "Token verified - Connected to: $($testResult.value[0].displayName)" -ForegroundColor Green
+}
+else {
+    Write-Host "Failed to obtain token!" -ForegroundColor Red
+    exit 1
+}
\ No newline at end of file
diff --git a/Intune-Win32-Deployer-ALPHAv1-UPDATED.ps1 b/Intune-Win32-Deployer-ALPHAv1-UPDATED.ps1
new file mode 100644
index 0000000..b1a194c
--- /dev/null
+++ b/Intune-Win32-Deployer-ALPHAv1-UPDATED.ps1
@@ -0,0 +1,640 @@
+#############################################################################################################
+#
+#   Tool:           Intune Win32 Deployer
+#   Author:         Abdullah Ollivierre
+#   Website:        https://github.com/aollivierre
+#   Twitter:        https://x.com/ollivierre
+#   LinkedIn:       https://www.linkedin.com/in/aollivierre
+#
+#   Description:    https://github.com/aollivierre
+#
+#############################################################################################################
+
+<#
+    .SYNOPSIS
+    Packages any custom app for MEM (Intune) deployment.
+    Uploads the packaged into the target Intune tenant.
+
+    .NOTES
+    For details on IntuneWin32App go here: https://github.com/aollivierre
+
+#>
+
+
+#region RE-LAUNCH SCRIPT IN POWERSHELL 5 FUNCTION
+#################################################################################################
+#                                                                                               #
+#                           RE-LAUNCH SCRIPT IN POWERSHELL 5 FUNCTION                           #
+#                                                                                               #
+#################################################################################################
+
+function Relaunch-InPowerShell5 {
+    # Check the current version of PowerShell
+    if ($PSVersionTable.PSVersion.Major -ge 7) {
+        Write-Host "Hello from PowerShell 7"
+
+        # Get the script path (works inside a function as well)
+        $scriptPath = $PSCommandPath
+
+        # $scriptPath = $MyInvocation.MyCommand.Definition
+        $ps5Path = "$($env:SystemRoot)\System32\WindowsPowerShell\v1.0\powershell.exe"
+
+        # Build the argument to relaunch this script in PowerShell 5 with -NoExit
+        $ps5Args = "-NoExit -NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`""
+
+        Write-Host "Relaunching in PowerShell 5..."
+        Start-Process -FilePath $ps5Path -ArgumentList $ps5Args
+
+        # Exit the current PowerShell 7 session to allow PowerShell 5 to take over
+        exit
+    }
+
+    # If relaunching in PowerShell 5
+    Write-Host "Hello from PowerShell 5"
+}
+
+Relaunch-InPowerShell5
+
+
+#endregion RE-LAUNCH SCRIPT IN POWERSHELL 5 FUNCTION
+#################################################################################################
+#                                                                                               #
+#                           END OF RE-LAUNCH SCRIPT IN POWERSHELL 5 FUNCTION                    #
+#                                                                                               #
+#################################################################################################
+
+
+# Set environment variable globally for all users
+[System.Environment]::SetEnvironmentVariable('EnvironmentMode', 'dev', 'Machine')
+
+# Retrieve the environment mode (default to 'prod' if not set)
+$mode = $env:EnvironmentMode
+
+#region FIRING UP MODULE STARTER
+#################################################################################################
+#                                                                                               #
+#                                 FIRING UP MODULE STARTER                                      #
+#                                                                                               #
+#################################################################################################
+
+# Invoke-Expression (Invoke-RestMethod "https://raw.githubusercontent.com/aollivierre/module-starter/main/Install-EnhancedModuleStarterAO.ps1")
+
+# Wait-Debugger
+
+# Define a hashtable for splatting
+$moduleStarterParams = @{
+    Mode                   = 'dev'
+    SkipPSGalleryModules   = $true
+    SkipCheckandElevate    = $true
+    SkipPowerShell7Install = $true
+    SkipEnhancedModules    = $true
+    SkipGitRepos           = $true
+}
+
+# Call the function using the splat
+Invoke-ModuleStarter @moduleStarterParams
+
+
+
+
+# Define a hashtable for splatting
+# $moduleStarterParams = @{
+#     Mode                   = 'PROD'
+#     SkipPSGalleryModules   = $FALSE
+#     SkipCheckandElevate    = $FALSE
+#     SkipPowerShell7Install = $FALSE
+#     SkipEnhancedModules    = $FALSE
+#     SkipGitRepos           = $true
+# }
+
+# # Call the function using the splat
+# Invoke-ModuleStarter @moduleStarterParams
+
+
+# Wait-Debugger
+
+#endregion FIRING UP MODULE STARTER
+
+# Toggle based on the environment mode
+switch ($mode) {
+    'dev' {
+        Write-EnhancedLog -Message "Running in development mode" -Level 'WARNING'
+        # Your development logic here
+    }
+    'prod' {
+        Write-EnhancedLog -Message "Running in production mode" -ForegroundColor Green
+        # Your production logic here
+    }
+    default {
+        Write-EnhancedLog -Message "Unknown mode. Defaulting to production." -ForegroundColor Red
+        # Default to production
+    }
+}
+
+
+
+#region HANDLE PSF MODERN LOGGING
+#################################################################################################
+#                                                                                               #
+#                            HANDLE PSF MODERN LOGGING                                          #
+#                                                                                               #
+#################################################################################################
+Set-PSFConfig -Fullname 'PSFramework.Logging.FileSystem.ModernLog' -Value $true -PassThru | Register-PSFConfig -Scope SystemDefault
+
+# Define the base logs path and job name
+$JobName = "Win32AppDeployer"
+$parentScriptName = Get-ParentScriptName
+Write-EnhancedLog -Message "Parent Script Name: $parentScriptName"
+
+# Call the Get-PSFCSVLogFilePath function to generate the dynamic log file path
+$paramGetPSFCSVLogFilePath = @{
+    LogsPath         = 'C:\Logs\PSF'
+    JobName          = $jobName
+    parentScriptName = $parentScriptName
+}
+
+$csvLogFilePath = Get-PSFCSVLogFilePath @paramGetPSFCSVLogFilePath
+
+$instanceName = "$parentScriptName-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
+
+# Configure the PSFramework logging provider to use CSV format
+$paramSetPSFLoggingProvider = @{
+    Name            = 'logfile'
+    InstanceName    = $instanceName  # Use a unique instance name
+    FilePath        = $csvLogFilePath  # Use the dynamically generated file path
+    Enabled         = $true
+    FileType        = 'CSV'
+    EnableException = $true
+}
+Set-PSFLoggingProvider @paramSetPSFLoggingProvider
+#endregion HANDLE PSF MODERN LOGGING
+
+
+#region HANDLE Transript LOGGING
+#################################################################################################
+#                                                                                               #
+#                            HANDLE Transript LOGGING                                           #
+#                                                                                               #
+#################################################################################################
+# Start the script with error handling
+try {
+    # Generate the transcript file path
+    $GetTranscriptFilePathParams = @{
+        TranscriptsPath  = "C:\Logs\Transcript"
+        JobName          = $jobName
+        parentScriptName = $parentScriptName
+    }
+    $transcriptPath = Get-TranscriptFilePath @GetTranscriptFilePathParams
+    
+    # Start the transcript
+    Write-EnhancedLog -Message "Starting transcript at: $transcriptPath"
+    Start-Transcript -Path $transcriptPath
+}
+catch {
+    Write-EnhancedLog -Message "An error occurred during script execution: $_" -Level 'ERROR'
+    if ($transcriptPath) {
+        Stop-Transcript
+        Write-EnhancedLog -Message "Transcript stopped." -ForegroundColor Cyan
+        # Stop logging in the finally block
+
+    }
+    else {
+        Write-EnhancedLog -Message "Transcript was not started due to an earlier error." -ForegroundColor Red
+    }
+
+    # Stop PSF Logging
+
+    # Ensure the log is written before proceeding
+    Wait-PSFMessage
+
+    # Stop logging in the finally block by disabling the provider
+    Set-PSFLoggingProvider -Name 'logfile' -InstanceName $instanceName -Enabled $false
+
+    Handle-Error -ErrorRecord $_
+    throw $_  # Re-throw the error after logging it
+}
+#endregion HANDLE Transript LOGGING
+
+try {
+    #region Script Logic
+    #################################################################################################
+    #                                                                                               #
+    #                                    Script Logic                                               #
+    #                                                                                               #
+    #################################################################################################
+
+
+    #region LOADING SECRETS FOR GRAPH
+    #################################################################################################
+    #                                                                                               #
+    #                                 LOADING SECRETS FOR GRAPH                                     #
+    #                                                                                               #
+    #################################################################################################
+
+    # Define a function to process a single tenant
+    function Process-SingleTenant {
+        param(
+            [string]$TenantPath,
+            [string]$TenantName,
+            [object]$Config,
+            [string]$ScriptRoot
+        )
+        
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+        Write-EnhancedLog -Message "Processing tenant: $TenantName" -Level 'INFO'
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+        Write-EnhancedLog -Message "Tenant path: $TenantPath" -Level 'INFO'
+        
+        # Define paths for the secrets.json and PFX files
+        $secretsJsonPath = Join-Path -Path $TenantPath -ChildPath "secrets.json"
+        $pfxFiles = Get-ChildItem -Path $TenantPath -Filter *.pfx
+
+        # Check if secrets.json exists
+        if (-Not (Test-Path -Path $secretsJsonPath)) {
+            Write-Error "secrets.json file not found in '$TenantPath'."
+            throw "secrets.json file not found"
+        }
+
+        # Load the secrets from the JSON file
+        Write-EnhancedLog -Message "Loading secrets from: $secretsJsonPath" -Level 'INFO'
+        $secrets = Get-Content -Path $secretsJsonPath -Raw | ConvertFrom-Json
+
+        # Debug: List all available properties in secrets
+        Write-EnhancedLog -Message "Available properties in secrets file:" -Level 'INFO'
+        $secrets.PSObject.Properties | ForEach-Object {
+            Write-EnhancedLog -Message "Property: $($_.Name) = $($_.Value)" -Level 'INFO'
+        }
+
+        # Check if a PFX file exists
+        if ($pfxFiles.Count -eq 0) {
+            Write-Error "No PFX file found in the '$TenantPath' directory."
+            throw "No PFX file found"
+        }
+        elseif ($pfxFiles.Count -gt 1) {
+            Write-Error "Multiple PFX files found in the '$TenantPath' directory. Please ensure there is only one PFX file."
+            throw "Multiple PFX files found"
+        }
+
+        # Use the first (and presumably only) PFX file found
+        $certPath = $pfxFiles[0].FullName
+        Write-EnhancedLog -Message "PFX file found: $certPath" -Level 'INFO'
+
+        # Assign values from JSON to variables with detailed logging
+        Write-EnhancedLog -Message "Attempting to load TenantID..." -Level 'INFO'
+        $tenantId = $secrets.PSObject.Properties['TenantID'].Value
+        Write-EnhancedLog -Message "Loaded TenantID: $tenantId" -Level 'INFO'
+
+        Write-EnhancedLog -Message "Attempting to load ClientId..." -Level 'INFO'
+        $clientId = $secrets.PSObject.Properties['ClientId'].Value
+        Write-EnhancedLog -Message "Loaded ClientId: $clientId" -Level 'INFO'
+
+        Write-EnhancedLog -Message "Attempting to load CertPassword..." -Level 'INFO'
+        $CertPassword = $secrets.PSObject.Properties['CertPassword'].Value
+        Write-EnhancedLog -Message "CertPassword loaded (value hidden for security)" -Level 'INFO'
+
+        # Validate the required values with detailed error messages
+        if ([string]::IsNullOrWhiteSpace($tenantId)) {
+            Write-EnhancedLog -Message "TenantID is missing or empty in secrets.json" -Level 'ERROR'
+            throw "TenantID is missing or empty in secrets.json"
+        }
+        if ([string]::IsNullOrWhiteSpace($clientId)) {
+            Write-EnhancedLog -Message "ClientId is missing or empty in secrets.json" -Level 'ERROR'
+            throw "ClientId is missing or empty in secrets.json"
+        }
+        if ([string]::IsNullOrWhiteSpace($CertPassword)) {
+            Write-EnhancedLog -Message "CertPassword is missing or empty in secrets.json" -Level 'ERROR'
+            throw "CertPassword is missing or empty in secrets.json"
+        }
+
+        Write-EnhancedLog -Message "Successfully loaded all required authentication details from secrets.json" -Level 'INFO'
+        Write-EnhancedLog -Message "TenantID length: $($tenantId.Length) characters" -Level 'INFO'
+        Write-EnhancedLog -Message "ClientId length: $($clientId.Length) characters" -Level 'INFO'
+        Write-EnhancedLog -Message "CertPassword length: $($CertPassword.Length) characters" -Level 'INFO'
+
+        #endregion LOADING SECRETS FOR GRAPH
+
+        # Call the function to initialize the environment
+        $envInitialization = Initialize-Win32Environment -scriptpath $ScriptRoot
+
+        # Access the properties of the EnvDetails object
+        $AOscriptDirectory = $envInitialization.EnvDetails.AOscriptDirectory
+        $directoryPath = $envInitialization.EnvDetails.directoryPath
+        $Repo_Path = $envInitialization.EnvDetails.Repo_Path
+        $Repo_winget = $envInitialization.EnvDetails.Repo_winget
+
+        # Output the extracted values
+        Write-EnhancedLog -Message "Global variables set by Initialize-Win32Environment" -Level 'INFO'
+        Write-EnhancedLog -Message "AO Script Directory: $AOscriptDirectory"
+        Write-EnhancedLog -Message "Directory Path: $directoryPath"
+        Write-EnhancedLog -Message "Repository Path: $Repo_Path"
+        Write-EnhancedLog -Message "Winget Path: $Repo_winget"
+
+        # Example usage of global variables outside the function
+        Write-EnhancedLog -Message "scriptBasePath: $scriptBasePath" -Level 'INFO'
+        Write-EnhancedLog -Message "modulesBasePath: $modulesBasePath" -Level 'INFO'
+        Write-EnhancedLog -Message "modulePath: $modulePath" -Level 'INFO'
+
+        Remove-IntuneWinFiles -DirectoryPath $directoryPath
+
+        #to address this bug in https://github.com/MSEndpointMgr/IntuneWin32App/issues/155 use the following function to update the Invoke-AzureStorageBlobUploadFinalize.ps1
+        Copy-InvokeAzureStorageBlobUploadFinalize
+
+        ##########################################################################################################################
+        ############################################STARTING THE MAIN FUNCTION LOGIC HERE#########################################
+        ##########################################################################################################################
+
+        ################################################################################################################################
+        ################################################ START GRAPH CONNECTING ########################################################
+        ################################################################################################################################
+
+        try {
+            # Log the values right before connecting
+            Write-EnhancedLog -Message "Preparing to connect with the following values:" -Level 'INFO'
+            Write-EnhancedLog -Message "TenantID: $tenantId" -Level 'INFO'
+            Write-EnhancedLog -Message "ClientID: $clientId" -Level 'INFO'
+            Write-EnhancedLog -Message "CertPath: $certPath" -Level 'INFO'
+            Write-EnhancedLog -Message "CertPassword length: $($CertPassword.Length)" -Level 'INFO'
+
+            # Create hashtable for splatting with explicit string conversions
+            $graphParams = @{
+                tenantId = [string]$tenantId
+                clientId = [string]$clientId
+                certPath = [string]$certPath
+                certPassword = [string]$CertPassword
+                ConnectToIntune = $true
+                ConnectToTeams = $false
+            }
+
+            # Log the hashtable values
+            Write-EnhancedLog -Message "Checking splat parameters:" -Level 'INFO'
+            Write-EnhancedLog -Message "tenantId from splat: $($graphParams.tenantId)" -Level 'INFO'
+            Write-EnhancedLog -Message "clientId from splat: $($graphParams.clientId)" -Level 'INFO'
+            Write-EnhancedLog -Message "certPath from splat: $($graphParams.certPath)" -Level 'INFO'
+
+            # Attempt to connect using the certificate for custom operations
+            Write-EnhancedLog -Message "Attempting to connect to Microsoft Graph using certificate authentication..." -Level "INFO"
+            $accessToken = Connect-GraphWithCert @graphParams
+            Write-EnhancedLog -Message "Connected using certificate authentication for custom operations. Access token obtained." -Level "INFO"
+            
+            # CRITICAL: Also authenticate with IntuneWin32App module
+            Write-EnhancedLog -Message "Establishing authentication with IntuneWin32App module..." -Level "INFO"
+            try {
+                # Clear any existing authentication state first
+                Write-EnhancedLog -Message "Clearing any existing IntuneWin32App authentication state..." -Level "INFO"
+                $Global:AccessToken = $null
+                $Global:AuthenticationHeader = $null
+                $Global:AccessTokenTenantID = $null
+                
+                # Extract certificate thumbprint
+                $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certPath, $CertPassword)
+                $certThumbprint = $cert.Thumbprint
+                Write-EnhancedLog -Message "Certificate thumbprint: $certThumbprint" -Level "INFO"
+                Write-EnhancedLog -Message "Certificate subject: $($cert.Subject)" -Level "INFO"
+                
+                # Store the certificate object globally for later use
+                $Global:CertObject = $cert
+                
+                # Connect using IntuneWin32App module - pass the certificate object directly
+                Write-EnhancedLog -Message "Calling Connect-MSIntuneGraph with TenantID: $tenantId, ClientID: $clientId" -Level "INFO"
+                Connect-MSIntuneGraph -TenantID $tenantId -ClientID $clientId -ClientCert $cert
+                Write-EnhancedLog -Message "Successfully authenticated with IntuneWin32App module" -Level "INFO"
+            }
+            catch {
+                Write-EnhancedLog -Message "Failed to authenticate with IntuneWin32App module: $($_.Exception.Message)" -Level "WARNING"
+                Write-EnhancedLog -Message "Will attempt interactive authentication if needed later" -Level "INFO"
+            }
+        
+            # Attempt to get tenant details
+            Write-EnhancedLog -Message "Attempting to retrieve tenant details..." -Level "INFO"
+            $tenantDetails = Get-TenantDetails
+
+            # Check if tenant details are retrieved successfully
+            if ($null -eq $tenantDetails) {
+                Write-EnhancedLog -Message "Tenant details could not be retrieved." -Level 'WARNING'
+            }
+            Write-EnhancedLog -Message "Tenant details retrieved successfully." -Level "INFO"
+        }
+        catch {
+            # Handle any errors during certificate-based authentication
+            $errorMessage = "Failed to connect using certificate-based authentication or retrieve tenant details. Reason: $($_.Exception.Message)"
+            Write-EnhancedLog -Message $errorMessage -Level "ERROR"
+            Write-EnhancedLog -Message "Full error details: $($_ | ConvertTo-Json)" -Level "ERROR"
+
+            # Log that we are falling back to interactive authentication
+            Write-EnhancedLog -Message "Falling back to interactive authentication..." -Level "WARNING"
+
+            try {
+                Write-EnhancedLog -Message "Attempting interactive authentication with TenantID: $tenantId" -Level "INFO"
+                Connect-MSIntuneGraph -TenantID $tenantId -Interactive
+                Write-EnhancedLog -Message "Interactive authentication successful" -Level "INFO"
+            }
+            catch {
+                Write-EnhancedLog -Message "Interactive authentication failed: $($_.Exception.Message)" -Level "ERROR"
+                Write-EnhancedLog -Message "Full error details: $($_ | ConvertTo-Json)" -Level "ERROR"
+                throw
+            }
+        }
+
+        # Store authentication parameters globally for potential reconnection later
+        $Global:TenantId = $tenantId
+        $Global:ClientId = $clientId
+        $Global:CertPath = $certPath
+        $Global:CertPassword = $CertPassword
+        Write-EnhancedLog -Message "Stored authentication parameters globally for reconnection purposes" -Level "INFO"
+        
+        # Verify IntuneWin32App module authentication
+        if ($null -eq $Global:AuthenticationHeader) {
+            Write-EnhancedLog -Message "WARNING: IntuneWin32App module authentication header not found" -Level "WARNING"
+            Write-EnhancedLog -Message "Authentication will be attempted when needed during app upload" -Level "INFO"
+        }
+        else {
+            Write-EnhancedLog -Message "IntuneWin32App module authentication verified successfully" -Level "INFO"
+        }
+
+        # Continue with the script logic now that tenant details are retrieved
+        Log-Params -Params @{accessToken = $accessToken; tenantDetails = $tenantDetails }
+
+        # Example output of tenant details
+        $tenantDetails
+
+        #################################################################################################################################
+        ################################################# END Connecting to Graph #######################################################
+        #################################################################################################################################
+ 
+        ####################################################################################
+        #   GO!
+        ####################################################################################
+
+        # Retrieve all folder names in the specified directory
+        $folders = Get-ChildItem -Path $directoryPath -Directory
+
+        foreach ($folder in $folders) {
+
+            $ProcessFolderParams = @{
+                Folder      = $folder
+                config      = $Config
+                Repo_winget = $Repo_winget
+                scriptpath  = $ScriptRoot
+                Repo_Path   = $Repo_Path
+            }
+            
+            $folderDetails = Process-Folder @ProcessFolderParams
+            
+        }
+
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+        Write-EnhancedLog -Message "Completed processing tenant: $TenantName" -Level 'INFO'
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+    }
+
+    # Define the path to the secrets directory
+    $secretsDirPath = Join-Path -Path $PSScriptRoot -ChildPath "secrets"
+
+    # Check if the secrets directory exists
+    if (-Not (Test-Path -Path $secretsDirPath)) {
+        Write-Error "Secrets directory not found at '$secretsDirPath'."
+        throw "Secrets directory not found"
+    }
+
+    # List all folders (tenants) in the secrets directory
+    $tenantFolders = Get-ChildItem -Path $secretsDirPath -Directory
+
+    if ($tenantFolders.Count -eq 0) {
+        Write-Error "No tenant folders found in the secrets directory."
+        throw "No tenant folders found"
+    }
+
+    # Read configuration from the JSON file (do this once, outside tenant processing)
+    $configPath = Join-Path -Path $PSScriptRoot -ChildPath "config.json"
+    $config = Get-Content -Path $configPath -Raw | ConvertFrom-Json
+
+    # Check if we have multiple tenants
+    if ($tenantFolders.Count -eq 1) {
+        # Single tenant - use it automatically without prompting
+        $selectedTenant = $tenantFolders[0].Name
+        $selectedTenantPath = $tenantFolders[0].FullName
+        Write-Host "Using tenant: $selectedTenant" -ForegroundColor Green
+        
+        # Process the single tenant
+        Process-SingleTenant -TenantPath $selectedTenantPath -TenantName $selectedTenant -Config $config -ScriptRoot $PSScriptRoot
+    }
+    else {
+        # Multiple tenants - prompt for selection
+        Write-Host "Available tenant folders:"
+        $tenantFolders | ForEach-Object -Begin { $i = 1 } -Process {
+            Write-Host "$i. $($_.Name)"
+            $i++
+        }
+        Write-Host "$($tenantFolders.Count + 1). All tenants" -ForegroundColor Cyan
+
+        # Prompt user for selection
+        do {
+            $selection = Read-Host "Enter the number of the tenant folder you want to use (1-$($tenantFolders.Count + 1))"
+            
+            # Validate the input is a number
+            if ($selection -match '^\d+$') {
+                $selectedNumber = [int]$selection
+            } else {
+                $selectedNumber = -1
+            }
+            
+            # Check if selection is within valid range
+            if ($selectedNumber -lt 1 -or $selectedNumber -gt ($tenantFolders.Count + 1)) {
+                Write-Host "Invalid selection. Please enter a number between 1 and $($tenantFolders.Count + 1)." -ForegroundColor Yellow
+            }
+        } while ($selectedNumber -lt 1 -or $selectedNumber -gt ($tenantFolders.Count + 1))
+
+        # Check if user selected "All tenants"
+        if ($selectedNumber -eq ($tenantFolders.Count + 1)) {
+            # Process all tenants
+            Write-Host "You selected: All tenants" -ForegroundColor Green
+            Write-EnhancedLog -Message "Processing all tenants..." -Level 'INFO'
+            
+            $successCount = 0
+            $failureCount = 0
+            
+            foreach ($tenantFolder in $tenantFolders) {
+                try {
+                    Process-SingleTenant -TenantPath $tenantFolder.FullName -TenantName $tenantFolder.Name -Config $config -ScriptRoot $PSScriptRoot
+                    $successCount++
+                }
+                catch {
+                    Write-EnhancedLog -Message "Failed to process tenant '$($tenantFolder.Name)': $_" -Level 'ERROR'
+                    $failureCount++
+                    # Continue with next tenant instead of failing completely
+                    continue
+                }
+            }
+            
+            Write-EnhancedLog -Message "========================================" -Level 'INFO'
+            Write-EnhancedLog -Message "FINAL SUMMARY" -Level 'INFO'
+            Write-EnhancedLog -Message "========================================" -Level 'INFO'
+            Write-EnhancedLog -Message "Total tenants: $($tenantFolders.Count)" -Level 'INFO'
+            Write-EnhancedLog -Message "Successfully processed: $successCount" -Level 'INFO'
+            Write-EnhancedLog -Message "Failed: $failureCount" -Level 'INFO'
+            Write-EnhancedLog -Message "========================================" -Level 'INFO'
+            
+            if ($successCount -eq 0) {
+                Write-Error "No tenants could be processed successfully."
+                throw "No valid tenants found"
+            }
+        }
+        else {
+            # Get the selected tenant folder
+            $selectedIndex = $selectedNumber - 1
+            $selectedTenant = $tenantFolders[$selectedIndex].Name
+            $selectedTenantPath = $tenantFolders[$selectedIndex].FullName
+            
+            Write-Host "You selected: $selectedTenant" -ForegroundColor Green
+            
+            # Process the selected tenant
+            Process-SingleTenant -TenantPath $selectedTenantPath -TenantName $selectedTenant -Config $config -ScriptRoot $PSScriptRoot
+        }
+    }
+
+    #endregion Script Logic
+}
+catch {
+    Write-EnhancedLog -Message "An error occurred during script execution: $_" -Level 'ERROR'
+    if ($transcriptPath) {
+        Stop-Transcript
+        Write-EnhancedLog -Message "Transcript stopped." -ForegroundColor Cyan
+        # Stop logging in the finally block
+
+    }
+    else {
+        Write-EnhancedLog -Message "Transcript was not started due to an earlier error." -ForegroundColor Red
+    }
+
+    # Stop PSF Logging
+
+    # Ensure the log is written before proceeding
+    Wait-PSFMessage
+
+    # Stop logging in the finally block by disabling the provider
+    Set-PSFLoggingProvider -Name 'logfile' -InstanceName $instanceName -Enabled $false
+
+    Handle-Error -ErrorRecord $_
+    throw $_  # Re-throw the error after logging it
+} 
+finally {
+    # Ensure that the transcript is stopped even if an error occurs
+    if ($transcriptPath) {
+        Stop-Transcript
+        Write-EnhancedLog -Message "Transcript stopped." -ForegroundColor Cyan
+        # Stop logging in the finally block
+
+    }
+    else {
+        Write-EnhancedLog -Message "Transcript was not started due to an earlier error." -ForegroundColor Red
+    }
+    # 
+
+    
+    # Ensure the log is written before proceeding
+    Wait-PSFMessage
+
+    # Stop logging in the finally block by disabling the provider
+    Set-PSFLoggingProvider -Name 'logfile' -InstanceName $instanceName -Enabled $false
+
+}
\ No newline at end of file
diff --git a/Intune-Win32-Deployer-ALPHAv1.ps1 b/Intune-Win32-Deployer-ALPHAv1.ps1
index 4da1475..ac49db4 100644
--- a/Intune-Win32-Deployer-ALPHAv1.ps1
+++ b/Intune-Win32-Deployer-ALPHAv1.ps1
@@ -53,7 +53,7 @@ function Relaunch-InPowerShell5 {
     Write-Host "Hello from PowerShell 5"
 }
 
-Relaunch-InPowerShell5
+
 
 
 #endregion RE-LAUNCH SCRIPT IN POWERSHELL 5 FUNCTION
@@ -97,7 +97,6 @@ Invoke-ModuleStarter @moduleStarterParams
 
 
 
-
 # Define a hashtable for splatting
 # $moduleStarterParams = @{
 #     Mode                   = 'PROD'
@@ -232,435 +231,505 @@ try {
     #                                                                                               #
     #################################################################################################
 
+    # Define a function to process a single tenant
+    function Process-SingleTenant {
+        param(
+            [string]$TenantPath,
+            [string]$TenantName,
+            [object]$Config,
+            [string]$ScriptRoot
+        )
+        
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+        Write-EnhancedLog -Message "Processing tenant: $TenantName" -Level 'INFO'
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+        Write-EnhancedLog -Message "Tenant path: $TenantPath" -Level 'INFO'
+        
+        # Define paths for the secrets.json and PFX files
+        $secretsJsonPath = Join-Path -Path $TenantPath -ChildPath "secrets.json"
+        $pfxFiles = Get-ChildItem -Path $TenantPath -Filter *.pfx
+
+        # Check if secrets.json exists
+        if (-Not (Test-Path -Path $secretsJsonPath)) {
+            Write-Error "secrets.json file not found in '$TenantPath'."
+            throw "secrets.json file not found"
+        }
 
-    #     Start
-    #   |
-    #   v
-    # Check if secrets directory exists
-    #   |
-    #   +-- [Yes] --> Check if tenant folders exist
-    #   |                |
-    #   |                +-- [Yes] --> List tenant folders
-    #   |                |                |
-    #   |                |                v
-    #   |                |       Display list and prompt user for tenant selection
-    #   |                |                |
-    #   |                |                v
-    #   |                |       Validate user's selected tenant folder
-    #   |                |                |
-    #   |                |                +-- [Valid] --> Check if secrets.json exists
-    #   |                |                |                 |
-    #   |                |                |                 +-- [Yes] --> Load secrets from JSON file
-    #   |                |                |                 |                |
-    #   |                |                |                 |                v
-    #   |                |                |                 |        Check for PFX file
-    #   |                |                |                 |                |
-    #   |                |                |                 |                +-- [Yes] --> Validate single PFX file
-    #   |                |                |                 |                |                 |
-    #   |                |                |                 |                |                 v
-    #   |                |                |                 |                |        Assign values from secrets to variables
-    #   |                |                |                 |                |                 |
-    #   |                |                |                 |                |                 v
-    #   |                |                |                 |                +--> Write log "PFX file found"
-    #   |                |                |                 |
-    #   |                |                |                 +-- [No] --> Error: secrets.json not found
-    #   |                |                |                
-    #   |                |                +-- [Invalid] --> Error: Invalid tenant folder
-    #   |                |                
-    #   |                +-- [No] --> Error: No tenant folders found
-    #   |
-    #   +-- [No] --> Error: Secrets directory not found
-    #   |
-    #   v
-    # End
-
-
-    # Define the path to the secrets directory
-    $secretsDirPath = Join-Path -Path $PSScriptRoot -ChildPath "secrets"
-
-    # Check if the secrets directory exists
-    if (-Not (Test-Path -Path $secretsDirPath)) {
-        Write-Error "Secrets directory not found at '$secretsDirPath'."
-        throw "Secrets directory not found"
-    }
-
-    # List all folders (tenants) in the secrets directory
-    $tenantFolders = Get-ChildItem -Path $secretsDirPath -Directory
+        # Load the secrets from the JSON file
+        Write-EnhancedLog -Message "Loading secrets from: $secretsJsonPath" -Level 'INFO'
+        $secrets = Get-Content -Path $secretsJsonPath -Raw | ConvertFrom-Json
 
-    if ($tenantFolders.Count -eq 0) {
-        Write-Error "No tenant folders found in the secrets directory."
-        throw "No tenant folders found"
-    }
-
-    # Display the list of tenant folders and ask the user to confirm
-    Write-Host "Available tenant folders:"
-    $tenantFolders | ForEach-Object { Write-Host "- $($_.Name)" }
+        # Debug: List all available properties in secrets
+        Write-EnhancedLog -Message "Available properties in secrets file:" -Level 'INFO'
+        $secrets.PSObject.Properties | ForEach-Object {
+            Write-EnhancedLog -Message "Property: $($_.Name) = $($_.Value)" -Level 'INFO'
+        }
 
-    $selectedTenant = Read-Host "Enter the name of the tenant folder you want to use"
+        # Check if a PFX file exists
+        if ($pfxFiles.Count -eq 0) {
+            Write-Error "No PFX file found in the '$TenantPath' directory."
+            throw "No PFX file found"
+        }
+        elseif ($pfxFiles.Count -gt 1) {
+            Write-Error "Multiple PFX files found in the '$TenantPath' directory. Please ensure there is only one PFX file."
+            throw "Multiple PFX files found"
+        }
 
-    # Validate the user's selection
-    $selectedTenantPath = Join-Path -Path $secretsDirPath -ChildPath $selectedTenant
+        # Use the first (and presumably only) PFX file found
+        $certPath = $pfxFiles[0].FullName
+        Write-EnhancedLog -Message "PFX file found: $certPath" -Level 'INFO'
 
-    if (-Not (Test-Path -Path $selectedTenantPath)) {
-        Write-Error "The specified tenant folder '$selectedTenant' does not exist."
-        throw "Invalid tenant folder"
-    }
+        # Assign values from JSON to variables with detailed logging
+        Write-EnhancedLog -Message "Attempting to load TenantID..." -Level 'INFO'
+        $tenantId = $secrets.PSObject.Properties['TenantID'].Value
+        Write-EnhancedLog -Message "Loaded TenantID: $tenantId" -Level 'INFO'
 
-    # Define paths for the secrets.json and PFX files
-    $secretsJsonPath = Join-Path -Path $selectedTenantPath -ChildPath "secrets.json"
-    $pfxFiles = Get-ChildItem -Path $selectedTenantPath -Filter *.pfx
+        Write-EnhancedLog -Message "Attempting to load ClientId..." -Level 'INFO'
+        $clientId = $secrets.PSObject.Properties['ClientId'].Value
+        Write-EnhancedLog -Message "Loaded ClientId: $clientId" -Level 'INFO'
 
-    # Check if secrets.json exists
-    if (-Not (Test-Path -Path $secretsJsonPath)) {
-        Write-Error "secrets.json file not found in '$selectedTenantPath'."
-        throw "secrets.json file not found"
-    }
+        Write-EnhancedLog -Message "Attempting to load CertPassword..." -Level 'INFO'
+        $CertPassword = $secrets.PSObject.Properties['CertPassword'].Value
+        Write-EnhancedLog -Message "CertPassword loaded (value hidden for security)" -Level 'INFO'
 
-    # Load the secrets from the JSON file
-    Write-EnhancedLog -Message "Loading secrets from: $secretsJsonPath" -Level 'INFO'
-    $secrets = Get-Content -Path $secretsJsonPath -Raw | ConvertFrom-Json
+        # Validate the required values with detailed error messages
+        if ([string]::IsNullOrWhiteSpace($tenantId)) {
+            Write-EnhancedLog -Message "TenantID is missing or empty in secrets.json" -Level 'ERROR'
+            throw "TenantID is missing or empty in secrets.json"
+        }
+        if ([string]::IsNullOrWhiteSpace($clientId)) {
+            Write-EnhancedLog -Message "ClientId is missing or empty in secrets.json" -Level 'ERROR'
+            throw "ClientId is missing or empty in secrets.json"
+        }
+        if ([string]::IsNullOrWhiteSpace($CertPassword)) {
+            Write-EnhancedLog -Message "CertPassword is missing or empty in secrets.json" -Level 'ERROR'
+            throw "CertPassword is missing or empty in secrets.json"
+        }
 
-    # Debug: List all available properties in secrets
-    Write-EnhancedLog -Message "Available properties in secrets file:" -Level 'INFO'
-    $secrets.PSObject.Properties | ForEach-Object {
-        Write-EnhancedLog -Message "Property: $($_.Name) = $($_.Value)" -Level 'INFO'
-    }
+        Write-EnhancedLog -Message "Successfully loaded all required authentication details from secrets.json" -Level 'INFO'
+        Write-EnhancedLog -Message "TenantID length: $($tenantId.Length) characters" -Level 'INFO'
+        Write-EnhancedLog -Message "ClientId length: $($clientId.Length) characters" -Level 'INFO'
+        Write-EnhancedLog -Message "CertPassword length: $($CertPassword.Length) characters" -Level 'INFO'
 
-    # Check if a PFX file exists
-    if ($pfxFiles.Count -eq 0) {
-        Write-Error "No PFX file found in the '$selectedTenantPath' directory."
-        throw "No PFX file found"
-    }
-    elseif ($pfxFiles.Count -gt 1) {
-        Write-Error "Multiple PFX files found in the '$selectedTenantPath' directory. Please ensure there is only one PFX file."
-        throw "Multiple PFX files found"
-    }
+        #endregion LOADING SECRETS FOR GRAPH
 
-    # Use the first (and presumably only) PFX file found
-    $certPath = $pfxFiles[0].FullName
-    Write-EnhancedLog -Message "PFX file found: $certPath" -Level 'INFO'
+        # Call the function to initialize the environment
+        $envInitialization = Initialize-Win32Environment -scriptpath $ScriptRoot
 
-    # Assign values from JSON to variables with detailed logging
-    Write-EnhancedLog -Message "Attempting to load TenantID..." -Level 'INFO'
-    $tenantId = $secrets.PSObject.Properties['TenantID'].Value
-    Write-EnhancedLog -Message "Loaded TenantID: $tenantId" -Level 'INFO'
+        # Access the properties of the EnvDetails object
+        $AOscriptDirectory = $envInitialization.EnvDetails.AOscriptDirectory
+        $directoryPath = $envInitialization.EnvDetails.directoryPath
+        $Repo_Path = $envInitialization.EnvDetails.Repo_Path
+        $Repo_winget = $envInitialization.EnvDetails.Repo_winget
 
-    Write-EnhancedLog -Message "Attempting to load ClientId..." -Level 'INFO'
-    $clientId = $secrets.PSObject.Properties['ClientId'].Value
-    Write-EnhancedLog -Message "Loaded ClientId: $clientId" -Level 'INFO'
+        # Output the extracted values
+        Write-EnhancedLog -Message "Global variables set by Initialize-Win32Environment" -Level 'INFO'
+        Write-EnhancedLog -Message "AO Script Directory: $AOscriptDirectory"
+        Write-EnhancedLog -Message "Directory Path: $directoryPath"
+        Write-EnhancedLog -Message "Repository Path: $Repo_Path"
+        Write-EnhancedLog -Message "Winget Path: $Repo_winget"
 
-    Write-EnhancedLog -Message "Attempting to load CertPassword..." -Level 'INFO'
-    $CertPassword = $secrets.PSObject.Properties['CertPassword'].Value
-    Write-EnhancedLog -Message "CertPassword loaded (value hidden for security)" -Level 'INFO'
+        # Example usage of global variables outside the function
+        Write-EnhancedLog -Message "scriptBasePath: $scriptBasePath" -Level 'INFO'
+        Write-EnhancedLog -Message "modulesBasePath: $modulesBasePath" -Level 'INFO'
+        Write-EnhancedLog -Message "modulePath: $modulePath" -Level 'INFO'
 
-    # Validate the required values with detailed error messages
-    if ([string]::IsNullOrWhiteSpace($tenantId)) {
-        Write-EnhancedLog -Message "TenantID is missing or empty in secrets.json" -Level 'ERROR'
-        throw "TenantID is missing or empty in secrets.json"
-    }
-    if ([string]::IsNullOrWhiteSpace($clientId)) {
-        Write-EnhancedLog -Message "ClientId is missing or empty in secrets.json" -Level 'ERROR'
-        throw "ClientId is missing or empty in secrets.json"
-    }
-    if ([string]::IsNullOrWhiteSpace($CertPassword)) {
-        Write-EnhancedLog -Message "CertPassword is missing or empty in secrets.json" -Level 'ERROR'
-        throw "CertPassword is missing or empty in secrets.json"
-    }
+        Remove-IntuneWinFiles -DirectoryPath $directoryPath
 
-    Write-EnhancedLog -Message "Successfully loaded all required authentication details from secrets.json" -Level 'INFO'
-    Write-EnhancedLog -Message "TenantID length: $($tenantId.Length) characters" -Level 'INFO'
-    Write-EnhancedLog -Message "ClientId length: $($clientId.Length) characters" -Level 'INFO'
-    Write-EnhancedLog -Message "CertPassword length: $($CertPassword.Length) characters" -Level 'INFO'
+        #to address this bug in https://github.com/MSEndpointMgr/IntuneWin32App/issues/155 use the following function to update the Invoke-AzureStorageBlobUploadFinalize.ps1
+        Copy-InvokeAzureStorageBlobUploadFinalize
 
+        ##########################################################################################################################
+        ############################################STARTING THE MAIN FUNCTION LOGIC HERE#########################################
+        ##########################################################################################################################
 
-    #endregion LOADING SECRETS FOR GRAPH
+        ################################################################################################################################
+        ################################################ START GRAPH CONNECTING ########################################################
+        ################################################################################################################################
 
+        try {
+            # Log the values right before connecting
+            Write-EnhancedLog -Message "Preparing to connect with the following values:" -Level 'INFO'
+            Write-EnhancedLog -Message "TenantID: $tenantId" -Level 'INFO'
+            Write-EnhancedLog -Message "ClientID: $clientId" -Level 'INFO'
+            Write-EnhancedLog -Message "CertPath: $certPath" -Level 'INFO'
+            Write-EnhancedLog -Message "CertPassword length: $($CertPassword.Length)" -Level 'INFO'
+
+            # Create hashtable for splatting with explicit string conversions
+            $graphParams = @{
+                tenantId = [string]$tenantId
+                clientId = [string]$clientId
+                certPath = [string]$certPath
+                certPassword = [string]$CertPassword
+                ConnectToIntune = $true
+                ConnectToTeams = $false
+            }
+
+            # Log the hashtable values
+            Write-EnhancedLog -Message "Checking splat parameters:" -Level 'INFO'
+            Write-EnhancedLog -Message "tenantId from splat: $($graphParams.tenantId)" -Level 'INFO'
+            Write-EnhancedLog -Message "clientId from splat: $($graphParams.clientId)" -Level 'INFO'
+            Write-EnhancedLog -Message "certPath from splat: $($graphParams.certPath)" -Level 'INFO'
+
+            # Attempt to connect using the certificate for custom operations
+            Write-EnhancedLog -Message "Attempting to connect to Microsoft Graph using certificate authentication..." -Level "INFO"
+            $accessToken = Connect-GraphWithCert @graphParams
+            Write-EnhancedLog -Message "Connected using certificate authentication for custom operations. Access token obtained." -Level "INFO"
+            
+            # CRITICAL: Also authenticate with IntuneWin32App module
+            Write-EnhancedLog -Message "Establishing authentication with IntuneWin32App module..." -Level "INFO"
+            try {
+                # Clear any existing authentication state first
+                Write-EnhancedLog -Message "Clearing any existing IntuneWin32App authentication state..." -Level "INFO"
+                $Global:AccessToken = $null
+                $Global:AuthenticationHeader = $null
+                $Global:AccessTokenTenantID = $null
+                
+                # Extract certificate thumbprint
+                $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certPath, $CertPassword)
+                $certThumbprint = $cert.Thumbprint
+                Write-EnhancedLog -Message "Certificate thumbprint: $certThumbprint" -Level "INFO"
+                Write-EnhancedLog -Message "Certificate subject: $($cert.Subject)" -Level "INFO"
+                
+                # Store the certificate object globally for later use
+                $Global:CertObject = $cert
+                
+                # Check if PowerShell 7 is available for CNG certificate handling
+                $ps7Path = "C:\Program Files\PowerShell\7\pwsh.exe"
+                $usePS7Auth = Test-Path $ps7Path
+                
+                if ($usePS7Auth) {
+                    Write-EnhancedLog -Message "Using PowerShell 7 for certificate authentication (better CNG support)..." -Level "INFO"
+                    
+                    # Create a temporary script to run in PS7
+                    $ps7ScriptContent = @"
+# PowerShell 7 Authentication Script
+param(
+    [string]`$TenantId,
+    [string]`$ClientId,
+    [string]`$CertPath,
+    [string]`$CertPassword
+)
 
-    # Read configuration from the JSON file
-    $configPath = Join-Path -Path $PSScriptRoot -ChildPath "config.json"
-    # $env:MYMODULE_CONFIG_PATH = $configPath
+try {
+    Import-Module MSAL.PS -ErrorAction Stop
     
-    $config = Get-Content -Path $configPath -Raw | ConvertFrom-Json
-
-    # Call the function to initialize the environment
-    $envInitialization = Initialize-Win32Environment -scriptpath $PSScriptRoot
-
-
-    # # Run Initialize-Win32Environment and store the returned object
-    # $envInitialization = Initialize-Win32Environment -scriptpath "C:\path\to\your\script.ps1"
-
-    # # Access the properties of the EnvDetails object
-    $AOscriptDirectory = $envInitialization.EnvDetails.AOscriptDirectory
-    $directoryPath = $envInitialization.EnvDetails.directoryPath
-    $Repo_Path = $envInitialization.EnvDetails.Repo_Path
-    $Repo_winget = $envInitialization.EnvDetails.Repo_winget
-
-    # Output the extracted values
-    Write-EnhancedLog -Message "Global variables set by Initialize-Win32Environment" -Level 'INFO'
-    Write-EnhancedLog -Message "AO Script Directory: $AOscriptDirectory"
-    Write-EnhancedLog -Message "Directory Path: $directoryPath"
-    Write-EnhancedLog -Message "Repository Path: $Repo_Path"
-    Write-EnhancedLog -Message "Winget Path: $Repo_winget"
-
-
-
-    # Example usage of global variables outside the function
-    Write-EnhancedLog -Message "scriptBasePath: $scriptBasePath" -Level 'INFO'
-    Write-EnhancedLog -Message "modulesBasePath: $modulesBasePath" -Level 'INFO'
-    Write-EnhancedLog -Message "modulePath: $modulePath" -Level 'INFO'
-
-    # Write-EnhancedLog -Message "AOscriptDirectory: $AOscriptDirectory" -Level 'INFO'
-    # Write-EnhancedLog -Message "directoryPath: "$envInitialization.EnvDetails.directoryPath"" -Level 'INFO'
-    # Write-EnhancedLog -Message "Repo_Path: $Repo_Path" -Level 'INFO'
-    # Write-EnhancedLog -Message "Repo_winget: $Repo_winget" -Level 'INFO'
-
-
-    # Wait-Debugger
-
-
-    Remove-IntuneWinFiles -DirectoryPath $directoryPath
-
-
-    # Wait-Debugger
-
-
-
-    #to address this bug in https://github.com/MSEndpointMgr/IntuneWin32App/issues/155 use the following function to update the Invoke-AzureStorageBlobUploadFinalize.ps1
-
-    Copy-InvokeAzureStorageBlobUploadFinalize
-
-    ##########################################################################################################################
-    ############################################STARTING THE MAIN FUNCTION LOGIC HERE#########################################
-    ##########################################################################################################################
-
-    ################################################################################################################################
-    ################################################ START Ensure-ScriptPathsExist #################################################
-    ################################################################################################################################
-
-    # ################################################################################################################################
-    # ################################################ START GRAPH CONNECTING ########################################################
-    # ################################################################################################################################
-    # # Define the splat for Connect-GraphWithCert
-    # $graphParams = @{
-    #     tenantId        = $tenantId
-    #     clientId        = $clientId
-    #     certPath        = $certPath
-    #     certPassword    = $certPassword
-    #     ConnectToIntune = $true
-    #     ConnectToTeams  = $false
-    # }
-
-    # # Connect to Microsoft Graph, Intune, and Teams
-    # $accessToken = Connect-GraphWithCert @graphParams
-
-
-
-
-    # # # Path to the scopes.json file
-    # # $jsonFilePath = "$PSscriptroot\scopes.json"
-
-    # # # Read the JSON file
-    # # $jsonContent = Get-Content -Path $jsonFilePath -Raw | ConvertFrom-Json
-
-    # # # Extract the scopes
-    # # $scopes = $jsonContent.Scopes -join " "
-
-    # # # Connect to Microsoft Graph with the specified scopes
-    # # # Connect to Graph interactively
-    # # disconnect-Graph
-    # # Disconnect-MgGraph -Verbose
-
-    # # # Call the function to connect to Microsoft Graph
-    # # Connect-ToMicrosoftGraphIfServerCore -Scopes $scopes
-
-
-
-    # Log-Params -Params @{accessToken = $accessToken }
-
-    # # Get-TenantDetails
-
-
-    # # Wait-Debugger
-
-
-    # # Get the tenant details
-    # $tenantDetails = $null
-    # $tenantDetails = Get-TenantDetails
-    # if ($null -eq $tenantDetails) {
-    #     Write-EnhancedLog -Message "Unable to proceed without tenant details" -Level "ERROR"
-    #     throw "Tenant Details name is empty. Cannot proceed without a valid tenant details"
-    #     exit
-    # }
-
-    # $tenantDetails
-
-
-
-
-
-
-
-
-    ################################################################################################################################
-    ################################################ START GRAPH CONNECTING ########################################################
-    ################################################################################################################################
-
-    # Define the splat for Connect-GraphWithCert
-    # $graphParams = @{
-    #     tenantId        = $tenantId
-    #     clientId        = $clientId
-    #     certPath        = $certPath
-    #     certPassword    = $certPassword
-    #     ConnectToIntune = $true
-    #     ConnectToTeams  = $false
-    # }
-
-    # $accessToken = $null
-    # $tenantDetails = $null
-
-
-
-    # $tenantId
-
-    # Connect interactively to Intune
-    # Connect-ToIntuneInteractive -tenantId $tenantId
-
-    # Connect interactively to Intune
-    # Connect-ToIntuneInteractive -tenantId $tenantId -clientId $clientId
-    # Connect-ToIntuneInteractive -tenantId $tenantId
-
-
-    # $accessToken = Connect-GraphWithCert @graphParams
-
-
-
-
-
-    #   # Disconnect any existing sessions before reconnecting interactively
-    #   Disconnect-Graph
-    #   Disconnect-MgGraph -Verbose
-
-    #   # Path to the scopes.json file (adjust this path as necessary)
-    #   $jsonFilePath = "$PSScriptRoot\scopes.json"
-
-    #   # Read the JSON file and extract scopes
-    #   $jsonContent = Get-Content -Path $jsonFilePath -Raw | ConvertFrom-Json
-    #   $scopes = $jsonContent.Scopes -join " "
-
-    #   # Connect to Microsoft Graph interactively using the specified scopes
-    #   Write-EnhancedLog -Message "Connecting to Microsoft Graph interactively..." -Level "INFO"
-    #   Connect-ToMicrosoftGraphIfServerCore -Scopes $scopes
-
-
-
-    try {
-        # Log the values right before connecting
-        Write-EnhancedLog -Message "Preparing to connect with the following values:" -Level 'INFO'
-        Write-EnhancedLog -Message "TenantID: $tenantId" -Level 'INFO'
-        Write-EnhancedLog -Message "ClientID: $clientId" -Level 'INFO'
-        Write-EnhancedLog -Message "CertPath: $certPath" -Level 'INFO'
-        Write-EnhancedLog -Message "CertPassword length: $($CertPassword.Length)" -Level 'INFO'
-
-        # Create hashtable for splatting with explicit string conversions
-        $graphParams = @{
-            tenantId = [string]$tenantId
-            clientId = [string]$clientId
-            certPath = [string]$certPath
-            certPassword = [string]$CertPassword
-            ConnectToIntune = $true
-            ConnectToTeams = $false
-        }
-
-        # Log the hashtable values
-        Write-EnhancedLog -Message "Checking splat parameters:" -Level 'INFO'
-        Write-EnhancedLog -Message "tenantId from splat: $($graphParams.tenantId)" -Level 'INFO'
-        Write-EnhancedLog -Message "clientId from splat: $($graphParams.clientId)" -Level 'INFO'
-        Write-EnhancedLog -Message "certPath from splat: $($graphParams.certPath)" -Level 'INFO'
-
-        # Attempt to connect using the certificate
-        Write-EnhancedLog -Message "Attempting to connect to Microsoft Graph using certificate authentication..." -Level "INFO"
-        $accessToken = Connect-GraphWithCert @graphParams
-        Write-EnhancedLog -Message "Connected using certificate authentication. Access token obtained." -Level "INFO"
+    # Load certificate - PS7 handles CNG certificates better
+    `$cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(`$CertPath, `$CertPassword)
     
-        # Attempt to get tenant details
-        Write-EnhancedLog -Message "Attempting to retrieve tenant details..." -Level "INFO"
-        $tenantDetails = Get-TenantDetails
-
-        # Check if tenant details are retrieved successfully
-        if ($null -eq $tenantDetails) {
-            Write-EnhancedLog -Message "Tenant details could not be retrieved." -Level 'WARNING'
+    # Get token
+    `$msalToken = Get-MsalToken -TenantId `$TenantId -ClientId `$ClientId -ClientCertificate `$cert
+    
+    if (`$msalToken) {
+        # Create token data for PS5
+        `$tokenData = @{
+            AccessToken = `$msalToken.AccessToken
+            ExpiresOn = `$msalToken.ExpiresOn.ToString("o")
+            TenantId = `$TenantId
+            ClientId = `$ClientId
+            TokenType = "Bearer"
         }
-        Write-EnhancedLog -Message "Tenant details retrieved successfully." -Level "INFO"
+        
+        # Save to temp file
+        `$tokenFile = Join-Path `$env:TEMP "intune_auth_token.json"
+        `$tokenData | ConvertTo-Json | Set-Content `$tokenFile -Force
+        
+        Write-Host "SUCCESS"
+        exit 0
     }
-    catch {
-        # Handle any errors during certificate-based authentication
-        $errorMessage = "Failed to connect using certificate-based authentication or retrieve tenant details. Reason: $($_.Exception.Message)"
-        Write-EnhancedLog -Message $errorMessage -Level "ERROR"
-        Write-EnhancedLog -Message "Full error details: $($_ | ConvertTo-Json)" -Level "ERROR"
-
-        # Log that we are falling back to interactive authentication
-        Write-EnhancedLog -Message "Falling back to interactive authentication..." -Level "WARNING"
-
-        try {
-            Write-EnhancedLog -Message "Attempting interactive authentication with TenantID: $tenantId" -Level "INFO"
-            Connect-MSIntuneGraph -TenantID $tenantId -Interactive
-            Write-EnhancedLog -Message "Interactive authentication successful" -Level "INFO"
+}
+catch {
+    Write-Host "ERROR: `$_"
+    exit 1
+}
+"@
+                    
+                    # Save PS7 script temporarily
+                    $ps7ScriptPath = Join-Path $env:TEMP "Get-IntuneAuthPS7.ps1"
+                    $ps7ScriptContent | Set-Content $ps7ScriptPath -Force
+                    
+                    # Run PS7 to get the token
+                    $ps7Args = @("-NoProfile", "-ExecutionPolicy", "Bypass", "-File", "`"$ps7ScriptPath`"", "-TenantId", $tenantId, "-ClientId", $clientId, "-CertPath", "`"$certPath`"", "-CertPassword", "`"$CertPassword`"")
+                    $ps7Process = Start-Process -FilePath $ps7Path -ArgumentList $ps7Args -Wait -PassThru -NoNewWindow -RedirectStandardOutput "$env:TEMP\ps7_auth_output.txt"
+                    
+                    # Check if PS7 authentication succeeded
+                    if ($ps7Process.ExitCode -eq 0) {
+                        # Load the token from PS7
+                        $tokenFile = Join-Path $env:TEMP "intune_auth_token.json"
+                        if (Test-Path $tokenFile) {
+                            $tokenData = Get-Content $tokenFile -Raw | ConvertFrom-Json
+                            
+                            # Set up global variables in the format IntuneWin32App expects
+                            $expiresOn = [DateTime]::Parse($tokenData.ExpiresOn).ToUniversalTime()
+                            
+                            # Create the AccessToken object to match what IntuneWin32App expects
+                            # The module expects ExpiresOn to be a DateTimeOffset with UtcDateTime property
+                            $expiresOnOffset = [DateTimeOffset]::new($expiresOn)
+                            
+                            $Global:AccessToken = [PSCustomObject]@{
+                                AccessToken = $tokenData.AccessToken
+                                ExpiresOn = $expiresOnOffset
+                                TokenType = $tokenData.TokenType
+                            }
+                            
+                            $Global:AccessTokenTenantID = $tokenData.TenantId
+                            $Global:AuthenticationHeader = @{
+                                "Content-Type" = "application/json"
+                                "Authorization" = "$($tokenData.TokenType) $($tokenData.AccessToken)"
+                                "ExpiresOn" = $expiresOn.ToString()
+                            }
+                            
+                            Write-EnhancedLog -Message "PowerShell 7 authentication successful" -Level "INFO"
+                            Write-EnhancedLog -Message "Token expires at: $expiresOn" -Level "INFO"
+                            
+                            # Test authentication
+                            try {
+                                $testUri = "https://graph.microsoft.com/v1.0/organization"
+                                $testResult = Invoke-RestMethod -Uri $testUri -Headers $Global:AuthenticationHeader -Method Get -ErrorAction Stop
+                                Write-EnhancedLog -Message "Authentication verified - connected to tenant: $($testResult.value[0].displayName)" -Level "INFO"
+                            }
+                            catch {
+                                Write-EnhancedLog -Message "Authentication test warning: $($_.Exception.Message)" -Level "WARNING"
+                            }
+                            
+                            # Clean up temp files
+                            Remove-Item $ps7ScriptPath -Force -ErrorAction SilentlyContinue
+                            Remove-Item "$env:TEMP\ps7_auth_output.txt" -Force -ErrorAction SilentlyContinue
+                        }
+                        else {
+                            throw "PowerShell 7 did not create token file"
+                        }
+                    }
+                    else {
+                        # PS7 auth failed, read the output for debugging
+                        $ps7Output = Get-Content "$env:TEMP\ps7_auth_output.txt" -Raw -ErrorAction SilentlyContinue
+                        Write-EnhancedLog -Message "PowerShell 7 authentication failed: $ps7Output" -Level "ERROR"
+                        throw "PowerShell 7 authentication failed"
+                    }
+                }
+                else {
+                    # Fallback to PS5 direct MSAL (will likely fail with CNG certs)
+                    Write-EnhancedLog -Message "PowerShell 7 not found. Using direct MSAL authentication (may fail with CNG certificates)..." -Level "WARNING"
+                    
+                    # Import MSAL.PS module
+                    Import-Module MSAL.PS -ErrorAction Stop
+                    
+                    # Get token using MSAL.PS directly
+                    Write-EnhancedLog -Message "Requesting token from Azure AD with TenantID: $tenantId, ClientID: $clientId" -Level "INFO"
+                    $msalToken = Get-MsalToken -TenantId $tenantId -ClientId $clientId -ClientCertificate $cert
+                    
+                    if ($msalToken) {
+                        # Set up global variables in the format IntuneWin32App expects
+                        $Global:AccessToken = $msalToken
+                        $Global:AccessTokenTenantID = $tenantId
+                        
+                        # Create the authentication header manually
+                        $Global:AuthenticationHeader = @{
+                            "Content-Type" = "application/json"
+                            "Authorization" = "Bearer $($msalToken.AccessToken)"
+                            "ExpiresOn" = $msalToken.ExpiresOn.UtcDateTime
+                        }
+                        
+                        Write-EnhancedLog -Message "Direct MSAL authentication successful" -Level "INFO"
+                        Write-EnhancedLog -Message "Token expires at: $($msalToken.ExpiresOn)" -Level "INFO"
+                    } else {
+                        throw "Failed to obtain access token from MSAL.PS"
+                    }
+                }
+            }
+            catch {
+                Write-EnhancedLog -Message "Failed to authenticate with direct MSAL: $($_.Exception.Message)" -Level "WARNING"
+                Write-EnhancedLog -Message "Will attempt interactive authentication if needed later" -Level "INFO"
+            }
+        
+            # Attempt to get tenant details
+            Write-EnhancedLog -Message "Attempting to retrieve tenant details..." -Level "INFO"
+            $tenantDetails = Get-TenantDetails
+
+            # Check if tenant details are retrieved successfully
+            if ($null -eq $tenantDetails) {
+                Write-EnhancedLog -Message "Tenant details could not be retrieved." -Level 'WARNING'
+            }
+            Write-EnhancedLog -Message "Tenant details retrieved successfully." -Level "INFO"
         }
         catch {
-            Write-EnhancedLog -Message "Interactive authentication failed: $($_.Exception.Message)" -Level "ERROR"
+            # Handle any errors during certificate-based authentication
+            $errorMessage = "Failed to connect using certificate-based authentication or retrieve tenant details. Reason: $($_.Exception.Message)"
+            Write-EnhancedLog -Message $errorMessage -Level "ERROR"
             Write-EnhancedLog -Message "Full error details: $($_ | ConvertTo-Json)" -Level "ERROR"
-            throw
-        }
-    }
 
-    # Continue with the script logic now that tenant details are retrieved
-    Log-Params -Params @{accessToken = $accessToken; tenantDetails = $tenantDetails }
+            # Log that we are falling back to interactive authentication
+            Write-EnhancedLog -Message "Falling back to interactive authentication..." -Level "WARNING"
+
+            try {
+                Write-EnhancedLog -Message "Attempting interactive authentication with TenantID: $tenantId" -Level "INFO"
+                Connect-MSIntuneGraph -TenantID $tenantId -Interactive
+                Write-EnhancedLog -Message "Interactive authentication successful" -Level "INFO"
+            }
+            catch {
+                Write-EnhancedLog -Message "Interactive authentication failed: $($_.Exception.Message)" -Level "ERROR"
+                Write-EnhancedLog -Message "Full error details: $($_ | ConvertTo-Json)" -Level "ERROR"
+                throw
+            }
+        }
 
-    # Example output of tenant details
-    $tenantDetails
+        # Store authentication parameters globally for potential reconnection later
+        $Global:TenantId = $tenantId
+        $Global:ClientId = $clientId
+        $Global:CertPath = $certPath
+        $Global:CertPassword = $CertPassword
+        Write-EnhancedLog -Message "Stored authentication parameters globally for reconnection purposes" -Level "INFO"
+        
+        # Verify IntuneWin32App module authentication
+        if ($null -eq $Global:AuthenticationHeader) {
+            Write-EnhancedLog -Message "WARNING: IntuneWin32App module authentication header not found" -Level "WARNING"
+            Write-EnhancedLog -Message "Authentication will be attempted when needed during app upload" -Level "INFO"
+        }
+        else {
+            Write-EnhancedLog -Message "IntuneWin32App module authentication verified successfully" -Level "INFO"
+        }
 
+        # Continue with the script logic now that tenant details are retrieved
+        Log-Params -Params @{accessToken = $accessToken; tenantDetails = $tenantDetails }
 
+        # Example output of tenant details
+        $tenantDetails
 
+        #################################################################################################################################
+        ################################################# END Connecting to Graph #######################################################
+        #################################################################################################################################
  
+        ####################################################################################
+        #   GO!
+        ####################################################################################
+
+        # Retrieve all folder names in the specified directory
+        $folders = Get-ChildItem -Path $directoryPath -Directory
+
+        foreach ($folder in $folders) {
+
+            $ProcessFolderParams = @{
+                Folder      = $folder
+                config      = $Config
+                Repo_winget = $Repo_winget
+                scriptpath  = $ScriptRoot
+                Repo_Path   = $Repo_Path
+            }
+            
+            $folderDetails = Process-Folder @ProcessFolderParams
+            
+        }
 
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+        Write-EnhancedLog -Message "Completed processing tenant: $TenantName" -Level 'INFO'
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+    }
 
+    # Define the path to the secrets directory
+    $secretsDirPath = Join-Path -Path $PSScriptRoot -ChildPath "secrets"
 
+    # Check if the secrets directory exists
+    if (-Not (Test-Path -Path $secretsDirPath)) {
+        Write-Error "Secrets directory not found at '$secretsDirPath'."
+        throw "Secrets directory not found"
+    }
 
+    # List all folders (tenants) in the secrets directory
+    $tenantFolders = Get-ChildItem -Path $secretsDirPath -Directory
 
+    if ($tenantFolders.Count -eq 0) {
+        Write-Error "No tenant folders found in the secrets directory."
+        throw "No tenant folders found"
+    }
 
+    # Read configuration from the JSON file (do this once, outside tenant processing)
+    $configPath = Join-Path -Path $PSScriptRoot -ChildPath "config.json"
+    $config = Get-Content -Path $configPath -Raw | ConvertFrom-Json
 
-
-
-    #################################################################################################################################
-    ################################################# END Connecting to Graph #######################################################
-    #################################################################################################################################
- 
-    ####################################################################################
-    #   GO!
-    ####################################################################################
-
-    # Wait-Debugger
-
-    # Invoke-ScriptInPS5 -ScriptPath "C:\Code\Intune-Win32-Deployer\UploadWin32App.PS5Script.ps1"
-
-
-    # Retrieve all folder names in the specified directory
-    $folders = Get-ChildItem -Path $directoryPath -Directory
-
-    foreach ($folder in $folders) {
-
-        $ProcessFolderParams = @{
-            Folder      = $folder
-            config      = $config
-            Repo_winget = $Repo_winget
-            scriptpath  = $PSScriptRoot
-        }
-        
-        $folderDetails = Process-Folder @ProcessFolderParams
+    # Check if we have multiple tenants
+    if ($tenantFolders.Count -eq 1) {
+        # Single tenant - use it automatically without prompting
+        $selectedTenant = $tenantFolders[0].Name
+        $selectedTenantPath = $tenantFolders[0].FullName
+        Write-Host "Using tenant: $selectedTenant" -ForegroundColor Green
         
+        # Process the single tenant
+        Process-SingleTenant -TenantPath $selectedTenantPath -TenantName $selectedTenant -Config $config -ScriptRoot $PSScriptRoot
+    }
+    else {
+        # Multiple tenants - prompt for selection
+        Write-Host "Available tenant folders:"
+        $tenantFolders | ForEach-Object -Begin { $i = 1 } -Process {
+            Write-Host "$i. $($_.Name)"
+            $i++
+        }
+        Write-Host "$($tenantFolders.Count + 1). All tenants" -ForegroundColor Cyan
+
+        # Prompt user for selection
+        do {
+            $selection = Read-Host "Enter the number of the tenant folder you want to use (1-$($tenantFolders.Count + 1))"
+            
+            # Validate the input is a number
+            if ($selection -match '^\d+$') {
+                $selectedNumber = [int]$selection
+            } else {
+                $selectedNumber = -1
+            }
+            
+            # Check if selection is within valid range
+            if ($selectedNumber -lt 1 -or $selectedNumber -gt ($tenantFolders.Count + 1)) {
+                Write-Host "Invalid selection. Please enter a number between 1 and $($tenantFolders.Count + 1)." -ForegroundColor Yellow
+            }
+        } while ($selectedNumber -lt 1 -or $selectedNumber -gt ($tenantFolders.Count + 1))
+
+        # Check if user selected "All tenants"
+        if ($selectedNumber -eq ($tenantFolders.Count + 1)) {
+            # Process all tenants
+            Write-Host "You selected: All tenants" -ForegroundColor Green
+            Write-EnhancedLog -Message "Processing all tenants..." -Level 'INFO'
+            
+            $successCount = 0
+            $failureCount = 0
+            
+            foreach ($tenantFolder in $tenantFolders) {
+                try {
+                    Process-SingleTenant -TenantPath $tenantFolder.FullName -TenantName $tenantFolder.Name -Config $config -ScriptRoot $PSScriptRoot
+                    $successCount++
+                }
+                catch {
+                    Write-EnhancedLog -Message "Failed to process tenant '$($tenantFolder.Name)': $_" -Level 'ERROR'
+                    $failureCount++
+                    # Continue with next tenant instead of failing completely
+                    continue
+                }
+            }
+            
+            Write-EnhancedLog -Message "========================================" -Level 'INFO'
+            Write-EnhancedLog -Message "FINAL SUMMARY" -Level 'INFO'
+            Write-EnhancedLog -Message "========================================" -Level 'INFO'
+            Write-EnhancedLog -Message "Total tenants: $($tenantFolders.Count)" -Level 'INFO'
+            Write-EnhancedLog -Message "Successfully processed: $successCount" -Level 'INFO'
+            Write-EnhancedLog -Message "Failed: $failureCount" -Level 'INFO'
+            Write-EnhancedLog -Message "========================================" -Level 'INFO'
+            
+            if ($successCount -eq 0) {
+                Write-Error "No tenants could be processed successfully."
+                throw "No valid tenants found"
+            }
+        }
+        else {
+            # Get the selected tenant folder
+            $selectedIndex = $selectedNumber - 1
+            $selectedTenant = $tenantFolders[$selectedIndex].Name
+            $selectedTenantPath = $tenantFolders[$selectedIndex].FullName
+            
+            Write-Host "You selected: $selectedTenant" -ForegroundColor Green
+            
+            # Process the selected tenant
+            Process-SingleTenant -TenantPath $selectedTenantPath -TenantName $selectedTenant -Config $config -ScriptRoot $PSScriptRoot
+        }
     }
 
- 
     #endregion Script Logic
 }
 catch {
diff --git a/Intune-Win32-Deployer-ALPHAv1.ps1.backup b/Intune-Win32-Deployer-ALPHAv1.ps1.backup
new file mode 100644
index 0000000..b1a194c
--- /dev/null
+++ b/Intune-Win32-Deployer-ALPHAv1.ps1.backup
@@ -0,0 +1,640 @@
+#############################################################################################################
+#
+#   Tool:           Intune Win32 Deployer
+#   Author:         Abdullah Ollivierre
+#   Website:        https://github.com/aollivierre
+#   Twitter:        https://x.com/ollivierre
+#   LinkedIn:       https://www.linkedin.com/in/aollivierre
+#
+#   Description:    https://github.com/aollivierre
+#
+#############################################################################################################
+
+<#
+    .SYNOPSIS
+    Packages any custom app for MEM (Intune) deployment.
+    Uploads the packaged into the target Intune tenant.
+
+    .NOTES
+    For details on IntuneWin32App go here: https://github.com/aollivierre
+
+#>
+
+
+#region RE-LAUNCH SCRIPT IN POWERSHELL 5 FUNCTION
+#################################################################################################
+#                                                                                               #
+#                           RE-LAUNCH SCRIPT IN POWERSHELL 5 FUNCTION                           #
+#                                                                                               #
+#################################################################################################
+
+function Relaunch-InPowerShell5 {
+    # Check the current version of PowerShell
+    if ($PSVersionTable.PSVersion.Major -ge 7) {
+        Write-Host "Hello from PowerShell 7"
+
+        # Get the script path (works inside a function as well)
+        $scriptPath = $PSCommandPath
+
+        # $scriptPath = $MyInvocation.MyCommand.Definition
+        $ps5Path = "$($env:SystemRoot)\System32\WindowsPowerShell\v1.0\powershell.exe"
+
+        # Build the argument to relaunch this script in PowerShell 5 with -NoExit
+        $ps5Args = "-NoExit -NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`""
+
+        Write-Host "Relaunching in PowerShell 5..."
+        Start-Process -FilePath $ps5Path -ArgumentList $ps5Args
+
+        # Exit the current PowerShell 7 session to allow PowerShell 5 to take over
+        exit
+    }
+
+    # If relaunching in PowerShell 5
+    Write-Host "Hello from PowerShell 5"
+}
+
+Relaunch-InPowerShell5
+
+
+#endregion RE-LAUNCH SCRIPT IN POWERSHELL 5 FUNCTION
+#################################################################################################
+#                                                                                               #
+#                           END OF RE-LAUNCH SCRIPT IN POWERSHELL 5 FUNCTION                    #
+#                                                                                               #
+#################################################################################################
+
+
+# Set environment variable globally for all users
+[System.Environment]::SetEnvironmentVariable('EnvironmentMode', 'dev', 'Machine')
+
+# Retrieve the environment mode (default to 'prod' if not set)
+$mode = $env:EnvironmentMode
+
+#region FIRING UP MODULE STARTER
+#################################################################################################
+#                                                                                               #
+#                                 FIRING UP MODULE STARTER                                      #
+#                                                                                               #
+#################################################################################################
+
+# Invoke-Expression (Invoke-RestMethod "https://raw.githubusercontent.com/aollivierre/module-starter/main/Install-EnhancedModuleStarterAO.ps1")
+
+# Wait-Debugger
+
+# Define a hashtable for splatting
+$moduleStarterParams = @{
+    Mode                   = 'dev'
+    SkipPSGalleryModules   = $true
+    SkipCheckandElevate    = $true
+    SkipPowerShell7Install = $true
+    SkipEnhancedModules    = $true
+    SkipGitRepos           = $true
+}
+
+# Call the function using the splat
+Invoke-ModuleStarter @moduleStarterParams
+
+
+
+
+# Define a hashtable for splatting
+# $moduleStarterParams = @{
+#     Mode                   = 'PROD'
+#     SkipPSGalleryModules   = $FALSE
+#     SkipCheckandElevate    = $FALSE
+#     SkipPowerShell7Install = $FALSE
+#     SkipEnhancedModules    = $FALSE
+#     SkipGitRepos           = $true
+# }
+
+# # Call the function using the splat
+# Invoke-ModuleStarter @moduleStarterParams
+
+
+# Wait-Debugger
+
+#endregion FIRING UP MODULE STARTER
+
+# Toggle based on the environment mode
+switch ($mode) {
+    'dev' {
+        Write-EnhancedLog -Message "Running in development mode" -Level 'WARNING'
+        # Your development logic here
+    }
+    'prod' {
+        Write-EnhancedLog -Message "Running in production mode" -ForegroundColor Green
+        # Your production logic here
+    }
+    default {
+        Write-EnhancedLog -Message "Unknown mode. Defaulting to production." -ForegroundColor Red
+        # Default to production
+    }
+}
+
+
+
+#region HANDLE PSF MODERN LOGGING
+#################################################################################################
+#                                                                                               #
+#                            HANDLE PSF MODERN LOGGING                                          #
+#                                                                                               #
+#################################################################################################
+Set-PSFConfig -Fullname 'PSFramework.Logging.FileSystem.ModernLog' -Value $true -PassThru | Register-PSFConfig -Scope SystemDefault
+
+# Define the base logs path and job name
+$JobName = "Win32AppDeployer"
+$parentScriptName = Get-ParentScriptName
+Write-EnhancedLog -Message "Parent Script Name: $parentScriptName"
+
+# Call the Get-PSFCSVLogFilePath function to generate the dynamic log file path
+$paramGetPSFCSVLogFilePath = @{
+    LogsPath         = 'C:\Logs\PSF'
+    JobName          = $jobName
+    parentScriptName = $parentScriptName
+}
+
+$csvLogFilePath = Get-PSFCSVLogFilePath @paramGetPSFCSVLogFilePath
+
+$instanceName = "$parentScriptName-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
+
+# Configure the PSFramework logging provider to use CSV format
+$paramSetPSFLoggingProvider = @{
+    Name            = 'logfile'
+    InstanceName    = $instanceName  # Use a unique instance name
+    FilePath        = $csvLogFilePath  # Use the dynamically generated file path
+    Enabled         = $true
+    FileType        = 'CSV'
+    EnableException = $true
+}
+Set-PSFLoggingProvider @paramSetPSFLoggingProvider
+#endregion HANDLE PSF MODERN LOGGING
+
+
+#region HANDLE Transript LOGGING
+#################################################################################################
+#                                                                                               #
+#                            HANDLE Transript LOGGING                                           #
+#                                                                                               #
+#################################################################################################
+# Start the script with error handling
+try {
+    # Generate the transcript file path
+    $GetTranscriptFilePathParams = @{
+        TranscriptsPath  = "C:\Logs\Transcript"
+        JobName          = $jobName
+        parentScriptName = $parentScriptName
+    }
+    $transcriptPath = Get-TranscriptFilePath @GetTranscriptFilePathParams
+    
+    # Start the transcript
+    Write-EnhancedLog -Message "Starting transcript at: $transcriptPath"
+    Start-Transcript -Path $transcriptPath
+}
+catch {
+    Write-EnhancedLog -Message "An error occurred during script execution: $_" -Level 'ERROR'
+    if ($transcriptPath) {
+        Stop-Transcript
+        Write-EnhancedLog -Message "Transcript stopped." -ForegroundColor Cyan
+        # Stop logging in the finally block
+
+    }
+    else {
+        Write-EnhancedLog -Message "Transcript was not started due to an earlier error." -ForegroundColor Red
+    }
+
+    # Stop PSF Logging
+
+    # Ensure the log is written before proceeding
+    Wait-PSFMessage
+
+    # Stop logging in the finally block by disabling the provider
+    Set-PSFLoggingProvider -Name 'logfile' -InstanceName $instanceName -Enabled $false
+
+    Handle-Error -ErrorRecord $_
+    throw $_  # Re-throw the error after logging it
+}
+#endregion HANDLE Transript LOGGING
+
+try {
+    #region Script Logic
+    #################################################################################################
+    #                                                                                               #
+    #                                    Script Logic                                               #
+    #                                                                                               #
+    #################################################################################################
+
+
+    #region LOADING SECRETS FOR GRAPH
+    #################################################################################################
+    #                                                                                               #
+    #                                 LOADING SECRETS FOR GRAPH                                     #
+    #                                                                                               #
+    #################################################################################################
+
+    # Define a function to process a single tenant
+    function Process-SingleTenant {
+        param(
+            [string]$TenantPath,
+            [string]$TenantName,
+            [object]$Config,
+            [string]$ScriptRoot
+        )
+        
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+        Write-EnhancedLog -Message "Processing tenant: $TenantName" -Level 'INFO'
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+        Write-EnhancedLog -Message "Tenant path: $TenantPath" -Level 'INFO'
+        
+        # Define paths for the secrets.json and PFX files
+        $secretsJsonPath = Join-Path -Path $TenantPath -ChildPath "secrets.json"
+        $pfxFiles = Get-ChildItem -Path $TenantPath -Filter *.pfx
+
+        # Check if secrets.json exists
+        if (-Not (Test-Path -Path $secretsJsonPath)) {
+            Write-Error "secrets.json file not found in '$TenantPath'."
+            throw "secrets.json file not found"
+        }
+
+        # Load the secrets from the JSON file
+        Write-EnhancedLog -Message "Loading secrets from: $secretsJsonPath" -Level 'INFO'
+        $secrets = Get-Content -Path $secretsJsonPath -Raw | ConvertFrom-Json
+
+        # Debug: List all available properties in secrets
+        Write-EnhancedLog -Message "Available properties in secrets file:" -Level 'INFO'
+        $secrets.PSObject.Properties | ForEach-Object {
+            Write-EnhancedLog -Message "Property: $($_.Name) = $($_.Value)" -Level 'INFO'
+        }
+
+        # Check if a PFX file exists
+        if ($pfxFiles.Count -eq 0) {
+            Write-Error "No PFX file found in the '$TenantPath' directory."
+            throw "No PFX file found"
+        }
+        elseif ($pfxFiles.Count -gt 1) {
+            Write-Error "Multiple PFX files found in the '$TenantPath' directory. Please ensure there is only one PFX file."
+            throw "Multiple PFX files found"
+        }
+
+        # Use the first (and presumably only) PFX file found
+        $certPath = $pfxFiles[0].FullName
+        Write-EnhancedLog -Message "PFX file found: $certPath" -Level 'INFO'
+
+        # Assign values from JSON to variables with detailed logging
+        Write-EnhancedLog -Message "Attempting to load TenantID..." -Level 'INFO'
+        $tenantId = $secrets.PSObject.Properties['TenantID'].Value
+        Write-EnhancedLog -Message "Loaded TenantID: $tenantId" -Level 'INFO'
+
+        Write-EnhancedLog -Message "Attempting to load ClientId..." -Level 'INFO'
+        $clientId = $secrets.PSObject.Properties['ClientId'].Value
+        Write-EnhancedLog -Message "Loaded ClientId: $clientId" -Level 'INFO'
+
+        Write-EnhancedLog -Message "Attempting to load CertPassword..." -Level 'INFO'
+        $CertPassword = $secrets.PSObject.Properties['CertPassword'].Value
+        Write-EnhancedLog -Message "CertPassword loaded (value hidden for security)" -Level 'INFO'
+
+        # Validate the required values with detailed error messages
+        if ([string]::IsNullOrWhiteSpace($tenantId)) {
+            Write-EnhancedLog -Message "TenantID is missing or empty in secrets.json" -Level 'ERROR'
+            throw "TenantID is missing or empty in secrets.json"
+        }
+        if ([string]::IsNullOrWhiteSpace($clientId)) {
+            Write-EnhancedLog -Message "ClientId is missing or empty in secrets.json" -Level 'ERROR'
+            throw "ClientId is missing or empty in secrets.json"
+        }
+        if ([string]::IsNullOrWhiteSpace($CertPassword)) {
+            Write-EnhancedLog -Message "CertPassword is missing or empty in secrets.json" -Level 'ERROR'
+            throw "CertPassword is missing or empty in secrets.json"
+        }
+
+        Write-EnhancedLog -Message "Successfully loaded all required authentication details from secrets.json" -Level 'INFO'
+        Write-EnhancedLog -Message "TenantID length: $($tenantId.Length) characters" -Level 'INFO'
+        Write-EnhancedLog -Message "ClientId length: $($clientId.Length) characters" -Level 'INFO'
+        Write-EnhancedLog -Message "CertPassword length: $($CertPassword.Length) characters" -Level 'INFO'
+
+        #endregion LOADING SECRETS FOR GRAPH
+
+        # Call the function to initialize the environment
+        $envInitialization = Initialize-Win32Environment -scriptpath $ScriptRoot
+
+        # Access the properties of the EnvDetails object
+        $AOscriptDirectory = $envInitialization.EnvDetails.AOscriptDirectory
+        $directoryPath = $envInitialization.EnvDetails.directoryPath
+        $Repo_Path = $envInitialization.EnvDetails.Repo_Path
+        $Repo_winget = $envInitialization.EnvDetails.Repo_winget
+
+        # Output the extracted values
+        Write-EnhancedLog -Message "Global variables set by Initialize-Win32Environment" -Level 'INFO'
+        Write-EnhancedLog -Message "AO Script Directory: $AOscriptDirectory"
+        Write-EnhancedLog -Message "Directory Path: $directoryPath"
+        Write-EnhancedLog -Message "Repository Path: $Repo_Path"
+        Write-EnhancedLog -Message "Winget Path: $Repo_winget"
+
+        # Example usage of global variables outside the function
+        Write-EnhancedLog -Message "scriptBasePath: $scriptBasePath" -Level 'INFO'
+        Write-EnhancedLog -Message "modulesBasePath: $modulesBasePath" -Level 'INFO'
+        Write-EnhancedLog -Message "modulePath: $modulePath" -Level 'INFO'
+
+        Remove-IntuneWinFiles -DirectoryPath $directoryPath
+
+        #to address this bug in https://github.com/MSEndpointMgr/IntuneWin32App/issues/155 use the following function to update the Invoke-AzureStorageBlobUploadFinalize.ps1
+        Copy-InvokeAzureStorageBlobUploadFinalize
+
+        ##########################################################################################################################
+        ############################################STARTING THE MAIN FUNCTION LOGIC HERE#########################################
+        ##########################################################################################################################
+
+        ################################################################################################################################
+        ################################################ START GRAPH CONNECTING ########################################################
+        ################################################################################################################################
+
+        try {
+            # Log the values right before connecting
+            Write-EnhancedLog -Message "Preparing to connect with the following values:" -Level 'INFO'
+            Write-EnhancedLog -Message "TenantID: $tenantId" -Level 'INFO'
+            Write-EnhancedLog -Message "ClientID: $clientId" -Level 'INFO'
+            Write-EnhancedLog -Message "CertPath: $certPath" -Level 'INFO'
+            Write-EnhancedLog -Message "CertPassword length: $($CertPassword.Length)" -Level 'INFO'
+
+            # Create hashtable for splatting with explicit string conversions
+            $graphParams = @{
+                tenantId = [string]$tenantId
+                clientId = [string]$clientId
+                certPath = [string]$certPath
+                certPassword = [string]$CertPassword
+                ConnectToIntune = $true
+                ConnectToTeams = $false
+            }
+
+            # Log the hashtable values
+            Write-EnhancedLog -Message "Checking splat parameters:" -Level 'INFO'
+            Write-EnhancedLog -Message "tenantId from splat: $($graphParams.tenantId)" -Level 'INFO'
+            Write-EnhancedLog -Message "clientId from splat: $($graphParams.clientId)" -Level 'INFO'
+            Write-EnhancedLog -Message "certPath from splat: $($graphParams.certPath)" -Level 'INFO'
+
+            # Attempt to connect using the certificate for custom operations
+            Write-EnhancedLog -Message "Attempting to connect to Microsoft Graph using certificate authentication..." -Level "INFO"
+            $accessToken = Connect-GraphWithCert @graphParams
+            Write-EnhancedLog -Message "Connected using certificate authentication for custom operations. Access token obtained." -Level "INFO"
+            
+            # CRITICAL: Also authenticate with IntuneWin32App module
+            Write-EnhancedLog -Message "Establishing authentication with IntuneWin32App module..." -Level "INFO"
+            try {
+                # Clear any existing authentication state first
+                Write-EnhancedLog -Message "Clearing any existing IntuneWin32App authentication state..." -Level "INFO"
+                $Global:AccessToken = $null
+                $Global:AuthenticationHeader = $null
+                $Global:AccessTokenTenantID = $null
+                
+                # Extract certificate thumbprint
+                $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certPath, $CertPassword)
+                $certThumbprint = $cert.Thumbprint
+                Write-EnhancedLog -Message "Certificate thumbprint: $certThumbprint" -Level "INFO"
+                Write-EnhancedLog -Message "Certificate subject: $($cert.Subject)" -Level "INFO"
+                
+                # Store the certificate object globally for later use
+                $Global:CertObject = $cert
+                
+                # Connect using IntuneWin32App module - pass the certificate object directly
+                Write-EnhancedLog -Message "Calling Connect-MSIntuneGraph with TenantID: $tenantId, ClientID: $clientId" -Level "INFO"
+                Connect-MSIntuneGraph -TenantID $tenantId -ClientID $clientId -ClientCert $cert
+                Write-EnhancedLog -Message "Successfully authenticated with IntuneWin32App module" -Level "INFO"
+            }
+            catch {
+                Write-EnhancedLog -Message "Failed to authenticate with IntuneWin32App module: $($_.Exception.Message)" -Level "WARNING"
+                Write-EnhancedLog -Message "Will attempt interactive authentication if needed later" -Level "INFO"
+            }
+        
+            # Attempt to get tenant details
+            Write-EnhancedLog -Message "Attempting to retrieve tenant details..." -Level "INFO"
+            $tenantDetails = Get-TenantDetails
+
+            # Check if tenant details are retrieved successfully
+            if ($null -eq $tenantDetails) {
+                Write-EnhancedLog -Message "Tenant details could not be retrieved." -Level 'WARNING'
+            }
+            Write-EnhancedLog -Message "Tenant details retrieved successfully." -Level "INFO"
+        }
+        catch {
+            # Handle any errors during certificate-based authentication
+            $errorMessage = "Failed to connect using certificate-based authentication or retrieve tenant details. Reason: $($_.Exception.Message)"
+            Write-EnhancedLog -Message $errorMessage -Level "ERROR"
+            Write-EnhancedLog -Message "Full error details: $($_ | ConvertTo-Json)" -Level "ERROR"
+
+            # Log that we are falling back to interactive authentication
+            Write-EnhancedLog -Message "Falling back to interactive authentication..." -Level "WARNING"
+
+            try {
+                Write-EnhancedLog -Message "Attempting interactive authentication with TenantID: $tenantId" -Level "INFO"
+                Connect-MSIntuneGraph -TenantID $tenantId -Interactive
+                Write-EnhancedLog -Message "Interactive authentication successful" -Level "INFO"
+            }
+            catch {
+                Write-EnhancedLog -Message "Interactive authentication failed: $($_.Exception.Message)" -Level "ERROR"
+                Write-EnhancedLog -Message "Full error details: $($_ | ConvertTo-Json)" -Level "ERROR"
+                throw
+            }
+        }
+
+        # Store authentication parameters globally for potential reconnection later
+        $Global:TenantId = $tenantId
+        $Global:ClientId = $clientId
+        $Global:CertPath = $certPath
+        $Global:CertPassword = $CertPassword
+        Write-EnhancedLog -Message "Stored authentication parameters globally for reconnection purposes" -Level "INFO"
+        
+        # Verify IntuneWin32App module authentication
+        if ($null -eq $Global:AuthenticationHeader) {
+            Write-EnhancedLog -Message "WARNING: IntuneWin32App module authentication header not found" -Level "WARNING"
+            Write-EnhancedLog -Message "Authentication will be attempted when needed during app upload" -Level "INFO"
+        }
+        else {
+            Write-EnhancedLog -Message "IntuneWin32App module authentication verified successfully" -Level "INFO"
+        }
+
+        # Continue with the script logic now that tenant details are retrieved
+        Log-Params -Params @{accessToken = $accessToken; tenantDetails = $tenantDetails }
+
+        # Example output of tenant details
+        $tenantDetails
+
+        #################################################################################################################################
+        ################################################# END Connecting to Graph #######################################################
+        #################################################################################################################################
+ 
+        ####################################################################################
+        #   GO!
+        ####################################################################################
+
+        # Retrieve all folder names in the specified directory
+        $folders = Get-ChildItem -Path $directoryPath -Directory
+
+        foreach ($folder in $folders) {
+
+            $ProcessFolderParams = @{
+                Folder      = $folder
+                config      = $Config
+                Repo_winget = $Repo_winget
+                scriptpath  = $ScriptRoot
+                Repo_Path   = $Repo_Path
+            }
+            
+            $folderDetails = Process-Folder @ProcessFolderParams
+            
+        }
+
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+        Write-EnhancedLog -Message "Completed processing tenant: $TenantName" -Level 'INFO'
+        Write-EnhancedLog -Message "========================================" -Level 'INFO'
+    }
+
+    # Define the path to the secrets directory
+    $secretsDirPath = Join-Path -Path $PSScriptRoot -ChildPath "secrets"
+
+    # Check if the secrets directory exists
+    if (-Not (Test-Path -Path $secretsDirPath)) {
+        Write-Error "Secrets directory not found at '$secretsDirPath'."
+        throw "Secrets directory not found"
+    }
+
+    # List all folders (tenants) in the secrets directory
+    $tenantFolders = Get-ChildItem -Path $secretsDirPath -Directory
+
+    if ($tenantFolders.Count -eq 0) {
+        Write-Error "No tenant folders found in the secrets directory."
+        throw "No tenant folders found"
+    }
+
+    # Read configuration from the JSON file (do this once, outside tenant processing)
+    $configPath = Join-Path -Path $PSScriptRoot -ChildPath "config.json"
+    $config = Get-Content -Path $configPath -Raw | ConvertFrom-Json
+
+    # Check if we have multiple tenants
+    if ($tenantFolders.Count -eq 1) {
+        # Single tenant - use it automatically without prompting
+        $selectedTenant = $tenantFolders[0].Name
+        $selectedTenantPath = $tenantFolders[0].FullName
+        Write-Host "Using tenant: $selectedTenant" -ForegroundColor Green
+        
+        # Process the single tenant
+        Process-SingleTenant -TenantPath $selectedTenantPath -TenantName $selectedTenant -Config $config -ScriptRoot $PSScriptRoot
+    }
+    else {
+        # Multiple tenants - prompt for selection
+        Write-Host "Available tenant folders:"
+        $tenantFolders | ForEach-Object -Begin { $i = 1 } -Process {
+            Write-Host "$i. $($_.Name)"
+            $i++
+        }
+        Write-Host "$($tenantFolders.Count + 1). All tenants" -ForegroundColor Cyan
+
+        # Prompt user for selection
+        do {
+            $selection = Read-Host "Enter the number of the tenant folder you want to use (1-$($tenantFolders.Count + 1))"
+            
+            # Validate the input is a number
+            if ($selection -match '^\d+$') {
+                $selectedNumber = [int]$selection
+            } else {
+                $selectedNumber = -1
+            }
+            
+            # Check if selection is within valid range
+            if ($selectedNumber -lt 1 -or $selectedNumber -gt ($tenantFolders.Count + 1)) {
+                Write-Host "Invalid selection. Please enter a number between 1 and $($tenantFolders.Count + 1)." -ForegroundColor Yellow
+            }
+        } while ($selectedNumber -lt 1 -or $selectedNumber -gt ($tenantFolders.Count + 1))
+
+        # Check if user selected "All tenants"
+        if ($selectedNumber -eq ($tenantFolders.Count + 1)) {
+            # Process all tenants
+            Write-Host "You selected: All tenants" -ForegroundColor Green
+            Write-EnhancedLog -Message "Processing all tenants..." -Level 'INFO'
+            
+            $successCount = 0
+            $failureCount = 0
+            
+            foreach ($tenantFolder in $tenantFolders) {
+                try {
+                    Process-SingleTenant -TenantPath $tenantFolder.FullName -TenantName $tenantFolder.Name -Config $config -ScriptRoot $PSScriptRoot
+                    $successCount++
+                }
+                catch {
+                    Write-EnhancedLog -Message "Failed to process tenant '$($tenantFolder.Name)': $_" -Level 'ERROR'
+                    $failureCount++
+                    # Continue with next tenant instead of failing completely
+                    continue
+                }
+            }
+            
+            Write-EnhancedLog -Message "========================================" -Level 'INFO'
+            Write-EnhancedLog -Message "FINAL SUMMARY" -Level 'INFO'
+            Write-EnhancedLog -Message "========================================" -Level 'INFO'
+            Write-EnhancedLog -Message "Total tenants: $($tenantFolders.Count)" -Level 'INFO'
+            Write-EnhancedLog -Message "Successfully processed: $successCount" -Level 'INFO'
+            Write-EnhancedLog -Message "Failed: $failureCount" -Level 'INFO'
+            Write-EnhancedLog -Message "========================================" -Level 'INFO'
+            
+            if ($successCount -eq 0) {
+                Write-Error "No tenants could be processed successfully."
+                throw "No valid tenants found"
+            }
+        }
+        else {
+            # Get the selected tenant folder
+            $selectedIndex = $selectedNumber - 1
+            $selectedTenant = $tenantFolders[$selectedIndex].Name
+            $selectedTenantPath = $tenantFolders[$selectedIndex].FullName
+            
+            Write-Host "You selected: $selectedTenant" -ForegroundColor Green
+            
+            # Process the selected tenant
+            Process-SingleTenant -TenantPath $selectedTenantPath -TenantName $selectedTenant -Config $config -ScriptRoot $PSScriptRoot
+        }
+    }
+
+    #endregion Script Logic
+}
+catch {
+    Write-EnhancedLog -Message "An error occurred during script execution: $_" -Level 'ERROR'
+    if ($transcriptPath) {
+        Stop-Transcript
+        Write-EnhancedLog -Message "Transcript stopped." -ForegroundColor Cyan
+        # Stop logging in the finally block
+
+    }
+    else {
+        Write-EnhancedLog -Message "Transcript was not started due to an earlier error." -ForegroundColor Red
+    }
+
+    # Stop PSF Logging
+
+    # Ensure the log is written before proceeding
+    Wait-PSFMessage
+
+    # Stop logging in the finally block by disabling the provider
+    Set-PSFLoggingProvider -Name 'logfile' -InstanceName $instanceName -Enabled $false
+
+    Handle-Error -ErrorRecord $_
+    throw $_  # Re-throw the error after logging it
+} 
+finally {
+    # Ensure that the transcript is stopped even if an error occurs
+    if ($transcriptPath) {
+        Stop-Transcript
+        Write-EnhancedLog -Message "Transcript stopped." -ForegroundColor Cyan
+        # Stop logging in the finally block
+
+    }
+    else {
+        Write-EnhancedLog -Message "Transcript was not started due to an earlier error." -ForegroundColor Red
+    }
+    # 
+
+    
+    # Ensure the log is written before proceeding
+    Wait-PSFMessage
+
+    # Stop logging in the finally block by disabling the provider
+    Set-PSFLoggingProvider -Name 'logfile' -InstanceName $instanceName -Enabled $false
+
+}
\ No newline at end of file
diff --git a/POWERSHELL7_AUTHENTICATION_SOLUTION.md b/POWERSHELL7_AUTHENTICATION_SOLUTION.md
new file mode 100644
index 0000000..e281088
--- /dev/null
+++ b/POWERSHELL7_AUTHENTICATION_SOLUTION.md
@@ -0,0 +1,127 @@
+# PowerShell 7 Authentication Solution for IntuneWin32App
+
+## Problem Summary
+The IntuneWin32App module has issues with CNG certificates in PowerShell 5.1, causing the error:
+- "The property 'ClientId' cannot be found on this object" (actually a certificate compatibility issue)
+- "Could not use the certificate for signing" with CNG certificates
+
+## Solution Overview
+Use PowerShell 7 for authentication (which handles CNG certificates properly), then pass the token to PowerShell 5.1 for the IntuneWin32App operations.
+
+## Implementation Steps
+
+### Step 1: Get Token with PowerShell 7
+Run this in PowerShell 7 to authenticate and save the token:
+```powershell
+pwsh.exe -File "C:\Code\Intune-Win32-Deployer\Get-AuthTokenPS7.ps1"
+```
+
+This script:
+- Loads the certificate without CNG issues
+- Gets an access token from Azure AD
+- Saves the token to a temporary file
+- Validates the token with a test API call
+
+### Step 2: Use Token in PowerShell 5.1
+In your main script, replace the authentication block with:
+
+```powershell
+# Function to load authentication from PS7 token
+function Set-IntuneAuthFromPS7Token {
+    param(
+        [string]$TokenFile = (Join-Path $env:TEMP "intune_auth_token.json")
+    )
+    
+    try {
+        if (-not (Test-Path $TokenFile)) {
+            # Token file doesn't exist, need to run PS7 to get it
+            Write-EnhancedLog -Message "No saved token found. Launching PowerShell 7 to authenticate..." -Level "INFO"
+            
+            $ps7Path = "C:\Program Files\PowerShell\7\pwsh.exe"
+            $authScriptPath = "C:\Code\Intune-Win32-Deployer\Get-AuthTokenPS7.ps1"
+            
+            # Run PS7 to get the token
+            $process = Start-Process -FilePath $ps7Path -ArgumentList "-File", "`"$authScriptPath`"" -Wait -PassThru -NoNewWindow
+            
+            if ($process.ExitCode -ne 0) {
+                throw "PowerShell 7 authentication failed"
+            }
+        }
+        
+        # Load the token
+        $tokenData = Get-Content $TokenFile -Raw | ConvertFrom-Json
+        
+        # Check validity
+        $expiresOn = [DateTime]::Parse($tokenData.ExpiresOn).ToUniversalTime()
+        $now = [DateTime]::UtcNow
+        
+        if ($expiresOn -lt $now.AddMinutes(5)) {
+            # Token expires in less than 5 minutes, refresh it
+            Write-EnhancedLog -Message "Token expires soon. Refreshing..." -Level "INFO"
+            Remove-Item $TokenFile -Force
+            return Set-IntuneAuthFromPS7Token  # Recursive call to get new token
+        }
+        
+        # Set global variables for IntuneWin32App
+        $Global:AccessToken = [PSCustomObject]@{
+            AccessToken = $tokenData.AccessToken
+            ExpiresOn = $expiresOn
+            TokenType = $tokenData.TokenType
+        }
+        
+        $Global:AccessTokenTenantID = $tokenData.TenantId
+        $Global:AuthenticationHeader = @{
+            "Content-Type" = "application/json"
+            "Authorization" = "$($tokenData.TokenType) $($tokenData.AccessToken)"
+            "ExpiresOn" = $expiresOn.ToString()
+        }
+        
+        # Store for re-authentication
+        $Global:TenantId = $tokenData.TenantId
+        $Global:ClientId = $tokenData.ClientId
+        
+        Write-EnhancedLog -Message "Authentication successful (token valid until $expiresOn UTC)" -Level "INFO"
+        return $true
+    }
+    catch {
+        Write-EnhancedLog -Message "Failed to authenticate: $_" -Level "ERROR"
+        return $false
+    }
+}
+
+# Replace your existing authentication block with:
+if (-not (Set-IntuneAuthFromPS7Token)) {
+    throw "Failed to establish authentication"
+}
+```
+
+### Step 3: Update Ensure-IntuneAuthentication Function
+Update the module function to use the same approach:
+
+```powershell
+# In Ensure-IntuneAuthentication.ps1, add this option:
+if ($PSVersionTable.PSVersion.Major -eq 5 -and $CertPath) {
+    # Use PS7 for authentication if we're in PS5 with a certificate
+    Write-EnhancedLog -Message "Using PowerShell 7 for certificate authentication..." -Level "INFO"
+    
+    $tokenFile = Join-Path $env:TEMP "intune_auth_token.json"
+    # Check if we need a new token...
+    # (similar logic as above)
+}
+```
+
+## Benefits
+1. **No more CNG certificate errors**
+2. **Maintains compatibility with IntuneWin32App module**
+3. **Automatic token refresh when needed**
+4. **Seamless integration with existing code**
+
+## Testing
+1. Delete any existing token: `Remove-Item "$env:TEMP\intune_auth_token.json" -ErrorAction SilentlyContinue`
+2. Run your main script - it should automatically use PS7 for auth
+3. Subsequent runs will reuse the token until it expires
+
+## Troubleshooting
+- If PS7 is not installed: `winget install Microsoft.PowerShell`
+- If the certificate still fails: Check if it's properly exported with private key
+- Token file location: `$env:TEMP\intune_auth_token.json`
\ No newline at end of file
diff --git a/Reload-AuthToken.ps1 b/Reload-AuthToken.ps1
new file mode 100644
index 0000000..77b5f91
--- /dev/null
+++ b/Reload-AuthToken.ps1
@@ -0,0 +1,56 @@
+# Reload authentication token from saved file
+
+$tokenFile = Join-Path $env:TEMP "intune_auth_token.json"
+
+if (Test-Path $tokenFile) {
+    Write-Host "Found saved token file. Reloading..." -ForegroundColor Yellow
+    
+    $tokenData = Get-Content $tokenFile -Raw | ConvertFrom-Json
+    
+    # Set up global variables
+    $expiresOn = [DateTime]::Parse($tokenData.ExpiresOn).ToUniversalTime()
+    
+    $Global:AccessToken = [PSCustomObject]@{
+        AccessToken = $tokenData.AccessToken
+        ExpiresOn = $expiresOn
+        TokenType = $tokenData.TokenType
+    }
+    
+    $Global:AccessTokenTenantID = $tokenData.TenantId
+    $Global:AuthenticationHeader = @{
+        "Content-Type" = "application/json"
+        "Authorization" = "$($tokenData.TokenType) $($tokenData.AccessToken)"
+        "ExpiresOn" = $expiresOn.ToString()
+    }
+    
+    # Store additional globals
+    $Global:TenantId = $tokenData.TenantId
+    $Global:ClientId = $tokenData.ClientId
+    
+    Write-Host "Token reloaded successfully!" -ForegroundColor Green
+    Write-Host "Token expires at: $expiresOn" -ForegroundColor Cyan
+    
+    # Now check the types
+    Write-Host "`nToken object details:" -ForegroundColor Yellow
+    Write-Host "AccessToken type: $($Global:AccessToken.GetType().FullName)" -ForegroundColor Cyan
+    Write-Host "ExpiresOn type: $($Global:AccessToken.ExpiresOn.GetType().FullName)" -ForegroundColor Cyan
+    Write-Host "ExpiresOn value: $($Global:AccessToken.ExpiresOn)" -ForegroundColor Cyan
+    
+    # Test with IntuneWin32App module
+    Write-Host "`nTesting IntuneWin32App module..." -ForegroundColor Yellow
+    Import-Module IntuneWin32App -ErrorAction Stop
+    
+    try {
+        $apps = Get-IntuneWin32App -ErrorAction Stop
+        Write-Host "Successfully called Get-IntuneWin32App!" -ForegroundColor Green
+    }
+    catch {
+        Write-Host "Error: $_" -ForegroundColor Red
+        Write-Host "Full error:" -ForegroundColor Red
+        $_ | Format-List -Force
+    }
+}
+else {
+    Write-Host "No saved token file found at: $tokenFile" -ForegroundColor Red
+    Write-Host "Please run the main script first to authenticate." -ForegroundColor Yellow
+}
\ No newline at end of file
diff --git a/Test-AuthOnly.ps1 b/Test-AuthOnly.ps1
new file mode 100644
index 0000000..997b16d
--- /dev/null
+++ b/Test-AuthOnly.ps1
@@ -0,0 +1,203 @@
+# Direct test of just the authentication part
+# This extracts and tests only the authentication logic
+
+Write-Host "Testing Authentication Logic Only" -ForegroundColor Yellow
+Write-Host "=================================" -ForegroundColor Yellow
+
+# Load necessary functions
+function Write-EnhancedLog {
+    param($Message, $Level = "INFO")
+    $timestamp = Get-Date -Format "HH:mm:ss"
+    $color = switch($Level) {
+        "ERROR" { "Red" }
+        "WARNING" { "Yellow" }
+        "INFO" { "Cyan" }
+        default { "White" }
+    }
+    Write-Host "[$timestamp] $Message" -ForegroundColor $color
+}
+
+# Load secrets
+$secretsJsonPath = "C:\Code\Intune-Win32-Deployer\secrets\Lion's Housing Centres\secrets.json"
+Write-EnhancedLog -Message "Loading secrets from $secretsJsonPath" -Level "INFO"
+
+$secrets = Get-Content $secretsJsonPath -Raw | ConvertFrom-Json
+$tenantId = $secrets.TenantID
+$clientId = $secrets.ClientId
+$CertPassword = $secrets.CertPassword
+
+# Find certificate
+$baseOutputPath = $secrets.OutputPath
+$pfxFiles = Get-ChildItem -Path $baseOutputPath -Filter *.pfx -File -ErrorAction SilentlyContinue | 
+            Where-Object { $_.Name -like "*$clientId*" }
+
+if ($pfxFiles.Count -eq 0) {
+    Write-EnhancedLog -Message "No PFX file found" -Level "ERROR"
+    exit 1
+}
+
+$certPath = $pfxFiles[0].FullName
+Write-EnhancedLog -Message "Certificate found: $certPath" -Level "INFO"
+
+# Test the integrated authentication
+Write-EnhancedLog -Message "Establishing authentication with IntuneWin32App module..." -Level "INFO"
+try {
+    # Clear any existing authentication state first
+    Write-EnhancedLog -Message "Clearing any existing IntuneWin32App authentication state..." -Level "INFO"
+    $Global:AccessToken = $null
+    $Global:AuthenticationHeader = $null
+    $Global:AccessTokenTenantID = $null
+    
+    # Extract certificate thumbprint
+    $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certPath, $CertPassword)
+    $certThumbprint = $cert.Thumbprint
+    Write-EnhancedLog -Message "Certificate thumbprint: $certThumbprint" -Level "INFO"
+    Write-EnhancedLog -Message "Certificate subject: $($cert.Subject)" -Level "INFO"
+    
+    # Store the certificate object globally for later use
+    $Global:CertObject = $cert
+    
+    # Check if PowerShell 7 is available for CNG certificate handling
+    $ps7Path = "C:\Program Files\PowerShell\7\pwsh.exe"
+    $usePS7Auth = Test-Path $ps7Path
+    
+    if ($usePS7Auth) {
+        Write-EnhancedLog -Message "Using PowerShell 7 for certificate authentication (better CNG support)..." -Level "INFO"
+        
+        # Create a temporary script to run in PS7
+        $ps7ScriptContent = @"
+# PowerShell 7 Authentication Script
+param(
+    [string]`$TenantId,
+    [string]`$ClientId,
+    [string]`$CertPath,
+    [string]`$CertPassword
+)
+
+try {
+    Import-Module MSAL.PS -ErrorAction Stop
+    
+    # Load certificate - PS7 handles CNG certificates better
+    `$cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(`$CertPath, `$CertPassword)
+    
+    # Get token
+    `$msalToken = Get-MsalToken -TenantId `$TenantId -ClientId `$ClientId -ClientCertificate `$cert
+    
+    if (`$msalToken) {
+        # Create token data for PS5
+        `$tokenData = @{
+            AccessToken = `$msalToken.AccessToken
+            ExpiresOn = `$msalToken.ExpiresOn.ToString("o")
+            TenantId = `$TenantId
+            ClientId = `$ClientId
+            TokenType = "Bearer"
+        }
+        
+        # Save to temp file
+        `$tokenFile = Join-Path `$env:TEMP "intune_auth_token.json"
+        `$tokenData | ConvertTo-Json | Set-Content `$tokenFile -Force
+        
+        Write-Host "SUCCESS"
+        exit 0
+    }
+}
+catch {
+    Write-Host "ERROR: `$_"
+    exit 1
+}
+"@
+        
+        # Save PS7 script temporarily
+        $ps7ScriptPath = Join-Path $env:TEMP "Get-IntuneAuthPS7.ps1"
+        $ps7ScriptContent | Set-Content $ps7ScriptPath -Force
+        
+        # Run PS7 to get the token
+        $ps7Args = @("-NoProfile", "-ExecutionPolicy", "Bypass", "-File", "`"$ps7ScriptPath`"", "-TenantId", $tenantId, "-ClientId", $clientId, "-CertPath", "`"$certPath`"", "-CertPassword", "`"$CertPassword`"")
+        $ps7Process = Start-Process -FilePath $ps7Path -ArgumentList $ps7Args -Wait -PassThru -NoNewWindow -RedirectStandardOutput "$env:TEMP\ps7_auth_output.txt"
+        
+        # Check if PS7 authentication succeeded
+        if ($ps7Process.ExitCode -eq 0) {
+            # Load the token from PS7
+            $tokenFile = Join-Path $env:TEMP "intune_auth_token.json"
+            if (Test-Path $tokenFile) {
+                $tokenData = Get-Content $tokenFile -Raw | ConvertFrom-Json
+                
+                # Set up global variables in the format IntuneWin32App expects
+                $expiresOn = [DateTime]::Parse($tokenData.ExpiresOn).ToUniversalTime()
+                
+                $Global:AccessToken = [PSCustomObject]@{
+                    AccessToken = $tokenData.AccessToken
+                    ExpiresOn = $expiresOn
+                    TokenType = $tokenData.TokenType
+                }
+                
+                $Global:AccessTokenTenantID = $tokenData.TenantId
+                $Global:AuthenticationHeader = @{
+                    "Content-Type" = "application/json"
+                    "Authorization" = "$($tokenData.TokenType) $($tokenData.AccessToken)"
+                    "ExpiresOn" = $expiresOn.ToString()
+                }
+                
+                Write-EnhancedLog -Message "PowerShell 7 authentication successful" -Level "INFO"
+                Write-EnhancedLog -Message "Token expires at: $expiresOn" -Level "INFO"
+                
+                # Test authentication
+                try {
+                    $testUri = "https://graph.microsoft.com/v1.0/organization"
+                    $testResult = Invoke-RestMethod -Uri $testUri -Headers $Global:AuthenticationHeader -Method Get -ErrorAction Stop
+                    Write-EnhancedLog -Message "Authentication verified - connected to tenant: $($testResult.value[0].displayName)" -Level "INFO"
+                }
+                catch {
+                    Write-EnhancedLog -Message "Authentication test warning: $($_.Exception.Message)" -Level "WARNING"
+                }
+                
+                # Clean up temp files
+                Remove-Item $ps7ScriptPath -Force -ErrorAction SilentlyContinue
+                Remove-Item "$env:TEMP\ps7_auth_output.txt" -Force -ErrorAction SilentlyContinue
+            }
+            else {
+                throw "PowerShell 7 did not create token file"
+            }
+        }
+        else {
+            # PS7 auth failed, read the output for debugging
+            $ps7Output = Get-Content "$env:TEMP\ps7_auth_output.txt" -Raw -ErrorAction SilentlyContinue
+            Write-EnhancedLog -Message "PowerShell 7 authentication failed: $ps7Output" -Level "ERROR"
+            throw "PowerShell 7 authentication failed"
+        }
+    }
+    else {
+        Write-EnhancedLog -Message "PowerShell 7 not found. Direct MSAL would be used (likely to fail with CNG certs)." -Level "WARNING"
+    }
+    
+    # Final verification
+    Write-Host "`n=== AUTHENTICATION TEST RESULTS ===" -ForegroundColor Green
+    Write-Host "Global:AuthenticationHeader exists: $($null -ne $Global:AuthenticationHeader)" -ForegroundColor Cyan
+    Write-Host "Global:AccessToken exists: $($null -ne $Global:AccessToken)" -ForegroundColor Cyan
+    Write-Host "Global:AccessTokenTenantID: $Global:AccessTokenTenantID" -ForegroundColor Cyan
+    
+    if ($Global:AuthenticationHeader) {
+        Write-Host "`nAuthentication successful! Ready to deploy Win32 apps." -ForegroundColor Green
+        
+        # Test IntuneWin32App module
+        Write-Host "`nTesting IntuneWin32App module..." -ForegroundColor Yellow
+        Import-Module IntuneWin32App -ErrorAction Stop
+        
+        try {
+            $testApps = Get-IntuneWin32App -ErrorAction Stop | Select-Object -First 1
+            Write-Host "IntuneWin32App module is working correctly!" -ForegroundColor Green
+        }
+        catch {
+            Write-Host "IntuneWin32App module test: $($_.Exception.Message)" -ForegroundColor Yellow
+            Write-Host "This is normal if no apps are deployed yet." -ForegroundColor Yellow
+        }
+    }
+    else {
+        Write-Host "`nAuthentication FAILED!" -ForegroundColor Red
+    }
+}
+catch {
+    Write-EnhancedLog -Message "Failed to authenticate: $($_.Exception.Message)" -Level "ERROR"
+    Write-Host "`nFull error details:" -ForegroundColor Red
+    $_ | Format-List -Force
+}
\ No newline at end of file
diff --git a/Test-Authentication-Thumbprint.ps1 b/Test-Authentication-Thumbprint.ps1
new file mode 100644
index 0000000..a352cf1
--- /dev/null
+++ b/Test-Authentication-Thumbprint.ps1
@@ -0,0 +1,104 @@
+# Alternative test script that uses certificate from store
+param(
+    [string]$SecretsPath = "C:\Code\Intune-Win32-Deployer\secrets\Lion's Housing Centres\secrets.json"
+)
+
+# Import MSAL.PS
+try {
+    Import-Module MSAL.PS -ErrorAction Stop
+    Write-Host "MSAL.PS module imported successfully" -ForegroundColor Green
+}
+catch {
+    Write-Host "Failed to import MSAL.PS module: $_" -ForegroundColor Red
+    exit 1
+}
+
+# Load secrets
+try {
+    $secrets = Get-Content $SecretsPath -Raw | ConvertFrom-Json
+    $tenantId = $secrets.TenantID
+    $clientId = $secrets.ClientId
+    $thumbprint = $secrets.Thumbprint
+    
+    Write-Host "Secrets loaded successfully" -ForegroundColor Green
+    Write-Host "TenantID: $tenantId" -ForegroundColor Cyan
+    Write-Host "ClientID: $clientId" -ForegroundColor Cyan
+    Write-Host "Thumbprint: $thumbprint" -ForegroundColor Cyan
+}
+catch {
+    Write-Host "Failed to load secrets: $_" -ForegroundColor Red
+    exit 1
+}
+
+Write-Host "`nSearching for certificate in certificate store..." -ForegroundColor Yellow
+
+# Search for certificate in both user and machine stores
+$cert = Get-ChildItem -Path "Cert:\CurrentUser\My" | Where-Object { $_.Thumbprint -eq $thumbprint }
+if (-not $cert) {
+    Write-Host "Certificate not found in CurrentUser store, checking LocalMachine..." -ForegroundColor Yellow
+    $cert = Get-ChildItem -Path "Cert:\LocalMachine\My" | Where-Object { $_.Thumbprint -eq $thumbprint }
+}
+
+if ($cert) {
+    Write-Host "Certificate found in store!" -ForegroundColor Green
+    Write-Host "Subject: $($cert.Subject)" -ForegroundColor Cyan
+    Write-Host "Has Private Key: $($cert.HasPrivateKey)" -ForegroundColor Cyan
+    
+    if (-not $cert.HasPrivateKey) {
+        Write-Host "WARNING: Certificate does not have a private key!" -ForegroundColor Red
+        exit 1
+    }
+    
+    # Try authentication with certificate from store
+    try {
+        Write-Host "`nAttempting authentication with certificate from store..." -ForegroundColor Yellow
+        $msalToken = Get-MsalToken -TenantId $tenantId -ClientId $clientId -ClientCertificate $cert
+        
+        if ($msalToken) {
+            Write-Host "Authentication successful!" -ForegroundColor Green
+            Write-Host "Token expires at: $($msalToken.ExpiresOn)" -ForegroundColor Cyan
+            
+            # Test with Graph API
+            $headers = @{
+                "Authorization" = "Bearer $($msalToken.AccessToken)"
+                "Content-Type" = "application/json"
+            }
+            
+            $testUri = "https://graph.microsoft.com/v1.0/organization"
+            $testResult = Invoke-RestMethod -Uri $testUri -Headers $headers -Method Get
+            Write-Host "Connected to tenant: $($testResult.value[0].displayName)" -ForegroundColor Green
+        }
+    }
+    catch {
+        Write-Host "Authentication failed: $_" -ForegroundColor Red
+    }
+}
+else {
+    Write-Host "Certificate not found in any certificate store!" -ForegroundColor Red
+    Write-Host "The certificate may need to be imported to the certificate store first." -ForegroundColor Yellow
+    
+    # Offer to import the certificate
+    Write-Host "`nWould you like to import the certificate to the CurrentUser store? (Y/N)" -ForegroundColor Yellow
+    $response = Read-Host
+    
+    if ($response -eq 'Y' -or $response -eq 'y') {
+        try {
+            $certPassword = $secrets.CertPassword
+            $outputPath = $secrets.OutputPath
+            $certName = $secrets.CertName
+            $certPath = Join-Path $outputPath "$certName-$clientId.pfx"
+            
+            Write-Host "Importing certificate from: $certPath" -ForegroundColor Yellow
+            
+            $securePassword = ConvertTo-SecureString -String $certPassword -AsPlainText -Force
+            $importedCert = Import-PfxCertificate -FilePath $certPath -CertStoreLocation "Cert:\CurrentUser\My" -Password $securePassword
+            
+            Write-Host "Certificate imported successfully!" -ForegroundColor Green
+            Write-Host "Thumbprint: $($importedCert.Thumbprint)" -ForegroundColor Cyan
+            Write-Host "Please run this script again to test authentication." -ForegroundColor Yellow
+        }
+        catch {
+            Write-Host "Failed to import certificate: $_" -ForegroundColor Red
+        }
+    }
+}
\ No newline at end of file
diff --git a/Test-Authentication.ps1 b/Test-Authentication.ps1
new file mode 100644
index 0000000..3f86694
--- /dev/null
+++ b/Test-Authentication.ps1
@@ -0,0 +1,135 @@
+# Test script for IntuneWin32App authentication fix
+# This script tests the authentication separately before running the full deployer
+
+param(
+    [string]$SecretsPath = "C:\Code\Intune-Win32-Deployer\secrets\Lion's Housing Centres\secrets.json"
+)
+
+# Import only the required MSAL.PS module
+try {
+    Import-Module MSAL.PS -ErrorAction Stop
+    Write-Host "MSAL.PS module imported successfully" -ForegroundColor Green
+}
+catch {
+    Write-Host "Failed to import MSAL.PS module: $_" -ForegroundColor Red
+    Write-Host "Please ensure MSAL.PS is installed: Install-Module -Name MSAL.PS" -ForegroundColor Yellow
+    exit 1
+}
+
+# Load secrets
+try {
+    $secrets = Get-Content $SecretsPath -Raw | ConvertFrom-Json
+    $tenantId = $secrets.TenantID
+    $clientId = $secrets.ClientId
+    $CertPassword = $secrets.CertPassword
+    
+    # Construct the certificate path from the output path
+    $outputPath = $secrets.OutputPath
+    $certName = $secrets.CertName
+    $certPath = Join-Path $outputPath "$certName-$clientId.pfx"
+    
+    Write-Host "Secrets loaded successfully" -ForegroundColor Green
+    Write-Host "TenantID: $tenantId" -ForegroundColor Cyan
+    Write-Host "ClientID: $clientId" -ForegroundColor Cyan
+    Write-Host "CertPath: $certPath" -ForegroundColor Cyan
+    
+    # Verify certificate exists
+    if (-not (Test-Path $certPath)) {
+        throw "Certificate file not found at: $certPath"
+    }
+}
+catch {
+    Write-Host "Failed to load secrets: $_" -ForegroundColor Red
+    exit 1
+}
+
+# Test authentication
+Write-Host "`nTesting direct MSAL authentication..." -ForegroundColor Yellow
+
+try {
+    # Clear any existing authentication
+    $Global:AccessToken = $null
+    $Global:AuthenticationHeader = $null
+    $Global:AccessTokenTenantID = $null
+    
+    # Load certificate with specific flags to handle CNG certificates
+    $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
+    $cert.Import($certPath, $CertPassword, [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::PersistKeySet)
+    Write-Host "Certificate loaded. Thumbprint: $($cert.Thumbprint)" -ForegroundColor Green
+    
+    # Check if certificate has private key
+    if (-not $cert.HasPrivateKey) {
+        throw "Certificate does not have a private key"
+    }
+    
+    # Get token using MSAL.PS
+    Write-Host "Requesting token from Azure AD..." -ForegroundColor Yellow
+    $msalToken = Get-MsalToken -TenantId $tenantId -ClientId $clientId -ClientCertificate $cert
+    
+    if ($msalToken) {
+        Write-Host "Token obtained successfully!" -ForegroundColor Green
+        Write-Host "Access Token Type: $($msalToken.GetType().FullName)" -ForegroundColor Cyan
+        Write-Host "Token expires at: $($msalToken.ExpiresOn)" -ForegroundColor Cyan
+        
+        # Set up global variables
+        $Global:AccessToken = $msalToken
+        $Global:AccessTokenTenantID = $tenantId
+        $Global:AuthenticationHeader = @{
+            "Content-Type" = "application/json"
+            "Authorization" = "Bearer $($msalToken.AccessToken)"
+            "ExpiresOn" = $msalToken.ExpiresOn.UtcDateTime
+        }
+        
+        Write-Host "`nGlobal variables set successfully" -ForegroundColor Green
+        Write-Host "Global:AccessToken exists: $($null -ne $Global:AccessToken)" -ForegroundColor Cyan
+        Write-Host "Global:AuthenticationHeader exists: $($null -ne $Global:AuthenticationHeader)" -ForegroundColor Cyan
+        
+        # Test the authentication
+        Write-Host "`nTesting authentication with Graph API..." -ForegroundColor Yellow
+        $testUri = "https://graph.microsoft.com/v1.0/organization"
+        $testResult = Invoke-RestMethod -Uri $testUri -Headers $Global:AuthenticationHeader -Method Get -ErrorAction Stop
+        
+        Write-Host "Authentication test successful!" -ForegroundColor Green
+        Write-Host "Connected to tenant: $($testResult.value[0].displayName)" -ForegroundColor Cyan
+        Write-Host "Tenant ID: $($testResult.value[0].id)" -ForegroundColor Cyan
+        
+        # Test IntuneWin32App module function compatibility
+        Write-Host "`nTesting IntuneWin32App module compatibility..." -ForegroundColor Yellow
+        try {
+            Import-Module IntuneWin32App -ErrorAction Stop
+            
+            # Check if the module can use our authentication
+            # This would normally fail with Connect-MSIntuneGraph, but should work with our setup
+            Write-Host "IntuneWin32App module loaded" -ForegroundColor Green
+            
+            # Try a simple IntuneWin32App command
+            Write-Host "Attempting to retrieve Win32 apps..." -ForegroundColor Yellow
+            $apps = Get-IntuneWin32App -ErrorAction Stop | Select-Object -First 5
+            
+            if ($apps) {
+                Write-Host "Successfully retrieved Win32 apps using our authentication!" -ForegroundColor Green
+                Write-Host "Found $($apps.Count) apps (showing first 5)" -ForegroundColor Cyan
+                $apps | ForEach-Object { Write-Host "  - $($_.displayName)" -ForegroundColor Gray }
+            }
+            else {
+                Write-Host "No Win32 apps found, but authentication worked!" -ForegroundColor Yellow
+            }
+        }
+        catch {
+            Write-Host "IntuneWin32App test failed: $_" -ForegroundColor Red
+            Write-Host "This may be normal if no apps exist yet" -ForegroundColor Yellow
+        }
+        
+        Write-Host "`nAuthentication setup completed successfully!" -ForegroundColor Green
+        Write-Host "You can now run the main Intune-Win32-Deployer script." -ForegroundColor Cyan
+    }
+    else {
+        throw "Failed to obtain access token"
+    }
+}
+catch {
+    Write-Host "`nAuthentication test failed!" -ForegroundColor Red
+    Write-Host "Error: $_" -ForegroundColor Red
+    Write-Host "Full error details:" -ForegroundColor Red
+    $_ | Format-List -Force
+}
\ No newline at end of file
diff --git a/Test-DateTimeFix.ps1 b/Test-DateTimeFix.ps1
new file mode 100644
index 0000000..162b872
--- /dev/null
+++ b/Test-DateTimeFix.ps1
@@ -0,0 +1,43 @@
+# Test if the DateTime fix works
+
+Write-Host "Testing DateTime fix for IntuneWin32App module..." -ForegroundColor Yellow
+
+# First delete the old token to force re-authentication
+$tokenFile = Join-Path $env:TEMP "intune_auth_token.json"
+if (Test-Path $tokenFile) {
+    Remove-Item $tokenFile -Force
+    Write-Host "Removed old token file" -ForegroundColor Yellow
+}
+
+# Load the authentication function
+. .\Test-AuthOnly.ps1
+
+# The script above should have created new authentication with proper DateTimeOffset
+# Now test if it works
+
+Write-Host "`n`nChecking fixed authentication state..." -ForegroundColor Yellow
+Write-Host "AccessToken type: $($Global:AccessToken.GetType().FullName)" -ForegroundColor Cyan
+Write-Host "ExpiresOn type: $($Global:AccessToken.ExpiresOn.GetType().FullName)" -ForegroundColor Cyan
+Write-Host "ExpiresOn value: $($Global:AccessToken.ExpiresOn)" -ForegroundColor Cyan
+
+# Test with IntuneWin32App module
+Write-Host "`nTesting IntuneWin32App module with fixed DateTime..." -ForegroundColor Yellow
+Import-Module IntuneWin32App -ErrorAction Stop
+
+try {
+    $apps = Get-IntuneWin32App -ErrorAction Stop | Select-Object -First 5
+    Write-Host "SUCCESS! Get-IntuneWin32App works with the DateTime fix!" -ForegroundColor Green
+    
+    if ($apps) {
+        Write-Host "Found $($apps.Count) apps" -ForegroundColor Cyan
+        $apps | ForEach-Object { Write-Host "  - $($_.displayName)" -ForegroundColor Gray }
+    }
+    else {
+        Write-Host "No apps found, but the command executed successfully!" -ForegroundColor Green
+    }
+}
+catch {
+    Write-Host "Still getting error: $_" -ForegroundColor Red
+    Write-Host "`nFull error details:" -ForegroundColor Red
+    $_ | Format-List -Force
+}
\ No newline at end of file
diff --git a/Test-IntegratedAuth.ps1 b/Test-IntegratedAuth.ps1
new file mode 100644
index 0000000..3aa3db6
--- /dev/null
+++ b/Test-IntegratedAuth.ps1
@@ -0,0 +1,169 @@
+# Test script to verify the integrated PS7/PS5 authentication
+# This simulates just the authentication part of the main script
+
+# Force PowerShell 5 as the main script does
+if ($PSVersionTable.PSVersion.Major -ge 7) {
+    Write-Host "Relaunching in PowerShell 5..."
+    $ps5Path = "$($env:SystemRoot)\System32\WindowsPowerShell\v1.0\powershell.exe"
+    $ps5Args = "-NoExit -NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`""
+    Start-Process -FilePath $ps5Path -ArgumentList $ps5Args
+    exit
+}
+
+Write-Host "Running in PowerShell $($PSVersionTable.PSVersion)" -ForegroundColor Cyan
+
+# Load secrets
+$secretsJsonPath = "C:\Code\Intune-Win32-Deployer\secrets\Lion's Housing Centres\secrets.json"
+$secrets = Get-Content $secretsJsonPath -Raw | ConvertFrom-Json
+
+# Extract values
+$tenantId = $secrets.TenantID
+$clientId = $secrets.ClientId
+$CertPassword = $secrets.CertPassword
+
+# Find certificate path
+$baseOutputPath = $secrets.OutputPath
+$pfxFiles = Get-ChildItem -Path $baseOutputPath -Filter *.pfx -File -ErrorAction SilentlyContinue | 
+            Where-Object { $_.Name -like "*$clientId*" }
+
+if ($pfxFiles.Count -eq 0) {
+    Write-Host "ERROR: No PFX file found" -ForegroundColor Red
+    exit 1
+}
+
+$certPath = $pfxFiles[0].FullName
+Write-Host "Certificate found: $certPath" -ForegroundColor Green
+
+# Test the authentication logic
+try {
+    Write-Host "`nTesting integrated authentication..." -ForegroundColor Yellow
+    
+    # Clear any existing authentication
+    $Global:AccessToken = $null
+    $Global:AuthenticationHeader = $null
+    $Global:AccessTokenTenantID = $null
+    
+    # Load certificate for verification
+    $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certPath, $CertPassword)
+    Write-Host "Certificate loaded. Thumbprint: $($cert.Thumbprint)" -ForegroundColor Green
+    
+    # Check if PowerShell 7 is available
+    $ps7Path = "C:\Program Files\PowerShell\7\pwsh.exe"
+    $usePS7Auth = Test-Path $ps7Path
+    
+    if ($usePS7Auth) {
+        Write-Host "PowerShell 7 found. Using it for authentication..." -ForegroundColor Green
+        
+        # Create the PS7 script content (same as in main script)
+        $ps7ScriptContent = @"
+param(
+    [string]`$TenantId,
+    [string]`$ClientId,
+    [string]`$CertPath,
+    [string]`$CertPassword
+)
+
+try {
+    Import-Module MSAL.PS -ErrorAction Stop
+    `$cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(`$CertPath, `$CertPassword)
+    `$msalToken = Get-MsalToken -TenantId `$TenantId -ClientId `$ClientId -ClientCertificate `$cert
+    
+    if (`$msalToken) {
+        `$tokenData = @{
+            AccessToken = `$msalToken.AccessToken
+            ExpiresOn = `$msalToken.ExpiresOn.ToString("o")
+            TenantId = `$TenantId
+            ClientId = `$ClientId
+            TokenType = "Bearer"
+        }
+        
+        `$tokenFile = Join-Path `$env:TEMP "intune_auth_token.json"
+        `$tokenData | ConvertTo-Json | Set-Content `$tokenFile -Force
+        Write-Host "SUCCESS"
+        exit 0
+    }
+}
+catch {
+    Write-Host "ERROR: `$_"
+    exit 1
+}
+"@
+        
+        # Save and run PS7 script
+        $ps7ScriptPath = Join-Path $env:TEMP "Get-IntuneAuthPS7.ps1"
+        $ps7ScriptContent | Set-Content $ps7ScriptPath -Force
+        
+        $ps7Args = @("-NoProfile", "-ExecutionPolicy", "Bypass", "-File", "`"$ps7ScriptPath`"", 
+                     "-TenantId", $tenantId, "-ClientId", $clientId, 
+                     "-CertPath", "`"$certPath`"", "-CertPassword", "`"$CertPassword`"")
+        
+        Write-Host "Launching PowerShell 7 for authentication..." -ForegroundColor Yellow
+        $ps7Process = Start-Process -FilePath $ps7Path -ArgumentList $ps7Args -Wait -PassThru -NoNewWindow -RedirectStandardOutput "$env:TEMP\ps7_auth_output.txt"
+        
+        if ($ps7Process.ExitCode -eq 0) {
+            Write-Host "PowerShell 7 authentication completed successfully!" -ForegroundColor Green
+            
+            # Load the token
+            $tokenFile = Join-Path $env:TEMP "intune_auth_token.json"
+            if (Test-Path $tokenFile) {
+                $tokenData = Get-Content $tokenFile -Raw | ConvertFrom-Json
+                
+                # Set up global variables
+                $expiresOn = [DateTime]::Parse($tokenData.ExpiresOn).ToUniversalTime()
+                
+                $Global:AccessToken = [PSCustomObject]@{
+                    AccessToken = $tokenData.AccessToken
+                    ExpiresOn = $expiresOn
+                    TokenType = $tokenData.TokenType
+                }
+                
+                $Global:AccessTokenTenantID = $tokenData.TenantId
+                $Global:AuthenticationHeader = @{
+                    "Content-Type" = "application/json"
+                    "Authorization" = "$($tokenData.TokenType) $($tokenData.AccessToken)"
+                    "ExpiresOn" = $expiresOn.ToString()
+                }
+                
+                Write-Host "Token loaded successfully!" -ForegroundColor Green
+                Write-Host "Token expires at: $expiresOn" -ForegroundColor Cyan
+                
+                # Test authentication
+                Write-Host "`nTesting authentication with Graph API..." -ForegroundColor Yellow
+                $testUri = "https://graph.microsoft.com/v1.0/organization"
+                $testResult = Invoke-RestMethod -Uri $testUri -Headers $Global:AuthenticationHeader -Method Get
+                Write-Host "SUCCESS: Connected to tenant: $($testResult.value[0].displayName)" -ForegroundColor Green
+                
+                # Test IntuneWin32App module
+                Write-Host "`nTesting IntuneWin32App module compatibility..." -ForegroundColor Yellow
+                Import-Module IntuneWin32App -ErrorAction Stop
+                
+                try {
+                    $apps = Get-IntuneWin32App -ErrorAction Stop | Select-Object -First 5
+                    Write-Host "IntuneWin32App module test passed!" -ForegroundColor Green
+                    if ($apps) {
+                        Write-Host "Found $($apps.Count) Win32 apps" -ForegroundColor Cyan
+                    }
+                }
+                catch {
+                    Write-Host "IntuneWin32App test: $($_.Exception.Message)" -ForegroundColor Yellow
+                }
+                
+                # Clean up
+                Remove-Item $ps7ScriptPath -Force -ErrorAction SilentlyContinue
+                Remove-Item "$env:TEMP\ps7_auth_output.txt" -Force -ErrorAction SilentlyContinue
+            }
+        }
+        else {
+            $ps7Output = Get-Content "$env:TEMP\ps7_auth_output.txt" -Raw -ErrorAction SilentlyContinue
+            Write-Host "PowerShell 7 authentication failed!" -ForegroundColor Red
+            Write-Host "Output: $ps7Output" -ForegroundColor Red
+        }
+    }
+    else {
+        Write-Host "PowerShell 7 not found. Would fall back to direct MSAL (likely to fail with CNG certs)." -ForegroundColor Yellow
+    }
+}
+catch {
+    Write-Host "Error during authentication: $_" -ForegroundColor Red
+    $_ | Format-List -Force
+}
\ No newline at end of file
diff --git a/Test-MainScript.ps1 b/Test-MainScript.ps1
new file mode 100644
index 0000000..fa94cb3
--- /dev/null
+++ b/Test-MainScript.ps1
@@ -0,0 +1,43 @@
+# Test runner for the main script
+# This will test if the authentication works in the actual script
+
+Write-Host "Starting main script test..." -ForegroundColor Yellow
+Write-Host "This will test the authentication portion only" -ForegroundColor Cyan
+
+# Set environment variable for dev mode
+[System.Environment]::SetEnvironmentVariable('EnvironmentMode', 'dev', 'Machine')
+
+# Run the main script but exit after authentication
+$scriptPath = "C:\Code\Intune-Win32-Deployer\Intune-Win32-Deployer-ALPHAv1.ps1"
+
+# We'll modify the command to exit after auth test
+$testScript = @'
+# Load the main script content
+$mainScript = Get-Content "C:\Code\Intune-Win32-Deployer\Intune-Win32-Deployer-ALPHAv1.ps1" -Raw
+
+# Add an exit after authentication verification
+$modifiedScript = $mainScript -replace '(\$Global:AuthenticationHeader\) \{[\s\S]*?Write-EnhancedLog[^\n]*"IntuneWin32App module authentication verified successfully"[^\n]*\n', @'
+$Global:AuthenticationHeader) {
+            Write-EnhancedLog -Message "IntuneWin32App module authentication verified successfully" -Level "INFO"
+            
+            # TEST MODE: Exit after successful authentication
+            Write-Host "`n`nTEST SUCCESSFUL: Authentication completed!" -ForegroundColor Green
+            Write-Host "Global:AuthenticationHeader exists: $($null -ne $Global:AuthenticationHeader)" -ForegroundColor Cyan
+            Write-Host "Global:AccessToken exists: $($null -ne $Global:AccessToken)" -ForegroundColor Cyan
+            Write-Host "Ready to process Win32 apps!" -ForegroundColor Green
+            exit 0
+'@
+
+# Save modified script
+$tempScript = "$env:TEMP\Test-MainScript-Temp.ps1"
+$modifiedScript | Set-Content $tempScript -Force
+
+# Run it
+& $tempScript
+'@
+
+# Execute the test
+$testScript | Set-Content "$env:TEMP\RunMainScriptTest.ps1" -Force
+
+Write-Host "`nLaunching main script in test mode..." -ForegroundColor Yellow
+& "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile -ExecutionPolicy Bypass -File "$env:TEMP\RunMainScriptTest.ps1"
\ No newline at end of file
diff --git a/Use-SavedAuthToken.ps1 b/Use-SavedAuthToken.ps1
new file mode 100644
index 0000000..34fa428
--- /dev/null
+++ b/Use-SavedAuthToken.ps1
@@ -0,0 +1,83 @@
+# Function to load authentication token saved by PowerShell 7
+function Set-IntuneAuthFromSavedToken {
+    param(
+        [string]$TokenFile = (Join-Path $env:TEMP "intune_auth_token.json")
+    )
+    
+    try {
+        if (-not (Test-Path $TokenFile)) {
+            throw "Token file not found. Please run Get-AuthTokenPS7.ps1 first."
+        }
+        
+        # Load the token data
+        $tokenData = Get-Content $TokenFile -Raw | ConvertFrom-Json
+        
+        # Check if token is still valid
+        $expiresOn = [DateTime]::Parse($tokenData.ExpiresOn).ToUniversalTime()
+        $now = [DateTime]::UtcNow
+        
+        Write-Host "Token expires at: $expiresOn UTC" -ForegroundColor Cyan
+        Write-Host "Current time: $now UTC" -ForegroundColor Cyan
+        
+        if ($expiresOn -lt $now) {
+            throw "Token has expired. Please run Get-AuthTokenPS7.ps1 again."
+        }
+        
+        Write-Host "Token is valid until: $expiresOn UTC" -ForegroundColor Green
+        
+        # Set the global variables that IntuneWin32App module expects
+        $Global:AccessToken = [PSCustomObject]@{
+            AccessToken = $tokenData.AccessToken
+            ExpiresOn = $expiresOn
+            TokenType = $tokenData.TokenType
+        }
+        
+        $Global:AccessTokenTenantID = $tokenData.TenantId
+        
+        $Global:AuthenticationHeader = @{
+            "Content-Type" = "application/json"
+            "Authorization" = "$($tokenData.TokenType) $($tokenData.AccessToken)"
+            "ExpiresOn" = $expiresOn.ToString()
+        }
+        
+        # Store for potential re-authentication
+        $Global:TenantId = $tokenData.TenantId
+        $Global:ClientId = $tokenData.ClientId
+        
+        Write-Host "Authentication loaded from saved token successfully!" -ForegroundColor Green
+        
+        # Test the authentication
+        try {
+            $testUri = "https://graph.microsoft.com/v1.0/organization"
+            $testResult = Invoke-RestMethod -Uri $testUri -Headers $Global:AuthenticationHeader -Method Get -ErrorAction Stop
+            Write-Host "Authentication verified - connected to: $($testResult.value[0].displayName)" -ForegroundColor Green
+            return $true
+        }
+        catch {
+            Write-Warning "Authentication test failed: $_"
+            return $false
+        }
+    }
+    catch {
+        Write-Host "Failed to load authentication from saved token: $_" -ForegroundColor Red
+        return $false
+    }
+}
+
+# Example usage in your main script:
+# Just call this function instead of the authentication block
+if (Set-IntuneAuthFromSavedToken) {
+    Write-Host "Ready to use IntuneWin32App module functions!" -ForegroundColor Green
+    
+    # Test with IntuneWin32App module
+    try {
+        Import-Module IntuneWin32App -ErrorAction Stop
+        $apps = Get-IntuneWin32App -ErrorAction Stop | Select-Object -First 5
+        if ($apps) {
+            Write-Host "Successfully retrieved $($apps.Count) Win32 apps" -ForegroundColor Green
+        }
+    }
+    catch {
+        Write-Host "IntuneWin32App test: $_" -ForegroundColor Yellow
+    }
+}
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/.DS_Store b/Win32Apps-Gallery/Cisco/Cisco Secure Client/.DS_Store
new file mode 100644
index 0000000..17eb8a7
Binary files /dev/null and b/Win32Apps-Gallery/Cisco/Cisco Secure Client/.DS_Store differ
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/.archive/Umbrella-Detection-Script.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/.archive/Umbrella-Detection-Script.ps1
new file mode 100644
index 0000000..adad8f1
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/.archive/Umbrella-Detection-Script.ps1	
@@ -0,0 +1,8 @@
+$UmbrellaService = Get-Service -Name "csc_umbrellaagent" -ErrorAction SilentlyContinue
+if ($UmbrellaService -and $UmbrellaService.Status -eq "Running") {
+    Write-Host "Umbrella service is installed and running"
+    Exit 0
+} else {
+    Write-Host "Umbrella service is not installed or not running"
+    Exit 1
+}
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/.claude/settings.local.json b/Win32Apps-Gallery/Cisco/Cisco Secure Client/.claude/settings.local.json
new file mode 100644
index 0000000..0ba5c25
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/.claude/settings.local.json	
@@ -0,0 +1,35 @@
+{
+  "permissions": {
+    "allow": [
+      "Bash(pwsh:*)",
+      "Bash(powershell.exe:*)",
+      "Bash(python3:*)",
+      "Bash(cp:*)",
+      "Bash(sed:*)",
+      "Bash(powershell:*)",
+      "Bash(echo $?)",
+      "Bash(echo $LASTEXITCODE)",
+      "Bash(echo:*)",
+      "Bash(ls:*)",
+      "Bash(find:*)",
+      "Bash(awk:*)",
+      "Bash(cat:*)",
+      "Bash(git --version)",
+      "Bash(curl:*)",
+      "Bash(wget:*)",
+      "Bash(tar:*)",
+      "Bash(gzip:*)",
+      "Bash(node:*)",
+      "Bash(npm:*)",
+      "Bash(pip --version)",
+      "Bash(apt:*)",
+      "Bash(cut:*)",
+      "Bash(ssh:*)",
+      "Bash(rsync:*)",
+      "Bash(make:*)",
+      "Bash(gcc:*)",
+      "Bash(rm:*)"
+    ],
+    "deny": []
+  }
+}
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/CLAUDE.md b/Win32Apps-Gallery/Cisco/Cisco Secure Client/CLAUDE.md
new file mode 100644
index 0000000..34f2e70
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/CLAUDE.md	
@@ -0,0 +1,30 @@
+**PowerShell 5.1 vs 7 Compatibility Issues:**
+<?xml version="1.0" encoding="UTF-8"?>
+<PowerShellCodingStandards version="1.0">
+  <!-- CRITICAL STANDARDS -->
+  <!-- Variables: Never place colons after variable names ($var: value), use proper spacing or ${var}: -->
+  <!-- Operators: Use -and, -or, -not, -eq, -ne, -gt, -lt, -ge, -le; NEVER use &&, ||, !, ==, !=, >, <, >=, <= -->
+  <!-- Null: Place $null on LEFT side of comparisons: ($null -eq $var) NOT ($var -eq $null) -->
+  <!-- Conditionals: Use ($result = if ($cond) { $true } else { $false }) NOT ternary operators -->
+  <!-- Special Ops: NEVER use PowerShell 7+ operators (??, ?.) in PowerShell 5.1 code -->
+  <!-- Params: Never use reserved parameter names (Verbose, Debug, ErrorAction, etc.) -->
+  <!-- Variables: Never reassign automatic variables like $PSScriptRoot or $MyInvocation -->
+  <!-- Strings: Use ASCII-compatible chars, not Unicode symbols like ? or ? -->
+  <!-- String Multiplication: Use parentheses for string multiplication in concatenation: ("=" * 60) NOT "="*60 -->
+  <!-- Modules: Place all Export-ModuleMember statements ONLY in the main .psm1 file -->
+  <!-- Functions: Always include complete comment-based help for all functions -->
+  <!-- Organization: Use #region/#endregion markers for logical code sections -->
+  <!-- Comments: Include detailed comments for initialization, logic, loops, error handling -->
+  <!-- CRITICAL: NEVER USE PESTER FOR TESTING UNDER ANY CIRCUMSTANCES! -->
+  <!-- Use script-based testing with functions and try/catch blocks instead -->
+  <!-- If lint errors persist after a few attempts, do not continue trying to fix them. Instead, inform the human user about the persistent errors and request manual intervention. -->
+  
+  <!-- COMMAND LINE EXECUTION BEST PRACTICES -->
+  <!-- PowerShell -Command: Prone to escaping issues with $, {}, quotes, <, > characters -->
+  <!-- PowerShell -File: Much more reliable for complex scripts - write to .ps1 file first -->
+  <!-- Unix Tools: Prefer grep, awk, sed for text processing - more predictable and composable -->
+  <!-- Mixed Approach: Use PowerShell for Windows-specific tasks (registry, WMI), Unix tools for general processing -->
+  <!-- Complex Commands: For multi-line or complex PowerShell, ALWAYS use script files instead of -Command -->
+  <!-- Escaping: When using -Command, be extremely careful with special characters and quotes -->
+  <!-- Path Handling: Use forward slashes in Git Bash, backslashes in PowerShell scripts -->
+</PowerShellCodingStandards>
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/Cisco Secure Client Installation procedure.docx b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Cisco Secure Client Installation procedure.docx
new file mode 100644
index 0000000..ca571fa
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Cisco Secure Client Installation procedure.docx	
@@ -0,0 +1,84 @@
+                                       
+                                       
+                                       
+                                       
+                  Cisco Secure Client Installation Procedure
+                                   Version 1
+                                       
+                                       
+                                       
+                                       
+                                       
+                                       
+                                       
+                                       
+                                       
+
+
+
+
+
+
+
+
+
+Contents
+
+Purpose	3
+Scope	3
+Steps	3
+Installation Verification	4
+
+
+
+
+
+Purpose 	
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+This procedure instructs on how to install Umbrella Cisco Secure client on end user's devices.
+Scope
+
+ETS internal and external clients
+Steps
+
+ Copy and paste installation folder (Provided by ETS SOC) on device's C drive.
+ Installation folder should have below (or similar) files.
+
+ Now Run Command Prompt as an admin and switch to a file path where Installation package folder has been saved. 
+ 
+ Now run the following 3 commands one by one. Please make sure that the software version you have matches with the command.
+
+msiexec /package cisco-secure-client-win-5.1.10.233-core-vpn-predeploy-k9.msi PRE_DEPLOY_DISABLE_VPN=1 /norestart /passive /lvx* vpninstall.log
+
+msiexec /package cisco-secure-client-win-5.1.10.233-umbrella-predeploy-k9.msi PRE_DEPLOY_DISABLE_VPN=1 /norestart /passive /lvx* umbrellainstall.log
+
+msiexec /package cisco-secure-client-win-5.1.10.233-dart-predeploy-k9.msi /norestart /passive /lvx* dartinstall.log
+
+ Commands should run without any error messages.
+
+
+Installation Verification
+ Open "Service" on target device and you should see following 3 services populated and running.
+
+ To verify if Umbrella Policies are being applied to this device or not, please visit test domain "http://examplemalwaredomain.com [HYPERLINK: http://examplemalwaredomain.com/]"
+ You should see below (or similar) block page if installation was successful.
+   
+ 
+
+
+
+
+
+
+Revision History:
+
+
+Revision Date
+Action
+Author
+07/10/2025
+Initial Document
+Kaushal Patel
+
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/Cisco-icon.png b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Cisco-icon.png
new file mode 100644
index 0000000..9847b3d
Binary files /dev/null and b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Cisco-icon.png differ
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/Umbrella Connector/.DS_Store b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Umbrella Connector/.DS_Store
new file mode 100644
index 0000000..a9663e6
Binary files /dev/null and b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Umbrella Connector/.DS_Store differ
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-Windows-Service/Config.dat b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-Windows-Service/Config.dat
new file mode 100644
index 0000000..e323fbf
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-Windows-Service/Config.dat	
@@ -0,0 +1,14 @@
+{
+    "LogLevel" : "1",
+    "SyncServer" : "https://api.opendns.com/v2/",
+    "Org_ID" : "8329794",
+    "Org_Token" : "d1c3f944503fcca3f8a4cdee2d39ba2b758e6a014dfca082f1884934a237675c",
+    "FedRamp" : "0",
+    "TokenGenerationURL": "https://api.umbrella.com/auth/v2/token",
+    "Credentials" : { 
+        "ClientApiKey": "",
+        "ClientApiSecret": ""
+    },
+    "SyncGwServer" : "https://api.umbrella.com",
+    "AuthType" : "fallback"
+}
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-WindowsConfigurationScript-2025-07-09 (1).wsf b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-WindowsConfigurationScript-2025-07-09 (1).wsf
new file mode 100644
index 0000000..635fa88
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-WindowsConfigurationScript-2025-07-09 (1).wsf	
@@ -0,0 +1,1606 @@
+<job>
+<script Language="VBScript">
+Option Explicit
+
+'*************************************************************************************************************
+' START MAIN
+'*************************************************************************************************************
+
+' GLOBAL DEFINITIONS
+
+' This will now be the default sAMAccountName, if the user leaves the prompt for Service Account name empty. 
+Const ACCOUNT_NAME = "Cisco_Connector"
+
+' Check this is being launched by cscript
+'********************************************************
+if (instr(lcase(WScript.FullName), "wscript")) Then
+    MsgBox "Use " & chr(34) & "cscript " & WScript.ScriptName & chr(34) & " to run this script." & vbcrlf & vbcrlf & _
+            "This script must be run from an elevated command prompt", vbCritical, "DCSetup: Incorrect scripting engine"
+    WScript.Quit
+End if
+
+' Needed globals
+'********************************************************
+Dim gOS ' Can be 0=Reserved,1=2003,2=2008,3=2012,4=Win7,5=Other,6=2016,7=2019,8=Microsoft Windows Server Standard,9=Microsoft Windows Server Datacenter,10=2022
+Dim gFunctionalLevel ' Can be 0=mixed, 1=2003-interim, 2=2003, 3=2008, 4=2008r2, 5=2012, 6=2016r2, 7=2016
+Dim gSP
+Dim gR2 ' Empty means it's not R2
+Dim gDomain
+Dim gDomainFull
+Dim gOrgID
+Dim gCustomerID_Token
+Dim gIntIP
+Dim gServerLabel
+Dim gAssetType
+Dim gToken
+Dim gAccessToken
+Dim gUptime
+Dim gCloudEndpoint
+Dim gTokenEndpoint
+Dim gAuthType
+Dim gApiGwURL
+Dim gVersion
+Dim gDomainFullyQualifiedDomain
+Dim gAccountName
+Dim gClientId
+Dim gClientSecret
+Dim gFedramp
+Dim gOauthAuthentication
+Dim gFWChecked, gFWEnabled, gFWRemoteAdmin, gADUserExists, gRDCPermissions, gELRMember, gForceNetBios
+Dim gManageELPSet
+Dim gForceUserExists, gForceFW, gForceAdmin, gForceFL, gForceRegister, gForceNonVA
+Dim gAccountSID
+Dim gObjSvc, gObjSecurity
+Dim gObjRegistry
+Dim regdec
+Dim decision
+
+gDomainFullyQualifiedDomain = ""
+gOrgID = "8329794"
+gClientId = ""
+gClientSecret = ""
+gTokenEndpoint = "https://api.umbrella.com/auth/v2/token"
+gFedramp = "0"
+gAuthType = "fallback"
+gApiGwURL = "https://api.umbrella.com"
+
+gCustomerID_Token = "d1c3f944503fcca3f8a4cdee2d39ba2b758e6a014dfca082f1884934a237675c"
+gCloudEndpoint = "https://api.opendns.com/v2/"
+gOS = 0
+gFunctionalLevel = 0
+gSP = ""
+gR2 = ""
+gVersion = "1.1.26"
+gServerLabel = "DefaultLabel"
+gAssetType = "domain_controller" ' Means DC
+gToken = ""
+gAccessToken = ""
+gUptime = 0
+gOauthAuthentication = "0"
+If (gFedramp) = "1" Then
+   gOauthAuthentication = "1"
+End If
+
+If (((gAuthType = "enhanced") Or (gAuthType = "fallback")) And ((gClientId <> "") And (gClientSecret <> ""))) Then
+   gOauthAuthentication = "1"
+   gCloudEndpoint = gApiGwURL
+ElseIf (((gAuthType = "legacy") Or (gAuthType = "fallback")) And (gCustomerID_Token <> "")) Then
+   gOauthAuthentication = "0"
+Else
+   gOauthAuthentication = "99"
+   gCloudEndpoint = ""
+End If
+
+' Make sure there is a trailing slash on the endpoint
+If (Right(gCloudEndpoint, 1) <> "/") Then
+   gCloudEndpoint = gCloudEndpoint + "/"
+End If
+
+' Globals that are set during Test functions, and must be True to be considered "configured"
+gFWChecked = True
+gFWEnabled = False
+gFWRemoteAdmin = False
+gADUserExists = False
+gRDCPermissions = False
+gELRMember = False
+gForceNetBios = ""
+
+gManageELPSet = False
+
+gForceUserExists = False
+gForceFW = False
+gForceAdmin = False
+gForceFL = False
+gForceRegister = False
+gForceNonVA = False 'False means VA Mode. Business as usual'
+
+' Account ID, needed by other functions
+gAccountSID = ""
+
+' Global WMI objects
+' Connect to WMI root\cimv2 namespace (needed by many other functions)
+Set gObjSvc = GetObject("WINMGMTS:root/cimv2")
+' Get the single __SystemSecurity object in this namespace
+Set gObjSecurity = gObjSvc.Get("__SystemSecurity=@")
+
+' Registry globals and constants
+Set gObjRegistry = GetObject("WINMGMTS:root/default:StdRegProv")
+Const HKEY_LOCAL_MACHINE = &H80000002
+Const DCOM_REG_PATH = "SOFTWARE\Microsoft\Ole\"
+Const DCOM_REG_KEY = "MachineLaunchRestriction"
+
+' WMI constants
+Const SE_DACL_PRESENT = &h4
+Const ACCESS_ALLOWED_ACE_TYPE = &h0
+Const ACE_ENABLE_ACCOUNT = 1 ' Read
+Const ACE_REMOTE_ENABLE = 32 ' Execute/Traverse
+Const ACE_READ_SECURITY = 131072 ' Read Control
+
+' DCOM constants
+Const DCOM_ENABLE_ACCOUNT = 1 ' Create Child
+Const DCOM_REMOTE_LAUNCH = 4 ' List Children
+Const DCOM_REMOTE_ACTIVATION = 16 ' Read Property
+
+' RDC constants
+Const ADS_RIGHT_DS_CONTROL_ACCESS = &H100
+Const ADS_ACETYPE_ACCESS_ALLOWED_OBJECT = &H5   'Allows an object to do something
+Const ADS_FLAG_OBJECT_TYPE_PRESENT = &H1   'Target object type is present in the ACE 
+Const SCHEMA_GUID_MS_REPLICATION_GET_CHANGES = "{1131F6AA-9C07-11D1-F79F-00C04FC2DCD2}"
+
+' Group constants
+Const ELR_SID = "S-1-5-32-573"
+Const DCOM_SID = "S-1-5-32-562"
+
+
+' Args
+'********************************************************
+CollectArgs()
+
+' OS Test - Do this early for conditional checks later on based on OS
+'********************************************************
+TestOS()
+
+' Check for Administrator privileges
+'********************************************************
+If (IsAdmin() <> 1) Then
+    WScript.Echo "Insufficient privileges detected!"
+    If (gForceAdmin) Then
+        WScript.Echo "Installation will be allowed to continue. However, if the script"
+        WScript.Echo "encounters errors, please make sure it is run from an administrator acccount."
+    Else
+        WScript.Echo "Please run this script as an Administrator user."
+        WScript.Echo "Or, right-click the Command Prompt icon and 'Run as Administrator'."
+        WScript.Echo "If you wish to continue anyway, run the script with the '--forceAdmin true' argument."
+        WScript.Quit
+    End If
+End If
+
+' Detect Config
+'********************************************************
+WScript.Echo "Testing configuration..."
+gIntIP = GetIPAddress()
+
+If (gDomain = "") Then
+	If (gForceNetBios) = "" Then
+		gDomain = GetComputerDomainName() ' This is actually NetBIOS name
+	Else
+		gDomain = gForceNetBios
+	End If
+End If
+
+gDomainFull = GetComputerFullDomainName()
+gServerLabel = GetComputerHostName()
+gDomainFullyQualifiedDomain = GetDomainFullName()
+WScript.Echo  "Full Computer Domain : " & gDomainFullyQualifiedDomain
+
+'The following if block is to check if CollectArgs has set a value for gAccountName with the --username parameter, else set to default - Cisco_Connector
+If gAccountName = "" Then
+    gAccountName = ACCOUNT_NAME
+End If
+
+
+If (gForceRegister) Then
+   WScript.Echo "Forcing Register"
+   If gOauthAuthentication="0" Then   
+      SendAssetRegister()
+      SendAssetUpdate()
+   ElseIf gOauthAuthentication="1" Then
+      SendForAuthToken()
+      SendAssetRegisterEnhancedAuth()
+      SendForAuthToken()
+      SendAssetUpdateEnhancedAuth()         
+   Else
+      WScript.Echo("Register failure. Unauthorized, missing mandatory credentials.")
+   End If
+   WScript.Echo "Exiting before configuration!"
+   WScript.Quit
+End If
+
+TestRemoteAdmin()
+TestADUser()
+If (gADUserExists And (gAccountSID <> "")) Then
+   ' Tests that require an AD user already configured
+   TestRDC()
+   TestELR()
+   TestManageELPolicy()
+Else
+   'WScript.Echo "Skipping tests that require an AD User..."
+End If
+
+' Alert admin to state, ask if he wants auto config
+WScript.Echo ""
+WScript.Echo "***********************************************"
+WScript.Echo "Local Platform Configuration"
+WScript.Echo ""
+WScript.Echo "Local OS: " & OSToString(gOS)
+WScript.Echo "Functional Level: " & FLToString(gFunctionalLevel)
+WScript.Echo "Local IP: " & gIntIP
+WScript.Echo "Domain:   " & gDomainFull & " (" & gDomain & ")"
+WScript.Echo "Label:    " & gServerLabel
+If (gFWChecked) Then 
+   WScript.Echo "Firewall Enabled: " & gFWEnabled
+   WScript.Echo ""
+   WScript.Echo "Remote Admin Enabled: " & gFWRemoteAdmin
+Else
+   WScript.Echo "Firewall Enabled: unknown" 
+   WScript.Echo ""
+   WScript.Echo "Remote Admin Enabled: unknown"
+End If
+
+If (((gOS = 2) Or (gOS = 3) Or (gOS = 6) Or (gOS = 7) or (gOS = 8) or (gOS = 9) or (gOS = 10)) And (gFunctionalLevel >= 3)) Then
+   ' Windows Server 2008, 2012 and 2016 (functional level) can be fully configured
+   ' Event Log Reader membership only exists in 2008+
+   WScript.Echo "AD User Exists: " & gADUserExists
+   WScript.Echo "RDC Permissions Set: " & gRDCPermissions
+   If (gForceNonVA = False) Then
+        WScript.Echo ""
+        WScript.Echo "Manage Event Log Policy Set: " & gManageELPSet
+        WScript.Echo ""
+        WScript.Echo "Event Log Readers MemberOf: " & gELRMember
+   End If
+   WScript.Echo "***********************************************"
+   WScript.Echo ""
+
+   ' Outcome
+   ' If we're already configured in full, we don't need to do anything
+   If (IsConfiguredInFull()) Then
+      WScript.Echo "Domain Controller is fully configured!"
+        AutoRegisterDC()
+   ElseIf (gADUserExists = False) Then
+      WScript.Echo "Could not find user " & gAccountName & " in domain " + gDomain + _
+          ".  Please create one, or use the --forceDomain DOMAIN or --forceUserExists true command line argument."
+   Else
+      WScript.Echo "Your platform is supported for auto-configure."
+
+      ' Decide if they want to auto config
+      decision = UserInput("Do you want us to auto configure this Domain Controller (y or n)?")
+      
+      If InStr(decision,"y")=1 Then
+         If (DoAutoConfig2008()) Then
+            ' Radio home results
+            AutoRegisterDC()
+         End If
+
+      ElseIf InStr(decision,"n")=1 Then
+         WScript.Echo ""
+         WScript.Echo ""
+         WScript.Echo "INFO:"
+         WScript.Echo "*-----------------------------------------------------------"
+         WScript.Echo "Use the settings table above to decide if you will need to "
+         WScript.Echo "manually configure your Domain Controller."
+         WScript.Echo "Check the documentation for further details."
+         WScript.Echo "*-----------------------------------------------------------"
+      Else
+         WScript.Echo "Didn't understand input, please re-run to configure"
+      End If
+   End If
+ElseIf ((gOS = 1) Or (gOS = 2) Or (gOS = 3) Or (gOS = 6) Or (gOS = 7) or (gOS = 8) or (gOS = 9) or (gOS = 10)) Then
+   ' Windows Server 2003 functional levels (on any OS)
+   ' Can't QUITE be fully configured; WMI must be done manually
+   WScript.Echo "AD User Exists: " & gADUserExists
+   WScript.Echo "RDC Permissions Set: " & gRDCPermissions
+   If (gForceNonVA = False) Then
+        WScript.Echo ""
+        WScript.Echo "Manage Event Log Policy Set: " & gManageELPSet
+        WScript.Echo ""
+   End If
+   WScript.Echo "***********************************************"
+   WScript.Echo ""
+
+   ' Outcome
+   ' If we're already configured in full, we don't need to do anything
+   If (IsConfiguredInFull()) Then
+     ' Radio home results
+      WScript.Echo "Domain Controller is fully configured!"
+        AutoRegisterDC()
+   ElseIf (gADUserExists = false) Then
+      WScript.Echo "Could not find user " & gAccountName & "  in domain " + gDomain
+      WScript.Echo "Please create one, or add the expected domain as a command line argument."
+      WScript.Echo "If you are sure this message is in error, you can use --forceUserExists true to force the script to continue."
+   Else
+      WScript.Echo "Your platform is supported for auto-configure."
+
+      ' Decide if they want to auto config
+      decision = UserInput("Do you want us to auto configure this Domain Controller (y or n)?")
+      
+      If InStr(decision,"y")=1 Then
+         If (DoAutoConfig2003()) Then
+            ' Radio home results
+            AutoRegisterDC()
+         End If
+
+      ElseIf InStr(decision,"n")=1 Then
+         WScript.Echo ""
+         WScript.Echo ""
+         WScript.Echo "INFO:"
+         WScript.Echo "*-----------------------------------------------------------"
+         WScript.Echo "Use the settings table above to decide if you will need to "
+         WScript.Echo "manually configure your Domain Controller."
+         WScript.Echo "Check the documentation for further details."
+         WScript.Echo "*-----------------------------------------------------------"
+      Else
+         WScript.Echo "Didn't understand input, please re-run to configure"
+      End If
+   End If
+Else
+   WScript.Echo ""
+   WScript.Echo "CONFIG FAILED - Reason: Your platform is not supported"
+   WScript.Echo "Please choose a Domain Controller running at least Windows Server 2003"
+End If
+
+'*************************************************************************************************************
+' END MAIN
+'*************************************************************************************************************
+
+
+' FUNCTIONS
+'*************************************************************************************************************
+
+' Auto Config Functions
+'*****************************
+Function DoAutoConfig2008()
+   WScript.Echo ""
+   WScript.Echo "Configuring system..."
+   
+   ' Configure the firewall, if necessary (Just always run, if firewall is off, doesn't hurt)
+   
+   If (gForceNonVA = False) Then
+      WScript.Echo "Setting Remote Admin permissions on firewall..."
+      SetRemoteAdmin()
+      SetRemoteEventLog()
+      TestRemoteAdmin()
+   End If
+   
+   ' Set other permissions, if necessary and able
+   If (gADUserExists And (gAccountSID <> "")) Then
+      ' Set RDC permissions, if necessary
+      If (gRDCPermissions = False) Then
+         WScript.Echo "Setting RDC permissions..."
+         SetRDC()
+         TestRDC()
+      End If
+
+      ' Add to Event Log Reader group, if necessary
+      If (gELRMember = False) Then
+      	 ' Check if Non VA mode is NOT set
+            WScript.Echo "Adding to Event Log Readers group..."
+            SetELR()
+            TestELR()
+      End If
+      
+      ' The Event Log policy is not required for 2008
+
+   End If
+   
+   If (IsConfiguredInFull()) Then
+      WScript.Echo "Auto Configuration complete in full!"
+      DoAutoConfig2008 = True
+   Else
+      WScript.Echo "Auto Configuration incomplete!"
+      WScript.Echo "You may re-run this script to verify settings."
+      DoAutoConfig2008 = False
+   End If
+End Function
+
+' Version specific 2003
+Function DoAutoConfig2003()
+   Dim override
+   WScript.Echo ""
+   WScript.Echo "Configuring system..."
+   
+   ' Configure the firewall, if necessary (Just always run, if firewall is off, doesn't hurt)
+   
+   If (gForceNonVA = False) Then
+      WScript.Echo "Setting Remote Admin permissions on firewall..."
+      SetRemoteAdmin()
+      SetRemoteEventLog()
+      TestRemoteAdmin()
+   End If
+   
+   ' Set other permissions, if necessary and able
+   If (gADUserExists And (gAccountSID <> "")) Then
+      ' Set RDC permissions, if necessary
+      If (gRDCPermissions = False) Then
+         WScript.Echo "Setting RDC permissions..."
+         SetRDC()
+         TestRDC()
+      End If
+
+      ' There is no Event Log Readers group in 2003, so don't check that
+      
+      ' This policy SHOULD be set for 2003, but consider it just a warning
+      If (gManageELPSet = False) Then
+          WScript.Echo ""
+          WScript.Echo "ERROR: "
+          WScript.Echo "*------------------------------------------------------------------------------"
+          WScript.Echo "You must edit the following Group Policy and apply it to all 2003 DCs: "
+          WScript.Echo ""
+          WScript.Echo "  Computer Configuration\Policies\Windows Settings\Security Settings\"
+          WScript.Echo "    Local Policies\User Rights Assignment\Manage auditing and security log"
+          WScript.Echo ""
+          WScript.Echo "You must add the " & gAccountName & " user to the setting and gpupdate!"
+          WScript.Echo "*------------------------------------------------------------------------------"
+          WScript.Echo ""
+      End If
+   End If
+   
+   If (IsConfiguredInFull()) Then
+      WScript.Echo "Auto Config complete in full!"
+      DoAutoConfig2003 = True
+   Else
+      WScript.Echo ""
+      override = UserInput("Do you want to force register anyway (y or n)?")
+      If InStr(override,"y")=1 Then
+         DoAutoConfig2003 = True
+      ElseIf InStr(override,"n")=1 Then
+         WScript.Echo ""
+         WScript.Echo "Auto Config incomplete!"
+         WScript.Echo "You will need to manually set WMI permissions and correct any errors."
+         WScript.Echo "Then you may re-run this script and force register."
+         DoAutoConfig2003 = False
+      Else
+         WScript.Echo "Didn't understand input, please re-run to configure"
+      End If
+   End If
+End Function
+
+' OS Test Function
+'*****************************
+Sub TestOS()
+   Dim strComputer
+   Dim colItems
+   Dim strOS, objItem, lastBoot
+   Dim lastBootDate
+
+   strComputer = "."
+
+   Set colItems = gObjSvc.ExecQuery("SELECT * FROM Win32_OperatingSystem",,48)
+
+   For Each objItem in colItems     
+      strOS = objItem.Caption    
+      gSP = objItem.ServicePackMajorVersion
+      gR2 = objItem.OtherTypeDescription
+      lastBoot = objItem.LastBootUpTime
+      Wscript.Echo "The System OS received from system  : " & strOS
+      Wscript.Echo "The OS version received from system : " & objItem.Version
+   Next
+   
+   If InStr(strOS,"2003")<>0 Then
+      gOS = 1 ' OS is 2003 of some flavor
+   ElseIf InStr(strOS,"2008")<>0 Then
+      gOS = 2 ' OS is 2008 of some flavor
+   ElseIf InStr(strOS,"2011")<>0 Then
+      gOS = 2 ' OS is SBS 2011, mark it as 2008
+   ElseIf InStr(strOS,"2012")<>0 Then
+      gOS = 3 ' OS is 2012 of some flavor
+   ElseIf InStr(strOS,"7")<>0 Then
+      gOS = 4 ' OS is Win 7
+   ElseIf InStr(strOS,"2016")<>0 Then
+      gOS = 6 ' OS is 2016 of some flavor
+   ElseIf InStr(strOS,"2019")<>0 Then
+      gOS = 7 ' OS is 2019 of some flavor
+   ElseIf InStr(strOS, "Microsoft Windows Server Standard")<>0 Then
+      gOS = 8 ' OS is Server Standard
+   ElseIf InStr(strOS, "Microsoft Windows Server Datacenter")<>0 Then
+      gOS = 9 ' OS is 2019 of some flavor
+   ElseIf InStr(strOS, "2022")<>0 Then
+      gOS = 9 ' OS is 2022 of some flavor
+   Else
+      WScript.Echo "OS reported as " & strOS
+      gOS = 5 ' OS is some other thing we don't support
+   End If
+
+   ' Check forest functional level
+   GetFunctionalLevel()
+   
+   ' Calculate the uptime (in seconds)
+   lastBootDate = WMIDateStringToDate(lastBoot)   
+   gUptime = DateDiff("s", lastBootDate, Now)
+End Sub
+
+Sub GetFunctionalLevel()
+    On Error Resume Next
+
+    Dim objRootDSE, objPartitions
+    Dim strFFL
+
+    If (gForceFL) Then
+       Exit Sub
+    End If
+    
+
+    Set objRootDSE = GetObject("LDAP://RootDSE")
+    If (Err.Number <> 0) Then
+       WScript.Echo "Could not determine Domain Functional Level!"
+       WScript.Echo "Please try the --forceFL [2003|2008|2012|2016] flag."
+       Err.Clear
+       Exit Sub
+    End If
+
+    Set objPartitions = GetObject("LDAP://CN=Partitions," & objRootDSE.Get("configurationNamingContext"))
+    If (Err.Number <> 0) Then
+       WScript.Echo "Could not determine Domain Functional Level!"
+       WScript.Echo "Please try the --forceFL [2003|2008|2012|2016] flag."
+       Err.Clear
+       Exit Sub
+    End If
+
+    strFFL = objPartitions.Get("msDS-Behavior-Version")
+    If (Err.Number <> 0) Then
+       WScript.Echo "Could not determine Domain Functional Level!"
+       WScript.Echo "Please try the --forceFL [2003|2008|2012|2016] flag."
+       Err.Clear
+       Exit Sub
+    End If
+    'Wscript.Echo "Forest Functional level: " & strFFL
+
+    If strFFL = 0 Then
+        Wscript.Echo "This is a mixed-level forest."
+    ElseIf strFFL = 1 Then
+        Wscript.Echo "This is a Windows Server 2003 interim-level forest."
+    ElseIf strFFL = 2 Then
+        Wscript.Echo "This is a Windows Server 2003 forest."
+    ElseIf strFFL = 3 Then
+        Wscript.Echo "This is a Windows Server 2008 forest."
+    ElseIf strFFL = 4 Then
+        Wscript.Echo "This is a Windows Server 2008R2 forest."
+    ElseIf strFFL = 5 Then
+        Wscript.Echo "This is a Windows Server 2012 forest."
+    ElseIf strFFL = 6 Then
+        Wscript.Echo "This is a Windows Server 2012R2 forest."
+    ElseIf strFFL = 7 Then
+        Wscript.Echo "This is a Windows Server 2016 forest."
+    Else
+        Wscript.Echo "This is an unknown forest."
+    End If
+
+    gFunctionalLevel = strFFL
+
+End Sub
+
+' Firewall Settings Functions
+'*****************************
+
+' Test firewall settings
+Sub TestRemoteAdmin()
+   On Error Resume Next
+   Dim objFirewall, objPolicy
+   Dim objAdminSettings
+
+   Set objFirewall = CreateObject("HNetCfg.FwMgr")
+   Set objPolicy = objFirewall.LocalPolicy.CurrentProfile
+   gFWEnabled = objPolicy.FirewallEnabled
+
+   Set objAdminSettings = objPolicy.RemoteAdminSettings
+   gFWRemoteAdmin = objAdminSettings.Enabled
+   If Err.Number <> 0 Then
+      WScript.Echo "Could not check firewall settings!"
+      WScript.Echo "If the Windows Firewall/ICS service is disabled, this is normal."
+      gFWChecked = false
+      Err.Clear
+   End If
+End Sub
+
+' Sets firewall based on OS
+' Must run TestOS() first, as this function depends on gOS
+' Doesn't actually set the firewall, just pokes the hole for RemoteAdmin
+Sub SetRemoteAdmin()
+   On Error Resume Next
+   Dim WshShell
+   Dim objFirewall, objPolicy, objAdminSettings
+
+   If ((gOS = 1) And (gSP > 0)) Then
+      ' Win 2003 SP1+ command
+      ' Without SP1, there is no "netsh firewall"... 
+      '   just an ICF (Internet Connection Firewall)
+
+      Set WshShell = WScript.CreateObject("WScript.Shell")
+      WshShell.Run "netsh firewall set service type = remoteadmin mode = enable"
+   ElseIf ((gOS = 2) Or (gOS = 3) Or (gOS = 6) Or (gOS = 7) Or (gOS = 8) Or (gOS = 9) or (gOS = 10)) Then
+      ' Enable Remote Administration (FIREWALL)
+      Set objFirewall = CreateObject("HNetCfg.FwMgr")
+      If Err.Number <> 0 Then
+         WScript.Echo 
+         WScript.Echo "Error setting RemoteAdmin!  If Windows Firewall service is disabled, " 
+         WScript.Echo "   run this script with the '--forceFirewall true' argument."
+         WScript.Echo 
+      Else
+         Set objPolicy = objFirewall.LocalPolicy.CurrentProfile
+         Set objAdminSettings = objPolicy.RemoteAdminSettings
+         objAdminSettings.Enabled = True   
+      End If
+   End If
+End Sub
+
+' This function to enable the Remote Event Log Management firewall rule for reading Logon events from Event Viewer directly
+Sub SetRemoteEventLog()
+	Dim WshShell
+
+	WScript.Echo "Enabling Remote Event Log Management firewall rule"
+    Set WshShell = WScript.CreateObject("WScript.Shell")
+    WshShell.Run "netsh advfirewall firewall set rule group=""Remote Event Log Management"" new enable=yes"
+End Sub
+
+' AD User Functions
+'*****************************
+
+' Check to see if the desired AD user exists at all
+' Also sets the gAccountSID global to that user's SID
+Sub TestADUser()
+   On Error Resume Next 
+   Dim objAccount
+   
+   gADUserExists = False
+   
+   ' Get the SID for the given user
+   Set objAccount = gObjSvc.Get("Win32_UserAccount.Name='" & gAccountName & "',Domain='" & gDomain & "'")
+   If Err.Number <> 0 Then
+      WScript.Echo "Could not find user " & gDomain & "\" & gAccountName
+      gAccountSID = ""
+      gADUserExists = False
+      Err.Clear
+   Else
+      gAccountSID = objAccount.SID
+      gADUserExists = True
+   End If
+End Sub
+
+' RDC Functions
+'*****************************
+
+' Checks the Replicating Directory Changes permission on the account name (gAccountName)
+' Depends on TestADUser passing and setting gDomain and gAccountSID properly
+Sub TestRDC
+    Dim objRootLDAP, strPathToDomain, objDomain, objDescriptor
+    Dim objACE
+
+    Set objRootLDAP = GetObject("LDAP://rootDSE")
+    strPathToDomain = "LDAP://" & objRootLDAP.Get("defaultNamingContext") ' e.g. string dc=mydomain,dc=com
+    Set objDomain = GetObject(strPathToDomain)
+    Set objDescriptor = objDomain.Get("ntSecurityDescriptor")
+
+    For Each objACE In objDescriptor.DiscretionaryAcl
+        ' Get ACE entries, looking for account name (gAccountName)
+        If (lcase(objACE.Trustee) = lcase(gDomain & "\" & gAccountName)) Then
+            ' We found the right user, now make sure it's active and has the right permissions
+            If ((objACE.AceType = ADS_ACETYPE_ACCESS_ALLOWED_OBJECT) And _
+                (objACE.Flags = ADS_FLAG_OBJECT_TYPE_PRESENT) And _
+                (objACE.AccessMask = ADS_RIGHT_DS_CONTROL_ACCESS) And _
+                (objACE.ObjectType = SCHEMA_GUID_MS_REPLICATION_GET_CHANGES)) _
+            Then
+                ' Everything checks out
+                gRDCPermissions = True
+                WScript.Echo "RDC Permissions Set: " & gRDCPermissions
+
+                'WScript.Echo "Trustee: " & objACE.Trustee
+                'WScript.Echo "      AceFlags  : " & objACE.AceFlags
+                'WScript.Echo "      AceType   : " & objACE.AceType
+                'WScript.Echo "      Flags     : " & objACE.Flags
+                'WScript.Echo "      ObjectType: " & objACE.objectType
+                'WScript.Echo "      AccessMask: " & objACE.AccessMask
+            
+                ' DS Control Access right.
+                ' Grants the ability to to perform an operation restricted by an
+                ' extended access right. Must specify a rights GUID identifying a
+                ' controlAccessRight object in the Extended-Rights container in the
+                ' configuration partition.
+                'If ((objACE.AccessMask And ADS_RIGHT_DS_CONTROL_ACCESS) <> 0) Then
+                '    Call ListRights(objACE, "ADS_RIGHT_DS_CONTROL_ACCESS")
+                'End If
+             End If
+        Else
+            'WScript.Echo "Skipping " + objACE.Trustee            
+        End If
+    Next
+End Sub
+
+' Sets the Replicating Directory Changes permission on gAccountName (the account name)
+' Depends on TestADUser passing and setting gDomain and gAccountSID properly
+Sub SetRDC
+    Dim objRootLDAP, strPathToDomain, objDomain, objDescriptor
+    Dim objNewAce
+
+    Set objRootLDAP = GetObject("LDAP://rootDSE")
+    strPathToDomain = "LDAP://" & objRootLDAP.Get("defaultNamingContext") ' e.g. string dc=mydomain,dc=com
+    Set objDomain = GetObject(strPathToDomain)
+    Set objDescriptor = objDomain.Get("ntSecurityDescriptor")
+
+    ' Create the new ACE with proper permissions
+
+    Set objNewAce = createObject("AccessControlEntry")
+    objNewAce.AceFlags = 0
+    objNewAce.AceType = ADS_ACETYPE_ACCESS_ALLOWED_OBJECT
+    objNewAce.Flags = ADS_FLAG_OBJECT_TYPE_PRESENT
+    objNewAce.Trustee = gAccountSID
+    objNewAce.AccessMask = ADS_RIGHT_DS_CONTROL_ACCESS 
+    objNewAce.ObjectType = SCHEMA_GUID_MS_REPLICATION_GET_CHANGES
+    objNewAce.InheritedObjectType = SCHEMA_GUID_MS_REPLICATION_GET_CHANGES
+
+    ' Add the new ACE to the DACL
+    objDescriptor.DiscretionaryAcl.AddAce objNewAce
+    objDomain.Put "ntSecurityDescriptor", Array(objDescriptor)
+    objDomain.SetInfo
+End Sub
+
+' ELR Functions
+'*****************************
+
+' Checks that account (gAccountName) is a member of the "Event Log Readers" group
+' Depends on TestADUser passing and setting gAccountSID properly
+Sub TestELR
+    On Error Resume Next
+    Dim objELR
+    Dim objUser, memberGroup
+
+   ' Get our Event Log Readers group
+    Set objELR = GetObject("LDAP://" & gDomainFull & "/<sid=" & ELR_SID & ">")
+	If (objELR.DistinguishedName = "") Then
+	    Set objELR = GetObject("LDAP://CN=Event Log Readers,CN=Builtin," & gDomainFullyQualifiedDomain)
+	    If (objELR.DistinguishedName = "") Then
+	        Set objELR = GetObject("LDAP://<sid=" & ELR_SID & ">")
+		End If
+	End If
+	
+    If (Err.Number <> 0) Then
+        ' Server 2003 likely doesn't have an Event Log Readers group, so don't complain
+        If (gFunctionalLevel >= 3) Then
+            WScript.Echo "Could not find Event Log Readers group"
+        End If
+        
+        Err.Clear
+        Exit Sub
+    End If
+    
+    WScript.Echo  "ELR Group Domain : " & objELR.DistinguishedName
+
+    ' Get all groups that gAccountSID belongs to
+    Set objUser = GetObject("LDAP://" & gDomainFull & "/<sid=" & gAccountSID & ">")
+    For Each memberGroup in objUser.Groups
+        ' Find a group with the same DN as ELR; this is easier than checking SIDs
+        WScript.Echo  gAccountName & " member of Group DN : " & memberGroup.DistinguishedName
+        If (memberGroup.DistinguishedName = objELR.DistinguishedName) Then
+            gELRMember = True
+        End If
+    Next
+End Sub
+
+' Adds the account (gAccountName) to the Event Log Readers group
+' Depends on TestADUser passing and setting gAccountSID properly
+Sub SetELR
+    Dim objELR
+    Dim objUser
+
+    ' Get our Event Log Readers group
+    Set objELR = GetObject("LDAP://" & gDomainFull & "/<sid=" & ELR_SID & ">")
+	If (objELR.DistinguishedName = "") Then
+	    Set objELR = GetObject("LDAP://CN=Event Log Readers,CN=Builtin," & gDomainFullyQualifiedDomain)
+	    If (objELR.DistinguishedName = "") Then
+	        Set objELR = GetObject("LDAP://<sid=" & ELR_SID & ">")
+		End If
+	End If
+    WScript.Echo  "ELR Group Domain : " & objELR.DistinguishedName
+    ' Get our account (gAccountName) user
+    Set objUser = GetObject("LDAP://<sid=" & gAccountSID & ">")
+
+    ' Add our user to the ELR group
+    objELR.Add(objUser.AdsPath)
+End Sub
+
+' Policy Functions
+'*****************************
+
+' Checks Computer Configuration\Policies\Windows Settings\Security Settings\Local Policies\User Rights Assignment\Manage audit and security log
+' Depends on TestADUser passing and setting gDomain properly
+Sub TestManageELPolicy
+    Dim objWMIService, strComputer
+    Dim objItem, colItems, strAccountList
+
+    ' Since this should be running on a DC, let's just assume if RSOP allows it here it will be allowed everywhere
+    strComputer = "."
+    Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\rsop\computer")
+
+    Set colItems = objWMIService.ExecQuery("Select * from RSOP_UserPrivilegeRight")
+    For Each objItem in colItems
+        If (objItem.UserRight = "SeSecurityPrivilege") Then
+            ' Make sure the account (gAccountName) appears in this list
+            For Each strAccountList in objItem.AccountList
+                If (lcase(strAccountList) = lcase(gDomain & "\" & gAccountName)) Then
+                    gManageELPSet = true
+                End If
+            Next
+        End If
+    Next
+End Sub
+
+' Human readable string for OS
+'*****************************
+Function OSToString(OS)
+
+Dim strOS 
+
+If OS = 1 Then
+   strOS = "Windows 2003"
+ElseIf OS = 2 Then
+   strOS = "Windows Server 2008"
+ElseIf OS = 3 Then
+   strOS = "Windows Server 2012"
+ElseIf OS = 4 Then
+   strOS = "Win 7"
+ElseIf OS = 6 Then
+   strOS = "Windows Server 2016"
+ElseIf OS = 7 Then
+   strOS = "Windows Server 2019"
+ElseIf OS = 8 Then
+   strOS = "Microsoft Windows Server Standard"
+ElseIf OS = 9 Then
+   strOS = "Microsoft Windows Server Datacenter"
+ElseIf OS = 10 Then
+   strOS = "Windows Server 2022"
+Else
+   strOS = "Unsupported OS"
+End If
+
+If gR2 <> "" Then
+strOS = strOS & " " & gR2
+End If
+
+If gSP <> 0 Then
+strOS = strOS & " Service Pack " & gSP
+End If
+
+OSToString = strOS
+
+End Function
+
+Function FLToString(FL)
+
+    Dim strFL
+
+    If FL = 0 Then
+        strFL = "Server 2000 Forest"
+    ElseIf FL = 1 Then
+        strFL = "Server 2003 interim-level Forest"
+    ElseIf FL = 2 Then
+        strFL = "Server 2003 Forest"
+    ElseIf FL = 3 Then
+        strFL = "Server 2008 Forest"
+    ElseIf FL = 4 Then
+        strFL = "Server 2008 R2 Forest"
+    ElseIf FL = 5 Then
+        strFL = "Server 2012 Forest"
+    ElseIf FL = 6 Then
+        strFL = "Server 2012 R2 Forest"
+    ElseIf FL = 7 Then
+        strFL = "Server 2016 Forest"
+    Else
+        strFL = "unknown forest"
+    End If
+
+    FLToString = strFL
+
+End Function
+
+
+' Input Function
+'*****************************
+Function UserInput( myPrompt )
+
+WScript.StdOut.Write myPrompt & " "
+UserInput = WScript.StdIn.ReadLine
+
+End Function
+
+Sub AutoRegisterDC()
+    WScript.Echo ""
+    regdec = UserInput("Would you like to register this Domain Controller (y or n)?")
+    If InStr(regdec,"y")=1 Then
+         ' Radio home results
+         If gOauthAuthentication="0" Then   
+            SendAssetRegister()
+            SendAssetUpdate()
+         ElseIf gOauthAuthentication="1" Then
+            SendForAuthToken()
+            SendAssetRegisterEnhancedAuth()
+            SendForAuthToken()
+            SendAssetUpdateEnhancedAuth()         
+         Else
+            WScript.Echo("Register failure. Unauthorized, missing mandatory credentials.")
+         End If
+    End If
+End Sub
+
+' Transport Functions
+'*****************************
+Sub SendAssetRegister()
+
+   Dim url
+   Dim objHTTP
+   Dim data
+
+   WScript.Echo("Registering Domain Controller in cloud...")
+
+   url = gCloudEndpoint + "OnPremAsset.register"
+
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+   
+   Call objHTTP.Open("POST", url, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/x-www-form-urlencoded"
+   
+   data = "api_key=298CF21F81C788EDA27E85C3E2E2C415" & _
+      "&type=" & gAssetType & "&org_id=" & gOrgID & _
+      "&ipaddress_internal=" & gIntIP & "&label=" & gServerLabel & _
+      "&org_token=" & gCustomerID_Token
+
+   On Error Resume Next
+   objHTTP.send(data)
+   
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error sending Domain Controller registration:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("Please verify that the Domain Controller can access the Cisco API ")
+      WScript.Echo("(" & gCloudEndpoint & ") at port 443!")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+
+   'WScript.Echo("Register Response (" & objHTTP.status & "): " & objHTTP.responseText
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Register Success!")
+      gToken = objHTTP.responseText
+   Else
+      WScript.Echo("Register failure, response (" & _
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+   
+End Sub
+
+Sub SendForAuthToken()
+   Dim tokenUrl
+   Dim objHTTP
+   Dim data
+   Dim responseJsonString
+   Dim accessTokenPos
+   Dim accessTokenEndPos
+
+   WScript.Echo("Fetching token...")
+
+   tokenUrl = gTokenEndpoint
+
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+
+   Call objHTTP.Open("GET", tokenUrl, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/json"
+   objHTTP.setRequestHeader "Authorization", "Basic " & EncodeBase64(gClientId & ":" & gClientSecret)
+
+   data = ""
+
+   On Error Resume Next
+   objHTTP.send(data)
+
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error fetching token:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("Please verify that API is accessible ")
+      WScript.Echo("(" & gTokenEndpoint & ") at port 443!")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+
+   'WScript.Echo("Auth token request response (" & objHTTP.status & "): " & objHTTP.responseText)
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Auth token fetched!")
+      responseJsonString = objHTTP.responseText
+      accessTokenPos = InStr(responseJsonString, """access_token""") + Len("""access_token"":")
+      accessTokenEndPos = InStr(accessTokenPos, responseJsonString, ",")
+      gAccessToken = replace(Mid(responseJsonString, accessTokenPos, accessTokenEndPos - accessTokenPos), chr(34), "")
+   Else
+      WScript.Echo("Register failure, response (" & _
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+
+End Sub
+
+Sub SendAssetRegisterEnhancedAuth()
+   Dim url
+   Dim objHTTP
+   Dim data
+   Dim responseJsonString
+   Dim assetidPos
+   Dim assetidEndPos
+
+   WScript.Echo("Registering Domain Controller in cloud...")
+   
+   url = gCloudEndpoint + "/onpremappliances"
+
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+   
+   Call objHTTP.Open("POST", url, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/json"
+   objHTTP.setRequestHeader "Authorization", "Bearer " & gAccessToken
+
+   data = _
+      "{ " & vbCrLf & _
+      "   ""type"": """ & gAssetType & """, " & vbCrLf & _
+      "   ""label"": """ & gServerLabel & """, " & vbCrLf & _
+      "   ""domains"": [""" & gDomainFull & """]," & vbCrLf & _
+      "   ""ipaddress_internal"": [""" & gIntIP & """]" & vbCrLf & _
+      "}"
+
+   On Error Resume Next
+   objHTTP.send(data)
+   
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error sending Domain Controller registration:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("Please verify that the Domain Controller can access the Cisco API ")
+      WScript.Echo("(" & gCloudEndpoint & ") at port 443!")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+
+   'WScript.Echo("Register Response (" & objHTTP.status & "): " & objHTTP.responseText
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Register Success!")
+      responseJsonString = objHTTP.responseText
+      assetidPos = InStr(responseJsonString, """asset_id""") + Len("""asset_id"":")
+      assetidEndPos = InStr(assetidPos, responseJsonString, ",")
+      gToken = Mid(responseJsonString, assetidPos, assetidEndPos - assetidPos)
+   Else
+      WScript.Echo("Register failure, response (" & _
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+
+End Sub
+
+Sub SendAssetUpdateEnhancedAuth()
+   Dim serverTime
+   Dim url
+   Dim objHTTP
+   Dim data
+
+   ' Don't attempt to register unless we have a good token (via a Register)
+   If (gToken = "") Then
+      WScript.Echo("Can't update DC status in the cloud without registering!")
+      Exit Sub
+   End If
+
+   WScript.Echo("Updating DC status in cloud...")
+   
+   serverTime = DateDiff("s", "01/01/1970 00:00:00", Now())
+   
+   url = gCloudEndpoint + "onpremappliances/" + gToken + "/syncs"
+   
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+   
+   Call objHTTP.Open("POST", url, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/json"
+   objHTTP.setRequestHeader "Authorization", "Bearer " & gAccessToken
+
+   data = _
+      "{ " & vbCrLf & _
+      "   ""AssetID"": """ & gToken & """, " & vbCrLf & _
+      "   ""ConfigVersion"": ""1""," & vbCrLf & _
+      "   ""Environment"": { " & vbCrLf & _
+      "      ""Domains"": [""" & gDomainFull & """]," & vbCrLf & _
+      "      ""InternalIPs"": [""" & gIntIP & """]," & vbCrLf & _
+      "      ""ServerTime"": """ & serverTime & """" & vbCrLf & _
+      "   }, " & vbCrLf & _
+      "   ""Status"": { " & vbCrLf & _
+      "      ""Uptime"": """ & gUptime & """ " & vbCrLf & _
+      "   } " & vbCrLf & _
+      "}"
+
+   On Error Resume Next
+   objHTTP.send(data)
+   
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error sending Update:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("If the registration was successful, this may be " & _ 
+         "a problem with the UpdateStatus API call")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+   
+   'WScript.Echo("Update Response (" & objHTTP.status & "): " & objHTTP.responseText
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Update success!")
+   Else
+      WScript.Echo("Update failure, response (" & _ 
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+   
+End Sub
+
+Sub SendAssetUpdate()
+   Dim serverTime
+   Dim url
+   Dim objHTTP
+   Dim data
+
+   ' Don't attempt to register unless we have a good token (via a Register)
+   If (gToken = "") Then
+      WScript.Echo("Can't update DC status in the cloud without registering!")
+      Exit Sub
+   End If
+
+   WScript.Echo("Updating DC status in cloud...")
+   
+   serverTime = DateDiff("s", "01/01/1970 00:00:00", Now())
+   
+   url = gCloudEndpoint + "OnPremAsset.sync"
+   
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+   
+   Call objHTTP.Open("POST", url, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/json"
+   objHTTP.setRequestHeader "X-OpenDNS-API-Key", "298CF21F81C788EDA27E85C3E2E2C415"
+   
+   data = _
+      "{ " & vbCrLf & _
+      "   ""AssetID"": """ & gToken & """, " & vbCrLf & _
+      "   ""Org_ID"": """ & gOrgID & """, " & vbCrLf & _
+      "   ""Org_Token"": """ & gCustomerID_Token & """, " & vbCrLf & _
+      "   ""ConfigVersion"": ""1""," & vbCrLf & _
+      "   ""Environment"": { " & vbCrLf & _
+      "      ""Domains"": [""" & gDomainFull & """]," & vbCrLf & _
+      "      ""InternalIP"": """ & gIntIP & """," & vbCrLf & _
+      "      ""ServerTime"": """ & serverTime & """" & vbCrLf & _
+      "   }, " & vbCrLf & _
+      "   ""Status"": { " & vbCrLf & _
+      "      ""Uptime"": """ & gUptime & """ " & vbCrLf & _
+      "   } " & vbCrLf & _
+      "}"
+
+   On Error Resume Next
+   objHTTP.send(data)
+   
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error sending Update:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("If the Register was successful, this may be " & _ 
+         "a problem with the UpdateStatus API call")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+   
+   'WScript.Echo("Update Response (" & objHTTP.status & "): " & objHTTP.responseText
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Update success!")
+   Else
+      WScript.Echo("Update failure, response (" & _ 
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+   
+End Sub
+
+'Function to Base64 encode a string
+Function EncodeBase64(inData)
+  Dim cOut, sOut, I
+  Dim nGroup, pOut, sGroup
+
+  Const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
+
+  'For each group of 3 bytes
+  For I = 1 To Len(inData) Step 3
+
+    'Create one long from this 3 bytes.
+    nGroup = &H10000 * Asc(Mid(inData, I, 1)) + _
+      &H100 * MyASC(Mid(inData, I + 1, 1)) + MyASC(Mid(inData, I + 2, 1))
+
+    'Oct splits the long To 8 groups with 3 bits
+    nGroup = Oct(nGroup)
+
+    'Add leading zeros
+    nGroup = String(8 - Len(nGroup), "0") & nGroup
+
+    'Convert To base64
+    pOut = Mid(Base64, CLng("&o" & Mid(nGroup, 1, 2)) + 1, 1) + _
+      Mid(Base64, CLng("&o" & Mid(nGroup, 3, 2)) + 1, 1) + _
+      Mid(Base64, CLng("&o" & Mid(nGroup, 5, 2)) + 1, 1) + _
+      Mid(Base64, CLng("&o" & Mid(nGroup, 7, 2)) + 1, 1)
+
+    'Add the part To OutPut string
+    sOut = sOut + pOut
+
+    'Add a new line For Each 76 chars In dest (76*3/4 = 57)
+    'If (I + 2) Mod 57 = 0 Then sOut = sOut + vbCrLf
+  Next
+  Select Case Len(inData) Mod 3
+    Case 1: '8 bit final
+      sOut = Left(sOut, Len(sOut) - 2) + "=="
+    Case 2: '16 bit final
+      sOut = Left(sOut, Len(sOut) - 1) + "="
+  End Select
+  EncodeBase64 = sOut
+End Function
+
+Function MyASC(OneChar)
+  If OneChar = "" Then MyASC = 0 Else MyASC = Asc(OneChar)
+End Function
+
+' Utility function to convert the WMI time format to the VBScript time format 
+Function WMIDateStringToDate(dtmBootup)
+   WMIDateStringToDate = CDate(Mid(dtmBootup, 5, 2) & "/" & _
+      Mid(dtmBootup, 7, 2) & "/" & Left(dtmBootup, 4) _
+      & " " & Mid (dtmBootup, 9, 2) & ":" & _
+      Mid(dtmBootup, 11, 2) & ":" & Mid(dtmBootup,13, 2))
+End Function
+
+
+Function GetIPAddress()
+
+Dim strComputer
+Dim objWMIService
+Dim IPConfigSet
+Dim IPConfig, i, out
+Dim notDone
+Dim IP, index
+
+strComputer = "."
+
+Set objWMIService = GetObject("winmgmts:" _
+    & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")
+
+Set IPConfigSet = objWMIService.ExecQuery _
+    ("Select * from Win32_NetworkAdapterConfiguration Where IPEnabled=TRUE")
+ 
+ReDim IPList(0)
+
+For Each IPConfig in IPConfigSet
+    If Not IsNull(IPConfig.IPAddress) Then 
+        For i=LBound(IPConfig.IPAddress) to UBound(IPConfig.IPAddress)
+            If Not IsNull(IPConfig.IPAddress(i)) Then
+                ' Strip out any IP addresses with : (no IPv6)
+                If Not (Instr(IPConfig.IPAddress(i), ":") > 0) Then
+                   out = IPConfig.IPAddress(i)
+                   IPList(UBound(IPList)) = out
+                   ReDim Preserve IPList(UBound(IPList) + 1)
+               End If
+            End If
+        Next
+    End If
+Next
+
+' Take off the empty one
+If Not UBound(IPList) = 0 Then
+    ReDim Preserve IPList(UBound(IPList) - 1)
+End If
+
+If UBound(IPList) = 0 Then
+    GetIPAddress = out
+    'WScript.Echo ""
+    'WScript.Echo "Detected IP: " & GetIPAddress
+Else
+
+notDone = true
+Do While notDone
+
+' Let user choose IP if more than one
+WScript.Echo ""
+WScript.Echo "Multiple IPs detected "
+
+index = 0
+For Each IP in IPList
+    index = index + 1   
+    WScript.Echo index & ") " & IP
+Next
+WScript.Echo ""
+
+notDone = false
+
+index = UserInput("Please enter the number of the IP you would like to use:")
+
+If Not IsNumeric(index) Then
+    WScript.Echo "Input was not a number - try again"
+    notDone = true
+Else
+    If CInt(index) > UBound(IPList)+1 Then
+        WScript.Echo "Invalid choice - choose again"
+        notDone = true
+    ElseIf (index = 0) Then
+        WScript.Echo "Invalid choice - choose again"
+        notDone = true
+    End If
+End If
+
+Loop
+ 
+GetIPAddress = IPList(index-1)
+
+WScript.Echo "You chose IP: " & GetIPAddress
+
+End If
+
+End Function
+
+' Get Domain Name
+Function GetDomainFullName()
+   Dim DomainFullyQualifiedDomainName
+   Dim DomainFullyQualifiedDomainNameArray
+   Dim DomainNameFECount
+   Dim item
+
+   DomainFullyQualifiedDomainNameArray = Split(gDomainFull,".")
+   DomainFullyQualifiedDomainName=""
+   DomainNameFECount=0
+
+   For each item in DomainFullyQualifiedDomainNameArray
+      If DomainNameFECount = 0 then
+          DomainFullyQualifiedDomainName = "DC=" + item
+      Else
+          DomainFullyQualifiedDomainName = DomainFullyQualifiedDomainName + ",DC=" + item
+      End If
+      DomainNameFECount = DomainNameFECount + 1
+   Next
+   GetDomainFullName = DomainFullyQualifiedDomainName
+End Function
+
+' Gets our domain
+Function GetComputerFullDomainName()
+   On Error Resume Next
+   Dim objItemSet, objItem
+   Set objItemSet = GetObject("winmgmts:\root\cimv2").ExecQuery("select * from Win32_ComputerSystem")
+   For Each objItem in objItemSet
+      GetComputerFullDomainName = lcase(objItem.Domain)
+   Next
+End Function
+
+' Gets our domain without the suffix
+Function GetComputerDomainName()
+   On Error Resume Next
+   Dim objItemSet, objItem, sysInfo
+	If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		Set objItemSet = GetObject("winmgmts:\root\cimv2").ExecQuery("select * from Win32_NTDomain")
+		For Each objItem in objItemSet
+			GetComputerDomainName = objItem.DomainName
+			' If there are multiple domains, just take the first and ignore the rest...
+		Exit For
+		Next
+	End If
+	If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		Set sysInfo = CreateObject("ADSystemInfo")
+		GetComputerDomainName = sysInfo.DomainShortName
+	End If
+	If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty)  then
+        Set WshNetwork = CreateObject("Wscript.Network")
+		GetComputerDomainName = WshNetwork.UserDomain
+   End If
+   If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		Set wshShell = CreateObject( "WScript.Shell" )
+		strNETBIOSName = wshShell.ExpandEnvironmentStrings( "%USERDOMAIN%" )
+		GetComputerDomainName = strNETBIOSName
+	End If
+	If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		Set objSysInfo = CreateObject( "WinNTSystemInfo" )
+		strDomainName = objSysInfo.DomainName
+		GetComputerDomainName = strDomainName
+	End If
+   If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		WScript.Echo "NetBIOS name for domain could not be found. Please re-run this script with parameter ""--forcenetbios <NetBIOS>"""
+		WScript.Echo "Example: cscript Cisco-WindowsConfigurationScript-********.wsf --forcenetbios <NetBIOS>"
+		WScript.Quit
+   End If
+End Function
+
+' Gets our hostname
+Function GetComputerHostName()
+   On Error Resume Next
+   Dim objItemSet, objItem
+   Set objItemSet = GetObject("winmgmts:\root\cimv2").ExecQuery("select * from Win32_ComputerSystem")
+   For Each objItem in objItemSet
+      GetComputerHostName = objItem.Name
+   Next
+End Function
+
+' Tells us whether we are properly configured or not
+Function IsConfiguredInFull()
+   IsConfiguredInFull = False
+   
+   ' Force user
+   If (gForceUserExists) Then
+      gADUserExists = True
+      gRDCPermissions = True
+      gELRMember = True
+   End If
+
+   ' Force firewall
+   If (gForceFW) Then
+      gFWRemoteAdmin = True
+   End If
+
+   If (gForceNonVA) Then
+        gELRMember = True
+        gManageELPSet = True
+        If (gADUserExists And gRDCPermissions And gELRMember) Then
+            IsConfiguredInFull = True
+         ElseIf (gFWRemoteAdmin And gADUserExists And gRDCPermissions And gELRMember) Then
+            IsConfiguredInFull = True
+         End If
+
+   End If
+
+   If (gFWRemoteAdmin And gADUserExists And gRDCPermissions And gELRMember) Then
+      IsConfiguredInFull = True
+   End If
+
+End Function
+
+Function IsAdmin
+    IsAdmin = 0
+    On Error Resume Next
+    Dim key
+    key = CreateObject("WScript.Shell").RegRead("HKEY_USERS\S-1-5-19\Environment\TEMP")
+    if Err.Number = 0 Then
+        IsAdmin = 1
+    End If
+    Err.Clear
+End Function
+
+Function CollectArgs
+
+Dim item, args, cur, count
+Set args = WScript.Arguments
+
+count = 0
+For Each item In args
+    If (lcase(item) = "--forceuserexists") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceUserExists = 1
+            Else
+                gForceUserExists = 0
+            End If
+            WScript.Echo "forceUser: " & gForceUserExists
+         End If
+    ElseIf (lcase(item) = "--forcefirewall") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceFW = 1
+            Else
+                gForceFW = 0
+            End If
+            WScript.Echo "forceFirewall: " & cur
+         End If
+    ElseIf (lcase(item) = "--forceadmin") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceAdmin = 1
+            Else
+                gForceAdmin = 0
+            End If
+            WScript.Echo "forceAdmin: " & cur
+         End If
+    ElseIf (lcase(item) = "--forcedomain") Then
+         If (args.length > (count+1)) Then
+            gDomain = args(count+1)
+            WScript.Echo "forceDomain: " & gDomain
+         End If
+    ElseIf (lcase(item) = "--forcefl") Then
+         If (args.length > (count+1)) Then
+            If (args(count+1) = "2003") Then
+                WScript.Echo "Forcing 2003 functional level"
+                gFunctionalLevel = 2
+                gForceFL = true
+            ElseIf (args(count+1) = "2008") Then
+                WScript.Echo "Forcing 2008 functional level"
+                gFunctionalLevel = 3
+                gForceFL = true
+            ElseIf (args(count+1) = "2012") Then
+                WScript.Echo "Forcing 2012 functional level"
+                gFunctionalLevel = 5
+                gForceFL = true
+            ElseIf (args(count+1) = "2016") Then
+                WScript.Echo "Forcing 2016 functional level"
+                gFunctionalLevel = 7
+                gForceFL = true
+            Else
+                WScript.Echo "Unknown functional level: " + args(count+1)
+                WScript.Echo "Please use --forceFl [2003|2008|2012|2016]"
+            End If
+        End If
+    ElseIf (lcase(item) = "--forceregister") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceRegister = 1
+            Else
+                gForceRegister = 0
+            End If
+            WScript.Echo "forceRegister: " & cur
+         End If
+    ElseIf (lcase(item) = "--forcenonva") Then
+        If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceNonVA = 1
+            Else
+                gForceNonVA = 0
+            End If
+            WScript.echo "Non VA Mode : " & gForceNonVA
+        End If
+	  ElseIf (lcase(item) = "--forcenetbios") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+			      gForceNetBios = Trim(cur)
+         End If
+    ElseIf (lcase(item) = "--username") Then
+        If (args.length > (count+1)) Then
+            cur = Trim(args(count+1))
+            If (cur<>"") Then
+                gAccountName = cur
+            Else
+                gAccountName = ACCOUNT_NAME
+            End If 
+            WScript.echo "Username (Account Name) : " & gAccountName
+        End If
+    Else
+        ' Unrecognized option
+    End If
+    count = count + 1
+Next
+
+End Function
+
+Sub ListRights(objACE_Item, strRight)
+    ' Subroutine to document rights to text file.
+    ' objReport is the output file object, with global scope.
+    If (objACE_Item.objectType = "") _
+            And (objACE_Item.InheritedObjectType = "") Then
+        WScript.Echo "  " & strRight
+    Else
+        If (objACE_Item.InheritedObjectType = "") Then
+            WScript.Echo "  " & strRight & " for SchemaIDGuid: " _
+                & objACE_Item.objectType
+        Else
+            WScript.Echo "  Inherited " & strRight _
+                & " for SchemaIDGuid: " & objACE_Item.InheritedObjectType
+        End If
+    End If
+End Sub
+
+</script>
+</job>
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/check.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/check.ps1
new file mode 100644
index 0000000..5dc124f
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/check.ps1	
@@ -0,0 +1,1235 @@
+<#
+.SYNOPSIS
+    Detects if Cisco Secure Client is installed on the system.
+
+.DESCRIPTION
+    This script performs multi-method detection for Cisco Secure Client installation:
+    - Marker file analysis (checks previous installation results)
+    - Registry detection (primary method)
+    - File system detection (secondary method)
+    - Service detection (tertiary method)
+    - Process detection (to avoid disruption during active sessions)
+    
+    For Intune Win32 app deployment:
+    - Exit 0 = Application is installed (detection successful)
+    - Exit 1 = Application is not installed (detection failed)
+    
+    Runtime tracking:
+    - Script includes runtime diagnostics in output
+    - Self-terminates after 5 minutes (well within Intune's 30-minute limit)
+    - Typical execution time: < 5 seconds
+
+.PARAMETER EnableDebug
+    Switch to enable detailed debug logging to console and file.
+    When enabled, creates detailed logs in C:\ProgramData\CiscoSecureClient\Logs\
+
+.PARAMETER DisableFileLogging
+    Switch to completely disable all file logging operations.
+    When enabled, only console output will be created.
+
+.NOTES
+    Version:        1.1
+    Creation Date:  2025-01-12
+    Purpose:        Intune Win32 App Detection Script
+    Compatibility:  PowerShell 5.1
+    Logging:        Uses comprehensive logging module with CSV export
+#>
+
+[CmdletBinding()]
+param (
+    [switch]$EnableDebug = $false,
+    [switch]$DisableFileLogging = $false
+)
+
+#region Script Configuration
+$MinimumVersion = "5.1.10.233"  # Minimum required version (based on installer package)
+$ApplicationName = "Cisco Secure Client"
+$script:DisableFileLogging = $DisableFileLogging  # Set script-level variable for logging module
+
+# # Import logging module
+# $LoggingModulePath = Join-Path $PSScriptRoot "logging\logging.psm1"
+# if (Test-Path $LoggingModulePath) {
+#     # Suppress module warnings to prevent STDOUT pollution for Intune
+#     Import-Module $LoggingModulePath -Force -WarningAction SilentlyContinue
+#     $LoggingMode = if ($EnableDebug) { 'EnableDebug' } else { 'SilentMode' }
+#     Write-AppDeploymentLog -Message "=== Cisco Secure Client Detection Script Started ===" -Level Information -Mode $LoggingMode
+#     Write-AppDeploymentLog -Message "Script Version: 1.1" -Level Information -Mode $LoggingMode
+#     Write-AppDeploymentLog -Message "EnableDebug: $EnableDebug, DisableFileLogging: $DisableFileLogging" -Level Information -Mode $LoggingMode
+# } else {
+#     # Fallback if logging module not found
+#     $LoggingMode = 'Off'
+#     if ($EnableDebug) {
+#         Write-Host "WARNING: Logging module not found at: $LoggingModulePath" -ForegroundColor Yellow
+#     }
+# }
+
+# Initialize LoggingMode since module import is commented out
+$LoggingMode = if ($EnableDebug) { 'EnableDebug' } else { 'SilentMode' }
+
+#region Logging Function
+
+
+function Write-AppDeploymentLog {
+    [CmdletBinding()]
+    Param (
+        [Parameter(Mandatory = $true)]
+        [string]$Message,
+        [Parameter()]
+        [ValidateSet('Information', 'Warning', 'Error', 'Debug')]
+        [string]$Level = 'Information',
+        [Parameter()]
+        [ValidateSet('EnableDebug', 'SilentMode', 'Off')]
+        [string]$Mode = 'Off'
+    )
+
+    # Determine logging mode - check EnableDebug first, then parameter, then default to Off
+    $loggingMode = if ($EnableDebug) { 
+        'EnableDebug' 
+    } elseif ($Mode -ne 'Off') { 
+        $Mode 
+    } else { 
+        'Off' 
+    }
+
+    # Exit early if logging is completely disabled
+    if ($loggingMode -eq 'Off') {
+        return
+    }
+
+    # Enhanced caller information using improved logic from Write-EnhancedLog
+    $callStack = Get-PSCallStack
+    
+    # Simplified and corrected function name detection logic
+    $callerFunction = '<Unknown>'
+    if ($callStack.Count -ge 2) {
+        $caller = $callStack[1]
+        
+        # Use the same simple approach as Write-EnhancedLog that works correctly
+        if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+            # This is a function name
+            $callerFunction = $caller.Command
+        } else {
+            # This is either main script execution or a script file name - use MainScript
+            $callerFunction = 'MainScript'
+        }
+    }
+    
+    # Get parent script name
+    $parentScriptName = try {
+        Get-ParentScriptName
+    } catch {
+        "UnknownScript"
+    }
+    
+    # Get line number and script name for detailed logging
+    $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+    $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+        Split-Path -Leaf $callStack[1].ScriptName 
+    } else { 
+        $parentScriptName 
+    }
+
+    # Create enhanced caller information combining both approaches
+    $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+    $detailedCallerInfo = "[$scriptFileName`:$lineNumber $callerFunction]"
+
+    $timeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $fileLogMessage = "[$timeStamp] [$Level] $enhancedCallerInfo - $Message"
+    $consoleLogMessage = "[$Level] $enhancedCallerInfo - $Message" # No timestamp for console
+
+    #region Local File Logging
+    # Skip all file logging if DisableFileLogging is set
+    if ($script:DisableFileLogging) {
+        return
+    }
+    
+    # Use session-based paths if available, otherwise fall back to per-call generation
+    if ($script:SessionLogFilePath -and $script:SessionFullLogDirectory) {
+        $logFilePath = $script:SessionLogFilePath
+        $logDirectory = $script:SessionFullLogDirectory
+    } else {
+        # Fallback to old method if session variables aren't set
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        $logDirectory = "C:\ProgramData\CiscoSecureClient\Logs"
+        $fullLogDirectory = Join-Path -Path $logDirectory -ChildPath $dateFolder
+        $fullLogDirectory = Join-Path -Path $fullLogDirectory -ChildPath $parentScriptName
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.log"
+        $logFilePath = Join-Path -Path $fullLogDirectory -ChildPath $logFileName
+        $logDirectory = $fullLogDirectory
+    }
+    
+    if (-not (Test-Path -Path $logDirectory)) {
+        New-Item -ItemType Directory -Path $logDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+    }
+    
+    if (Test-Path -Path $logDirectory) {
+        Add-Content -Path $logFilePath -Value $fileLogMessage -ErrorAction SilentlyContinue
+        
+        # Log rotation for local files (keep max 7 files)
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $logFiles = Get-ChildItem -Path $logDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.log" | Sort-Object LastWriteTime -Descending
+            if ($logFiles.Count -gt 7) {
+                $filesToRemove = $logFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for log rotation
+        }
+    }
+    #endregion Local File Logging
+
+    #region Network Share CSV Logging
+    # Network logging: Only save CSV format logs under a parent job folder for better organization
+    try {
+        $hostname = $env:COMPUTERNAME
+        $jobName = "CiscoSecureClient"  # Parent job folder name
+        $networkBasePath = "\\AZR1PSCCM02\.logs\$jobName\$hostname"
+        
+        # Test network connectivity first
+        $networkAvailable = Test-Path "\\AZR1PSCCM02\.logs" -ErrorAction SilentlyContinue
+        
+        if ($networkAvailable) {
+            # Use session-based paths if available
+            if ($script:SessionDateFolder -and $script:SessionParentScript -and $script:SessionCSVFileName) {
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $script:SessionDateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionParentScript
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionCSVFileName
+            } else {
+                # Fallback method
+                $dateFolder = Get-Date -Format "yyyy-MM-dd"
+                $parentScriptName = Get-ParentScriptName
+                $userContext = Get-CurrentUser
+                $callingScript = Get-CallingScriptName
+                $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+                
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $dateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $parentScriptName
+                $networkCSVFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $networkCSVFileName
+            }
+            
+            if (-not (Test-Path -Path $fullNetworkCSVPath)) {
+                New-Item -ItemType Directory -Path $fullNetworkCSVPath -Force -ErrorAction SilentlyContinue | Out-Null
+            }
+            
+            if (Test-Path -Path $fullNetworkCSVPath) {
+                # Create CSV entry for network logging
+                $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+                $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+                $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+                
+                # Get caller information
+                $callStack = Get-PSCallStack
+                $callerFunction = '<Unknown>'
+                if ($callStack.Count -ge 2) {
+                    $caller = $callStack[1]
+                    if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+                        $callerFunction = $caller.Command
+                    } else {
+                        $callerFunction = 'MainScript'
+                    }
+                }
+                
+                $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+                $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+                    Split-Path -Leaf $callStack[1].ScriptName 
+                } else { 
+                    $parentScriptName 
+                }
+                
+                $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+                
+                $networkCSVEntry = [PSCustomObject]@{
+                    Timestamp       = $timeStamp
+                    Level           = $Level
+                    ParentScript    = $parentScriptName
+                    CallingScript   = $callingScript
+                    ScriptName      = $scriptFileName
+                    FunctionName    = $callerFunction
+                    LineNumber      = $lineNumber
+                    Message         = $Message
+                    Hostname        = $env:COMPUTERNAME
+                    UserType        = $userContext.UserType
+                    UserName        = $userContext.UserName
+                    FullUserContext = $userContext.FullUserContext
+                    CallerInfo      = $enhancedCallerInfo
+                    JobName         = $jobName
+                    LogType         = "NetworkCSV"
+                }
+                
+                # Check if network CSV exists, if not create with headers
+                if (-not (Test-Path -Path $networkCSVFile)) {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -ErrorAction SilentlyContinue
+                } else {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -Append -ErrorAction SilentlyContinue
+                }
+                
+                # Network CSV log rotation (keep max 5 files per machine per script)
+                try {
+                    $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+                    $networkCSVFiles = Get-ChildItem -Path $fullNetworkCSVPath -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+                    if ($networkCSVFiles.Count -gt 5) {
+                        $filesToRemove = $networkCSVFiles | Select-Object -Skip 5
+                        foreach ($file in $filesToRemove) {
+                            Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                        }
+                    }
+                }
+                catch {
+                    # Silent error handling for network CSV log rotation
+                }
+            }
+        }
+    }
+    catch {
+        # Silent error handling for network CSV logging - don't interfere with main script
+    }
+    #endregion Network Share CSV Logging
+
+    #region CSV Logging
+    try {
+        # Use session-based paths if available
+        if ($script:SessionCSVFilePath -and $script:SessionFullCSVDirectory) {
+            $csvLogPath = $script:SessionCSVFilePath
+            $csvDirectory = $script:SessionFullCSVDirectory
+        } else {
+            # Fallback method
+            $userContext = Get-CurrentUser
+            $callingScript = Get-CallingScriptName
+            $parentScriptName = Get-ParentScriptName
+            $dateFolder = Get-Date -Format "yyyy-MM-dd"
+            $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+            
+            $csvLogDirectory = "C:\ProgramData\CiscoSecureClient\Logs\CSV"
+            $fullCSVDirectory = Join-Path -Path $csvLogDirectory -ChildPath $dateFolder
+            $fullCSVDirectory = Join-Path -Path $fullCSVDirectory -ChildPath $parentScriptName
+            $csvFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+            $csvLogPath = Join-Path -Path $fullCSVDirectory -ChildPath $csvFileName
+            $csvDirectory = $fullCSVDirectory
+        }
+        
+        if (-not (Test-Path -Path $csvDirectory)) {
+            New-Item -ItemType Directory -Path $csvDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+        }
+        
+        # Use session context if available, otherwise get fresh context
+        $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+        $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+        $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+        
+        $csvEntry = [PSCustomObject]@{
+            Timestamp       = $timeStamp
+            Level           = $Level
+            ParentScript    = $parentScriptName
+            CallingScript   = $callingScript
+            ScriptName      = $scriptFileName
+            FunctionName    = $callerFunction
+            LineNumber      = $lineNumber
+            Message         = $Message
+            Hostname        = $env:COMPUTERNAME
+            UserType        = $userContext.UserType
+            UserName        = $userContext.UserName
+            FullUserContext = $userContext.FullUserContext
+            CallerInfo      = $enhancedCallerInfo
+        }
+        
+        # Check if CSV exists, if not create with headers
+        if (-not (Test-Path -Path $csvLogPath)) {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -ErrorAction SilentlyContinue
+        } else {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -Append -ErrorAction SilentlyContinue
+        }
+        
+        # CSV log rotation
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $csvFiles = Get-ChildItem -Path $csvDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+            if ($csvFiles.Count -gt 7) {
+                $filesToRemove = $csvFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for CSV log rotation
+        }
+    }
+    catch {
+        # Silent error handling for CSV logging
+    }
+    #endregion CSV Logging
+
+    #region Console Output (only in EnableDebug mode)
+    if ($loggingMode -eq 'EnableDebug') {
+        switch ($Level.ToUpper()) {
+            'ERROR' { Write-Host $consoleLogMessage -ForegroundColor Red }
+            'WARNING' { Write-Host $consoleLogMessage -ForegroundColor Yellow }
+            'INFORMATION' { Write-Host $consoleLogMessage -ForegroundColor White }
+            'DEBUG' { Write-Host $consoleLogMessage -ForegroundColor Gray }
+        }
+    }
+    #endregion Console Output
+}
+
+function Write-EnhancedLog {
+    [CmdletBinding()]
+    param (
+        [string]$Message,
+        [string]$Level = 'INFO',
+        [string]$LoggingMode = 'SilentMode'
+    )
+
+    # Get the PowerShell call stack to determine the actual calling function
+    $callStack = Get-PSCallStack
+    $callerFunction = if ($callStack.Count -ge 2) { $callStack[1].Command } else { '<Unknown>' }
+
+    # Get the parent script name
+    $parentScriptName = Get-ParentScriptName
+
+    # Map enhanced log levels to CiscoApp log levels
+    $mappedLevel = switch ($Level.ToUpper()) {
+        'CRITICAL' { 'Error' }
+        'ERROR'    { 'Error' }
+        'WARNING'  { 'Warning' }
+        'INFO'     { 'Information' }
+        'DEBUG'    { 'Debug' }
+        'NOTICE'   { 'Information' }
+        'IMPORTANT' { 'Information' }
+        'OUTPUT'   { 'Information' }
+        'SIGNIFICANT' { 'Information' }
+        'VERBOSE'  { 'Debug' }
+        'VERYVERBOSE' { 'Debug' }
+        'SOMEWHATVERBOSE' { 'Debug' }
+        'SYSTEM'   { 'Information' }
+        'INTERNALCOMMENT' { 'Debug' }
+        default    { 'Information' }
+    }
+
+    # Format message with caller information
+    $formattedMessage = "[$parentScriptName.$callerFunction] $Message"
+
+    # Use the existing Write-AppDeploymentLog function
+    Write-AppDeploymentLog -Message $formattedMessage -Level $mappedLevel -Mode $LoggingMode
+}
+
+#region Helper Functions
+
+
+#region Error Handling
+function Handle-Error {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [System.Management.Automation.ErrorRecord]$ErrorRecord,
+        [string]$CustomMessage = "",
+        [string]$LoggingMode = "SilentMode"
+    )
+
+    try {
+        if ($PSVersionTable.PSVersion.Major -ge 7) {
+            $fullErrorDetails = Get-Error -InputObject $ErrorRecord | Out-String
+        } else {
+            $fullErrorDetails = $ErrorRecord.Exception | Format-List * -Force | Out-String
+        }
+
+        $errorMessage = if ($CustomMessage) {
+            "$CustomMessage - Exception: $($ErrorRecord.Exception.Message)"
+        } else {
+            "Exception Message: $($ErrorRecord.Exception.Message)"
+        }
+
+        Write-AppDeploymentLog -Message $errorMessage -Level Error -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Full Exception Details: $fullErrorDetails" -Level Debug -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Script Line Number: $($ErrorRecord.InvocationInfo.ScriptLineNumber)" -Level Debug -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Position Message: $($ErrorRecord.InvocationInfo.PositionMessage)" -Level Debug -Mode $LoggingMode
+    } 
+    catch {
+        # Fallback error handling in case of an unexpected error in the try block
+        Write-AppDeploymentLog -Message "An error occurred while handling another error. Original Exception: $($ErrorRecord.Exception.Message)" -Level Error -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Handler Exception: $($_.Exception.Message)" -Level Error -Mode $LoggingMode
+    }
+}
+#endregion Error Handling
+
+function Get-ParentScriptName {
+    [CmdletBinding()]
+    param ()
+
+    try {
+        # Get the current call stack
+        $callStack = Get-PSCallStack
+
+        # If there is a call stack, return the top-most script name
+        if ($callStack.Count -gt 0) {
+            foreach ($frame in $callStack) {
+                if ($frame.ScriptName) {
+                    $parentScriptName = $frame.ScriptName
+                    # Write-EnhancedLog -Message "Found script in call stack: $parentScriptName" -Level "INFO"
+                }
+            }
+
+            if (-not [string]::IsNullOrEmpty($parentScriptName)) {
+                $parentScriptName = [System.IO.Path]::GetFileNameWithoutExtension($parentScriptName)
+                return $parentScriptName
+            }
+        }
+
+        # If no script name was found, return 'UnknownScript'
+        Write-EnhancedLog -Message "No script name found in the call stack." -Level "WARNING"
+        return "UnknownScript"
+    }
+    catch {
+        Write-EnhancedLog -Message "An error occurred while retrieving the parent script name: $_" -Level "ERROR"
+        return "UnknownScript"
+    }
+}
+
+function Get-CurrentUser {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the current user context
+        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
+        $computerName = $env:COMPUTERNAME
+        
+        # Check if running as SYSTEM
+        if ($currentUser -like "*SYSTEM*" -or $currentUser -eq "NT AUTHORITY\SYSTEM") {
+            return @{
+                UserType = "SYSTEM"
+                UserName = "LocalSystem"
+                ComputerName = $computerName
+                FullUserContext = "SYSTEM-LocalSystem"
+            }
+        }
+        
+        # Extract domain and username
+        if ($currentUser.Contains('\')) {
+            $domain = $currentUser.Split('\')[0]
+            $userName = $currentUser.Split('\')[1]
+        } else {
+            $domain = $env:USERDOMAIN
+            $userName = $currentUser
+        }
+        
+        # Determine user type based on group membership
+        $userType = "User"
+        try {
+            $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
+            if ($isAdmin) {
+                $userType = "Admin"
+            }
+        }
+        catch {
+            # If we can't determine admin status, default to User
+            $userType = "User"
+        }
+        
+        # Sanitize names for file naming (remove invalid characters)
+        $userName = $userName -replace '[<>:"/\\|?*]', '_'
+        $userType = $userType -replace '[<>:"/\\|?*]', '_'
+        
+        return @{
+            UserType = $userType
+            UserName = $userName
+            ComputerName = $computerName
+            FullUserContext = "$userType-$userName"
+        }
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to get current user context: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        return @{
+            UserType = "Unknown"
+            UserName = "UnknownUser"
+            ComputerName = $env:COMPUTERNAME
+            FullUserContext = "Unknown-UnknownUser"
+        }
+    }
+}
+
+function Get-CallingScriptName {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the call stack
+        $callStack = Get-PSCallStack
+        
+        # Look for the actual calling script (not this script or logging functions)
+        $callingScript = "UnknownCaller"
+        
+        # Skip internal logging functions and Discovery script itself
+        $skipFunctions = @('Write-AppDeploymentLog', 'Write-EnhancedLog', 'Handle-Error', 'Get-CallingScriptName', 'Get-CurrentUser')
+        $skipScripts = @('Discovery', 'Discovery.ps1')
+        
+        # Start from index 1 to skip the current function
+        for ($i = 1; $i -lt $callStack.Count; $i++) {
+            $frame = $callStack[$i]
+            
+            # Check if this frame should be skipped
+            $shouldSkip = $false
+            
+            # Skip if it's one of our internal functions
+            if ($frame.Command -and $frame.Command -in $skipFunctions) {
+                $shouldSkip = $true
+            }
+            
+            # Skip if it's the Discovery script itself
+            if ($frame.ScriptName) {
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                if ($scriptName -in $skipScripts) {
+                    $shouldSkip = $true
+                }
+            }
+            
+            # If we shouldn't skip this frame, use it
+            if (-not $shouldSkip) {
+                if ($frame.ScriptName) {
+                    $callingScript = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                    break
+                }
+                elseif ($frame.Command -and $frame.Command -ne "<ScriptBlock>") {
+                    $callingScript = $frame.Command
+                    break
+                }
+            }
+        }
+        
+        # If we still haven't found a caller, determine the execution context
+        if ($callingScript -eq "UnknownCaller") {
+            # Check execution context
+            if ($callStack.Count -le 3) {
+                # Very short call stack suggests direct execution
+                $callingScript = "DirectExecution"
+            }
+            elseif ($MyInvocation.InvocationName -and $MyInvocation.InvocationName -ne "Get-CallingScriptName") {
+                # Use the invocation name if available
+                $callingScript = $MyInvocation.InvocationName
+            }
+            elseif ($PSCommandPath) {
+                # Check if we have a command path (script execution)
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($PSCommandPath)
+                if ($scriptName -and $scriptName -notin $skipScripts) {
+                    $callingScript = $scriptName
+                } else {
+                    $callingScript = "PowerShellExecution"
+                }
+            }
+            else {
+                # Check the host name to determine execution context
+                $hostName = $Host.Name
+                switch ($hostName) {
+                    "ConsoleHost" { $callingScript = "PowerShellConsole" }
+                    "Windows PowerShell ISE Host" { $callingScript = "PowerShell_ISE" }
+                    "ServerRemoteHost" { $callingScript = "RemoteExecution" }
+                    "Visual Studio Code Host" { $callingScript = "VSCode" }
+                    default { $callingScript = "PowerShellHost-$hostName" }
+                }
+            }
+        }
+        
+        return $callingScript
+    }
+    catch {
+        # In case of any error, provide a meaningful fallback
+        try {
+            $hostName = $Host.Name
+            return "ErrorFallback-$hostName"
+        }
+        catch {
+            return "ErrorFallback-Unknown"
+        }
+    }
+}
+
+
+#region Transcript Management Functions
+function Start-CiscoAppTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LogDirectory = "C:\ProgramData\CiscoSecureClient\Logs",
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-AppDeploymentLog -Message "Transcript not started - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $null
+        }
+        
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create directory structure: Logs/Transcript/{Date}/{ParentScript}
+        $transcriptDirectory = Join-Path -Path $LogDirectory -ChildPath "Transcript"
+        $fullTranscriptDirectory = Join-Path -Path $transcriptDirectory -ChildPath $dateFolder
+        $fullTranscriptDirectory = Join-Path -Path $fullTranscriptDirectory -ChildPath $parentScriptName
+        
+        if (-not (Test-Path -Path $fullTranscriptDirectory)) {
+            New-Item -ItemType Directory -Path $fullTranscriptDirectory -Force | Out-Null
+        }
+        
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        $transcriptPath = Join-Path -Path $fullTranscriptDirectory -ChildPath $transcriptFileName
+        
+        # Start transcript with error handling and suppress all console output
+        try {
+            Start-Transcript -Path $transcriptPath -ErrorAction Stop | Out-Null
+            Write-AppDeploymentLog -Message "Transcript started successfully at: $transcriptPath" -Level Information -Mode $LoggingMode
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Failed to start transcript at $transcriptPath" -LoggingMode $LoggingMode
+            return $null
+        }
+        
+        # Transcript rotation
+        try {
+            $transcriptFiles = Get-ChildItem -Path $fullTranscriptDirectory -Filter "*-*-*-*-$parentScriptName-transcript*.log" | Sort-Object LastWriteTime -Descending
+            if ($transcriptFiles.Count -gt 7) {
+                $filesToRemove = $transcriptFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                    Write-AppDeploymentLog -Message "Removed old transcript file: $($file.FullName)" -Level Debug -Mode $LoggingMode
+                }
+            }
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error during transcript file rotation" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptPath
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Start-CiscoAppTranscript function" -LoggingMode $LoggingMode
+        return $null
+    }
+}
+
+function Stop-CiscoAppTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-AppDeploymentLog -Message "Transcript not stopped - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $false
+        }
+        
+        # Check if transcript is running before attempting to stop
+        $transcriptRunning = $false
+        try {
+            # Try to stop transcript and suppress all console output
+            Stop-Transcript -ErrorAction Stop | Out-Null
+            $transcriptRunning = $true
+            Write-AppDeploymentLog -Message "Transcript stopped successfully." -Level Information -Mode $LoggingMode
+        }
+        catch [System.InvalidOperationException] {
+            # This is expected if no transcript is running
+            Write-AppDeploymentLog -Message "No active transcript to stop." -Level Debug -Mode $LoggingMode
+        }
+        catch {
+            # Other transcript-related errors
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error stopping transcript" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptRunning
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Stop-CiscoAppTranscript function" -LoggingMode $LoggingMode
+        return $false
+    }
+}
+
+function Get-TranscriptFilePath {
+    [CmdletBinding()]
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$TranscriptsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+    
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: Transcript/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+        
+        # Generate timestamp for unique transcript file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the transcript file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-transcript-{Timestamp}.log
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        
+        # Combine the full path
+        $transcriptFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $transcriptFileName
+        
+        return $transcriptFilePath
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to generate transcript file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-fallback-$timestamp.log"
+    }
+}
+#endregion Transcript Management Functions
+function Get-CSVLogFilePath {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [string]$LogsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: PSF/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+
+        # Generate timestamp for unique log file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the log file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-log-{Timestamp}.csv
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-$timestamp.csv"
+        
+        # Combine the full path
+        $csvLogFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $logFileName
+        
+        return $csvLogFilePath
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to generate CSV log file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-fallback-$timestamp.csv"
+    }
+}
+
+
+
+
+#endregion Helper Functions
+
+
+#endregion Logging Function
+
+#endregion
+
+#region Detection Functions
+
+#region Marker File Analysis
+function Test-MarkerFile {
+    <#
+    .SYNOPSIS
+        Checks for installation marker file from previous installations
+    #>
+    param(
+        [string]$FilePath,
+        [int]$MaxAgeHours = 168  # 7 days default
+    )
+    
+    try {
+        Write-AppDeploymentLog -Message "Checking marker file: $FilePath" -Level Debug -Mode $LoggingMode
+        
+        # Check if marker file exists
+        if (-not (Test-Path -Path $FilePath)) {
+            Write-AppDeploymentLog -Message "Marker file does not exist. Installation has never been run." -Level Information -Mode $LoggingMode
+            return @{ IsValid = $false; InstallationFound = $false; Reason = "FileNotFound" }
+        }
+        
+        # Check file age
+        $fileInfo = Get-Item -Path $FilePath
+        $fileAge = (Get-Date) - $fileInfo.LastWriteTime
+        $fileAgeHours = $fileAge.TotalHours
+        
+        if ($fileAgeHours -gt $MaxAgeHours) {
+            Write-AppDeploymentLog -Message "Marker file is stale (age: $([math]::Round($fileAgeHours, 2)) hours, max: $MaxAgeHours hours)." -Level Information -Mode $LoggingMode
+            return @{ IsValid = $false; InstallationFound = $false; Reason = "FileStale"; FileAgeHours = $fileAgeHours }
+        }
+        
+        Write-AppDeploymentLog -Message "Marker file exists and is current (age: $([math]::Round($fileAgeHours, 2)) hours). Analyzing content..." -Level Debug -Mode $LoggingMode
+        
+        # Read and parse JSON content
+        $jsonContent = Get-Content -Path $FilePath -Raw -ErrorAction Stop
+        $markerData = $jsonContent | ConvertFrom-Json -ErrorAction Stop
+        
+        # Validate required fields exist
+        if (-not $markerData.InstallationTimestamp -or -not $markerData.InstallationStatus) {
+            Write-AppDeploymentLog -Message "Marker file has invalid structure. Missing required fields." -Level Warning -Mode $LoggingMode
+            return @{ IsValid = $false; InstallationFound = $false; Reason = "InvalidStructure" }
+        }
+        
+        # Check installation status
+        $status = $markerData.InstallationStatus
+        Write-AppDeploymentLog -Message "Previous installation status: $status" -Level Debug -Mode $LoggingMode
+        
+        if ($status -eq "Success") {
+            Write-AppDeploymentLog -Message "Marker file indicates successful installation." -Level Information -Mode $LoggingMode
+            return @{ 
+                IsValid = $true
+                InstallationFound = $true
+                Reason = "InstallationSuccess"
+                InstallationStatus = $status
+                InstalledVersion = $markerData.InstalledVersion
+                ComponentsInstalled = $markerData.ComponentsInstalled
+            }
+        } else {
+            Write-AppDeploymentLog -Message "Marker file indicates installation was not fully successful (status: $status)." -Level Warning -Mode $LoggingMode
+            return @{ 
+                IsValid = $true
+                InstallationFound = $false
+                Reason = "InstallationIncomplete"
+                InstallationStatus = $status
+            }
+        }
+    }
+    catch {
+        if ($null -ne (Get-Command Handle-Error -ErrorAction SilentlyContinue)) {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Failed to analyze marker file: $FilePath" -LoggingMode $LoggingMode
+        }
+        Write-AppDeploymentLog -Message "Error reading marker file. Treating as invalid." -Level Error -Mode $LoggingMode
+        return @{ IsValid = $false; InstallationFound = $false; Reason = "FileReadError"; Error = $_.Exception.Message }
+    }
+}
+#endregion Marker File Analysis
+
+function Test-CiscoProcesses {
+    <#
+    .SYNOPSIS
+        Checks for running Cisco processes to avoid disruption
+    #>
+    param()
+    
+    Write-AppDeploymentLog -Message "Checking for active Cisco processes..." -Level Debug -Mode $LoggingMode
+    
+    $ciscoProcesses = @(
+        "vpnui",           # Cisco AnyConnect VPN UI
+        "vpnagent",        # Cisco AnyConnect VPN Agent
+        "csc_umbrellaagent", # Cisco Umbrella Agent
+        "acwebsecagent"    # Cisco Web Security Agent
+    )
+    
+    foreach ($processName in $ciscoProcesses) {
+        $process = Get-Process -Name $processName -ErrorAction SilentlyContinue
+        if ($null -ne $process) {
+            Write-AppDeploymentLog -Message "Active Cisco process found: $processName (PID: $($process.Id))" -Level Information -Mode $LoggingMode
+            return $true
+        }
+    }
+    
+    Write-AppDeploymentLog -Message "No active Cisco processes found." -Level Debug -Mode $LoggingMode
+    return $false
+}
+
+function Test-CiscoRegistry {
+    <#
+    .SYNOPSIS
+        Checks registry for Cisco Secure Client installation
+    #>
+    param()
+    
+    Write-AppDeploymentLog -Message "Starting registry detection for Cisco Secure Client..." -Level Debug -Mode $LoggingMode
+    
+    $registryPaths = @(
+        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*",
+        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*",
+        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*"
+    )
+    
+    $searchPatterns = @(
+        "*Cisco Secure Client*",
+        "*Cisco AnyConnect*",
+        "*Cisco Umbrella*"
+    )
+    
+    foreach ($path in $registryPaths) {
+        if (Test-Path $path) {
+            Write-AppDeploymentLog -Message "Checking registry path: $path" -Level Debug -Mode $LoggingMode
+            $items = Get-ItemProperty -Path $path -ErrorAction SilentlyContinue
+            
+            foreach ($item in $items) {
+                if ($null -eq $item.DisplayName) { continue }
+                
+                foreach ($pattern in $searchPatterns) {
+                    if ($item.DisplayName -like $pattern) {
+                        Write-AppDeploymentLog -Message "Found matching registry entry: $($item.DisplayName)" -Level Information -Mode $LoggingMode
+                        
+                        # Version check if version info is available
+                        if ($item.DisplayVersion) {
+                            try {
+                                $installedVersion = [version]$item.DisplayVersion
+                                $requiredVersion = [version]$MinimumVersion
+                                
+                                if ($installedVersion -ge $requiredVersion) {
+                                    Write-AppDeploymentLog -Message "Version check passed: $($item.DisplayVersion) >= $MinimumVersion" -Level Information -Mode $LoggingMode
+                                    return $true
+                                } else {
+                                    Write-AppDeploymentLog -Message "Version check failed: $($item.DisplayVersion) < $MinimumVersion" -Level Warning -Mode $LoggingMode
+                                }
+                            }
+                            catch {
+                                # If version parsing fails, consider it installed
+                                Write-AppDeploymentLog -Message "Version parsing failed for $($item.DisplayName), treating as installed" -Level Warning -Mode $LoggingMode
+                                return $true
+                            }
+                        }
+                        else {
+                            # No version info, but product found
+                            Write-AppDeploymentLog -Message "Found $($item.DisplayName) in registry (no version info available)" -Level Information -Mode $LoggingMode
+                            return $true
+                        }
+                    }
+                }
+            }
+        }
+    }
+    
+    Write-AppDeploymentLog -Message "No Cisco Secure Client found in registry." -Level Debug -Mode $LoggingMode
+    return $false
+}
+
+function Test-CiscoFiles {
+    <#
+    .SYNOPSIS
+        Checks for Cisco Secure Client files in common installation paths
+    #>
+    param()
+    
+    $filePaths = @(
+        "${env:ProgramFiles}\Cisco\Cisco Secure Client\vpnui.exe",
+        "${env:ProgramFiles(x86)}\Cisco\Cisco Secure Client\vpnui.exe",
+        "${env:ProgramFiles}\Cisco\Cisco AnyConnect Secure Mobility Client\vpnui.exe",
+        "${env:ProgramFiles(x86)}\Cisco\Cisco AnyConnect Secure Mobility Client\vpnui.exe"
+    )
+    
+    foreach ($path in $filePaths) {
+        if (Test-Path -Path $path -ErrorAction SilentlyContinue) {
+            # Check file version if possible
+            try {
+                $fileInfo = Get-Item -Path $path -ErrorAction Stop
+                $fileVersion = $fileInfo.VersionInfo.ProductVersion
+                
+                if ($fileVersion) {
+                    $installedVersion = [version]$fileVersion
+                    $requiredVersion = [version]$MinimumVersion
+                    
+                    if ($installedVersion -ge $requiredVersion) {
+                        if ($VerboseOutput) {
+                            Write-Output "Found Cisco executable at: $path (version $fileVersion)"
+                        }
+                        return $true
+                    }
+                }
+                else {
+                    # File exists but no version info
+                    if ($VerboseOutput) {
+                        Write-Output "Found Cisco executable at: $path (no version info)"
+                    }
+                    return $true
+                }
+            }
+            catch {
+                # File exists but couldn't read version
+                if ($VerboseOutput) {
+                    Write-Output "Found Cisco executable at: $path (error reading version)"
+                }
+                return $true
+            }
+        }
+    }
+    
+    return $false
+}
+
+function Test-CiscoServices {
+    <#
+    .SYNOPSIS
+        Checks for Cisco services
+    #>
+    param()
+    
+    $serviceNames = @(
+        "csc_umbrellaagent",  # Cisco Umbrella Roaming Client
+        "vpnagent",           # Cisco AnyConnect Secure Mobility Agent
+        "acwebsecagent"       # Cisco AnyConnect Web Security Agent
+    )
+    
+    foreach ($serviceName in $serviceNames) {
+        $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
+        if ($null -ne $service) {
+            if ($VerboseOutput) {
+                Write-Output "Found Cisco service: $serviceName (Status: $($service.Status))"
+            }
+            return $true
+        }
+    }
+    
+    return $false
+}
+#endregion
+
+#region Main Detection Logic
+# Start timing for diagnostics
+$ScriptStartTime = Get-Date
+$MaxRuntime = 300  # 5 minutes max (well within 30-minute limit)
+
+try {
+    Write-AppDeploymentLog -Message "Starting main detection logic..." -Level Information -Mode $LoggingMode
+    
+    #region Marker File Analysis
+    $markerFilePath = "C:\ProgramData\CiscoSecureClient\installation-results.json"
+    $markerFileMaxAgeHours = 168  # 7 days
+    
+    Write-AppDeploymentLog -Message "Checking installation marker file..." -Level Information -Mode $LoggingMode
+    $markerResult = Test-MarkerFile -FilePath $markerFilePath -MaxAgeHours $markerFileMaxAgeHours
+    
+    if ($markerResult.IsValid -and $markerResult.InstallationFound) {
+        Write-AppDeploymentLog -Message "Valid marker file found indicating successful installation." -Level Information -Mode $LoggingMode
+        # Continue with other checks to verify installation is still intact
+    }
+    #endregion Marker File Analysis
+    
+    # Check if user is in active session first (least disruptive)
+    if (Test-CiscoProcesses) {
+        $RunTime = (Get-Date) - $ScriptStartTime
+        Write-AppDeploymentLog -Message "Detection completed - active processes found. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+        Write-Output "$ApplicationName is installed (active processes detected) [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+        exit 0
+    }
+    
+    # Check runtime before registry scan
+    if (((Get-Date) - $ScriptStartTime).TotalSeconds -gt $MaxRuntime) {
+        Write-AppDeploymentLog -Message "Detection timeout reached." -Level Warning -Mode $LoggingMode
+        Write-Output "Detection timeout reached. Assuming not installed. [Runtime: $MaxRuntime s]"
+        exit 1
+    }
+    
+    # Primary detection method: Registry
+    if (Test-CiscoRegistry) {
+        $RunTime = (Get-Date) - $ScriptStartTime
+        Write-AppDeploymentLog -Message "Detection completed - found in registry. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+        Write-Output "$ApplicationName is installed (registry detection) [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+        exit 0
+    }
+    
+    # Check runtime before file system scan
+    if (((Get-Date) - $ScriptStartTime).TotalSeconds -gt $MaxRuntime) {
+        Write-AppDeploymentLog -Message "Detection timeout reached." -Level Warning -Mode $LoggingMode
+        Write-Output "Detection timeout reached. Assuming not installed. [Runtime: $MaxRuntime s]"
+        exit 1
+    }
+    
+    # Secondary detection method: File system
+    if (Test-CiscoFiles) {
+        $RunTime = (Get-Date) - $ScriptStartTime
+        Write-AppDeploymentLog -Message "Detection completed - found via file system. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+        Write-Output "$ApplicationName is installed (file detection) [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+        exit 0
+    }
+    
+    # Check runtime before service scan
+    if (((Get-Date) - $ScriptStartTime).TotalSeconds -gt $MaxRuntime) {
+        Write-AppDeploymentLog -Message "Detection timeout reached." -Level Warning -Mode $LoggingMode
+        Write-Output "Detection timeout reached. Assuming not installed. [Runtime: $MaxRuntime s]"
+        exit 1
+    }
+    
+    # Tertiary detection method: Services
+    if (Test-CiscoServices) {
+        $RunTime = (Get-Date) - $ScriptStartTime
+        Write-AppDeploymentLog -Message "Detection completed - found via services. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+        Write-Output "$ApplicationName is installed (service detection) [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+        exit 0
+    }
+    
+    # If we reach here, Cisco Secure Client is not detected
+    $RunTime = (Get-Date) - $ScriptStartTime
+    
+    # Log why detection failed
+    if (-not $markerResult.IsValid) {
+        Write-AppDeploymentLog -Message "No valid installation marker found. Reason: $($markerResult.Reason)" -Level Information -Mode $LoggingMode
+    }
+    
+    Write-AppDeploymentLog -Message "Detection completed - application not found. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+    Write-AppDeploymentLog -Message "=== Cisco Secure Client Detection Script Completed ===" -Level Information -Mode $LoggingMode
+    Write-Output "$ApplicationName is not installed [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+    exit 1
+}
+catch {
+    # On any error, assume not installed to trigger installation
+    $RunTime = (Get-Date) - $ScriptStartTime
+    
+    if ($null -ne (Get-Command Handle-Error -ErrorAction SilentlyContinue)) {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Detection script encountered an error" -LoggingMode $LoggingMode
+    }
+    
+    Write-AppDeploymentLog -Message "=== Cisco Secure Client Detection Script Failed ===" -Level Error -Mode $LoggingMode
+    Write-Output "Detection script error: $_ [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+    exit 1
+}
+#endregion
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/.DS_Store b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/.DS_Store
new file mode 100644
index 0000000..19a264e
Binary files /dev/null and b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/.DS_Store differ
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Profiles/umbrella/OrgInfo.json b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Profiles/umbrella/OrgInfo.json
new file mode 100644
index 0000000..0e5422f
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Profiles/umbrella/OrgInfo.json	
@@ -0,0 +1,5 @@
+{
+    "organizationId" : "8329794",
+    "fingerprint" : "d454b12c440243e57e518f4b8476bb23",
+    "userId" : "12030419"
+}
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/GUI.ico b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/GUI.ico
new file mode 100644
index 0000000..a2873b9
Binary files /dev/null and b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/GUI.ico differ
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/cues_bg.jpg b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/cues_bg.jpg
new file mode 100644
index 0000000..f42fb03
Binary files /dev/null and b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/cues_bg.jpg differ
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula.html b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula.html
new file mode 100644
index 0000000..afb5b3a
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula.html	
@@ -0,0 +1,151 @@
+<html>
+
+<head>
+<meta http-equiv=Content-Type content="text/html; charset=utf-8">
+<meta name=Generator content="Microsoft Word 15 (filtered)">
+<style>
+<!--
+ /* Font Definitions */
+ @font-face
+	{font-family:Wingdings;
+	panose-1:5 0 0 0 0 0 0 0 0 0;}
+@font-face
+	{font-family:SimSun;
+	panose-1:2 1 6 0 3 1 1 1 1 1;}
+@font-face
+	{font-family:"Cambria Math";
+	panose-1:2 4 5 3 5 4 6 3 2 4;}
+@font-face
+	{font-family:Tahoma;
+	panose-1:2 11 6 4 3 5 4 4 2 4;}
+@font-face
+	{font-family:"\@SimSun";
+	panose-1:2 1 6 0 3 1 1 1 1 1;}
+ /* Style Definitions */
+ p.MsoNormal, li.MsoNormal, div.MsoNormal
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:10.0pt;
+	margin-left:0in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+a:link, span.MsoHyperlink
+	{color:#003399;
+	text-decoration:underline;}
+p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:10.0pt;
+	margin-left:.5in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:0in;
+	margin-left:.5in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:0in;
+	margin-left:.5in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:10.0pt;
+	margin-left:.5in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+.MsoChpDefault
+	{font-family:"Calibri",sans-serif;}
+.MsoPapDefault
+	{margin-bottom:10.0pt;
+	line-height:115%;}
+@page WordSection1
+	{size:8.5in 11.0in;
+	margin:1.0in 1.0in 1.0in 1.0in;}
+div.WordSection1
+	{page:WordSection1;}
+ /* List Definitions */
+ ol
+	{margin-bottom:0in;}
+ul
+	{margin-bottom:0in;}
+-->
+</style>
+
+</head>
+
+<body lang=EN-US link="#003399" vlink=purple style='word-wrap:break-word'>
+
+<div class=WordSection1>
+
+<p class=MsoNormal align=center style='text-align:center;line-height:normal'><a
+name=wp1015257></a><a name=wp1015255></a><a
+name="Supplemental_End_User_License_Agreement_"></a><b><span style='font-size:
+14.0pt;font-family:"Arial",sans-serif;color:black'>Supplemental End User
+License Agreement</span></b></p>
+
+<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
+line-height:normal'><a name=wp1015256></a><b><span style='font-family:"Arial",sans-serif;
+color:black'>IMPORTANT: READ CAREFULLY</span></b></p>
+
+<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
+line-height:normal'><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>By clicking accept or using the Cisco Technology, you agree that
+such use is governed by the Cisco End User License Agreement and the applicable
+Product Specific Terms (collectively, the &quot;EULA&quot;). You also
+acknowledge and agree that you have read the Cisco Privacy Statement. </span></p>
+
+<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
+line-height:normal'><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>If you do not have authority to bind your company and its
+affiliates, or if you do not agree with the terms of the EULA, do not click 'accept'
+and do not use the Cisco Technology. If you are a Cisco channel partner
+accepting on behalf of an end customer (&quot;customer&quot;), you must inform
+the customer that the EULA applies to customer's use of the Cisco Technology
+and provide the customer with access to all relevant terms.</span></p>
+
+<p class=MsoNormal style='margin-bottom:0in;text-align:justify;text-justify:
+inter-ideograph;line-height:normal'><span style='font-size:9.0pt;font-family:
+"Arial",sans-serif;color:black'>The latest version of documents can be found at
+the following locations.</span></p>
+
+<p class=MsoListParagraphCxSpFirst style='margin-left:40.5pt;text-indent:-22.5pt;
+line-height:normal'><span style='font-size:9.0pt;font-family:Symbol;color:black'>┬╖<span
+style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+</span></span><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>Cisco End User License Agreement: <a
+href="https://www.cisco.com/c/en/us/about/legal/cloud-and-software/end_user_license_agreement.html"
+target="_blank">https://www.cisco.com/c/en/us/about/legal/cloud-and-software/end_user_license_agreement.html</a></span></p>
+
+<p class=MsoListParagraphCxSpMiddle style='margin-left:40.5pt;text-indent:-22.5pt;
+line-height:normal'><span style='font-size:9.0pt;font-family:Symbol;color:black'>┬╖<span
+style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+</span></span><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>Applicable Product Specific Terms: <a
+href="https://www.cisco.com/c/en/us/about/legal/cloud-and-software/software-terms.html"
+target="_blank">https://www.cisco.com/c/en/us/about/legal/cloud-and-software/software-terms.html</a></span></p>
+
+<p class=MsoListParagraphCxSpLast style='margin-bottom:0in;margin-left:40.5pt;
+text-indent:-22.5pt;line-height:normal'><span style='font-size:9.0pt;
+font-family:Symbol;color:black'>┬╖<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+</span></span><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>Cisco Privacy Statement: <a
+href="https://www.cisco.com/c/en/us/about/legal/privacy-full.html"
+target="_blank">https://www.cisco.com/c/en/us/about/legal/privacy-full.html</a></span></p>
+
+</div>
+
+</body>
+
+</html>
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula_dialog.html b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula_dialog.html
new file mode 100644
index 0000000..891433f
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula_dialog.html	
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
+<head>
+  <title>Cisco Secure Client EULA</title>
+  <meta http-equiv="MSThemeCompatible" content="Yes" />
+</head>
+<body style="background-image:url('cues_bg.jpg')">
+  <div style="text-align:center;margin:15px;">
+    <iframe src="eula.html" scrolling="auto" style="position:relative;width:550px;height:350px;"></iframe>
+    <br />
+    <input type="submit" id="accept" onclick="window.returnValue=1;self.close()" style="margin-top:10px;margin-right:10px" value="Accept" />
+    <input type="submit" id="decline" onclick="window.returnValue=0;self.close()" style="margin-top:10px" value="Decline" />
+  </div>
+</body>
+</html>
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/update.txt b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/update.txt
new file mode 100644
index 0000000..976ddcb
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/update.txt	
@@ -0,0 +1 @@
+5,1,10,233
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Umbrella-Install.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Umbrella-Install.ps1
new file mode 100644
index 0000000..75fe4ce
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Umbrella-Install.ps1	
@@ -0,0 +1,3 @@
+Start-Process msiexec /package cisco-secure-client-win-5.1.10.233-core-vpn-predeploy-k9.msi PRE_DEPLOY_DISABLE_VPN=1 /norestart /passive /lvx* vpninstall.log
+Start-Process msiexec /package cisco-secure-client-win-5.1.10.233-umbrella-predeploy-k9.msi PRE_DEPLOY_DISABLE_VPN=1 /norestart /passive /lvx* umbrellainstall.log
+Start-Process msiexec /package cisco-secure-client-win-5.1.10.233-dart-predeploy-k9.msi /norestart /passive /lvx* dartinstall.log
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/setup.hta b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/setup.hta
new file mode 100644
index 0000000..c7c3de7
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/setup.hta	
@@ -0,0 +1,538 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<!--
+*************************************************************************
+**           Copyright (c) 2015, Cisco Systems, All Rights Reserved
+*************************************************************************
+-->
+<head>
+<title>Cisco Secure Client Install Selector</title>
+<meta http-equiv="MSThemeCompatible" content="Yes">
+<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+<HTA:APPLICATION 
+     ID="installSelect" 
+     APPLICATIONNAME="Cisco Secure Client - Installer"
+     SCROLL="yes"
+     SINGLEINSTANCE="yes"
+     SELECTION="no"
+     ICON="Setup\GUI.ico">
+<script type="text/vbscript">
+    'Window_OnLoad
+    Window.ResizeTo 650, 670
+    Window.moveto 0, 0
+
+    Dim WshShell, objFSO, strVer, strTemp, Return, strReturn
+    Dim bNeedsReboot, valNeedsReboot, valNumChecked
+    Dim strLockDown, dblQuote
+    
+    strLockDown = ""
+    dblQuote  = chr(34)
+    valNeedsReboot = 3010
+
+    Set WshShell = CreateObject("WScript.Shell")
+    Set objFSO = CreateObject("Scripting.FileSystemObject")
+
+    Dim strScriptDir
+    strScriptDir = objFSO.GetParentFolderName(replace(installSelect.commandLine, dblQuote, ""))
+
+    Sub Initialize
+        Dim strVerFile
+        strVerFile = strScriptDir & "\Setup\update.txt"
+        If objFSO.FileExists(strVerFile) Then
+            Set objTextFile = objFSO.OpenTextFile(strVerFile, 1)
+            strVer = objTextFile.ReadAll
+            objTextFile.Close
+            strVer = Replace (strVer, ",", ".")
+            strVer = Replace (strVer, vbNewLine, "")
+        End If
+
+        If Not IsEmpty(strVer) Then
+            Version.InnerText = strVer
+        Else
+            Body.InnerHTML = "<p style='text-align:center'>Unable to determine Cisco Secure Client package version (missing update.txt).</p>"
+        End If
+
+        strTemp = objFSO.GetSpecialFolder(TemporaryFolder)
+        strTemp = strTemp & "\Temp\"
+    End Sub
+
+    ' Main Subroutine
+    Sub TestCheckboxes
+        valNumChecked = 0
+        strSelected = vbCrLf
+        If CheckboxVPN.Checked Then
+            strSelected = strSelected & "AnyConnect VPN" & vbCrLf
+            blnInstallVPN = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxSBL.Checked Then
+            strSelected = strSelected & "Start Before Login" & vbCrLf
+            blnInstallSBL = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxDART.Checked Then
+            strSelected = strSelected & "Diagnostic And Reporting Tool" & vbCrLf
+            blnInstallDART = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxPosture.Checked Then
+            strSelected = strSelected & "Secure Firewall Posture" & vbCrLf
+            blnInstallPosture = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxISEPosture.Checked Then
+            If blnInstallVPN Then
+                strSelected = strSelected & "ISE Posture" & vbCrLf
+                blnInstallISEPosture = true
+                valNumChecked = valNumChecked + 1
+            Else
+                strSelected = strSelected & "Stand-Alone ISE Posture" & vbCrLf
+                blnInstallISEPostureAlone = true
+                valNumChecked = valNumChecked + 1
+            End If
+        End If
+        If CheckboxNVM.Checked Then
+            strSelected = strSelected & "Network Visibility Module" & vbCrLf
+            blnInstallNVM = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxNAM.Checked Then
+            If blnInstallVPN Then
+                strSelected = strSelected & "Network Access Manager" & vbCrLf
+                blnInstallNAM = true
+                valNumChecked = valNumChecked + 1
+            Else
+                strSelected = strSelected & "Stand-Alone Network Access Manager" & vbCrLf
+                blnInstallNAMAlone = true
+                valNumChecked = valNumChecked + 1
+            End If
+        End If
+        If CheckboxUmbrella.Checked Then
+            If blnInstallVPN Then
+                strSelected = strSelected & "Umbrella" & vbCrLf
+                blnInstallUmbrella = true
+                valNumChecked = valNumChecked + 1
+            Else
+                strSelected = strSelected & "Stand-Alone Umbrella" & vbCrLf
+                blnInstallUmbrellaAlone = true
+                valNumChecked = valNumChecked + 1
+            End If
+        End If
+        If CheckboxThousandEyes.Checked Then
+            strSelected = strSelected & "ThousandEyes" & vbCrLf
+            blnInstallThousandEyes = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxZTA.Checked Then
+            If blnInstallVPN Then
+                strSelected = strSelected & "Zero Trust Access" & vbCrLf
+                blnInstallZTA = true
+                valNumChecked = valNumChecked + 1
+            Else
+                strSelected = strSelected & "Stand-Alone Zero Trust Access" & vbCrLf
+                blnInstallZTAAlone = true
+                valNumChecked = valNumChecked + 1
+            End If
+        End If
+        If valNumChecked > 0 Then
+            blnAnswer = window.confirm( "You selected the following Cisco Secure Client " & strVer & " modules to install: " & vbCrLf & strSelected & vbCrLf & "Do you wish to install these now?")
+            If Not blnAnswer Then
+                Exit Sub
+            End If
+           
+            blnAcceptedEULA = window.showModalDialog(strScriptDir & "/Setup/eula_dialog.html","","dialogwidth=650px;dialogheight=450px;status:no")
+            If blnAcceptedEULA Then
+                If blnInstallVPN Then
+                    InstallVPN
+                End If
+                If blnInstallDART Then
+                    InstallDART
+                End If
+                If blnInstallNAM Then
+                    InstallNAM
+                End If
+                If blnInstallPosture Then
+                    InstallPosture
+                End If
+                If blnInstallISEPosture Then
+                    InstallISEPosture
+                End If
+                If blnInstallNVM Then
+                    InstallNVM
+                End If
+                If blnInstallUmbrella Then
+                    InstallUmbrella
+                End If
+                If blnInstallThousandEyes Then
+                    InstallThousandEyes
+                End If
+                If blnInstallSBL Then
+                    InstallSBL
+                End If
+                If blnInstallZTA Then
+                    InstallZTA
+                End If
+                If blnInstallNAMAlone Then
+                    InstallAnyConnectDisableVPN
+                    InstallNAM
+                End If
+                If blnInstallUmbrellaAlone Then
+                    InstallAnyConnectDisableVPN
+                    InstallUmbrella
+                End If
+                If blnInstallISEPostureAlone Then
+                    InstallAnyConnectDisableVPN
+                    InstallISEPosture
+                End If
+                If blnInstallZTAAlone Then
+                    InstallAnyConnectDisableVPN
+                    InstallZTA
+                End If
+
+                If bNeedsReboot Then
+                    Msgbox "You must reboot your system for the installed changes to take effect.", vbOKOnly, "Cisco Secure Client Install Selector"
+                Else
+                    Msgbox "Installation complete.", vbOKOnly, "Cisco Secure Client Install Selector"
+                End If
+
+                ExitHTA
+            End If
+        End If
+    End Sub
+
+    ' Checkbox Dependencies Subroutines
+    Sub CheckAll
+        CheckboxVPN.Checked = CheckboxALL.Checked
+        CheckboxSBL.Checked = CheckboxALL.Checked
+        CheckboxNAM.Checked = CheckboxALL.Checked
+        CheckboxPosture.Checked = CheckboxALL.Checked
+        CheckboxISEPosture.Checked = CheckboxALL.Checked
+        CheckboxNVM.Checked = CheckboxALL.Checked
+        CheckboxUmbrella.Checked = CheckboxALL.Checked
+        CheckboxThousandEyes.Checked = CheckboxALL.Checked
+        CheckboxZTA.Checked = CheckboxALL.Checked
+    End Sub
+
+    Sub CheckDependsVPN
+        CheckSBLChecked
+        If CheckboxVPN.Checked=False Then
+            CheckboxPosture.Checked = False
+            CheckboxISEPosture.Checked = False
+            CheckboxNVM.Checked = False
+            CheckboxAll.Checked = False
+        End If
+    End Sub
+    
+    Sub CheckSBLDependsOnSBLClick
+        If CheckboxSBL.Checked Then
+            CheckboxVPN.Checked = True
+        End If
+    End Sub
+
+    Sub CheckSBLChecked
+        If CheckboxVPN.Checked=False And CheckboxNAM.Checked=False Then
+            CheckboxSBL.checked=False
+        End If
+    End Sub
+    
+    Sub CheckDependsNAM
+        CheckSBLChecked
+        If CheckboxNAM.Checked=False Then
+            CheckboxAll.Checked = False
+        End If
+    End Sub
+
+    Sub CheckPostureDepends
+        If CheckboxPosture.Checked Then
+            CheckboxVPN.Checked = True
+        End If
+        If CheckboxPosture.Checked=False Then
+            CheckboxALL.Checked = False
+        End If
+    End Sub
+ 
+    Sub CheckNVMDepends
+        If CheckboxNVM.Checked Then
+            CheckboxVPN.Checked = True
+        End If
+        If CheckboxNVM.Checked=False Then
+            CheckboxALL.Checked = False
+        End If
+    End Sub
+ 
+    Sub CheckALLFalse
+        If CheckboxNAM.Checked=False or CheckboxISEPosture.Checked=False or CheckboxNVM.Checked=False or CheckboxUmbrella.Checked=False or CheckboxThousandEyes.Checked=False or CheckboxZTA.Checked=False Then
+            CheckboxALL.Checked = False
+        End If
+    End Sub
+    
+    Sub SetLockDownFlag
+        If CheckboxLOCKDOWN.Checked Then
+            strLockDown = "LOCKDOWN=1"
+        Else
+            strLockDown = ""
+        End If
+    End Sub
+   
+    ' Install Subroutines
+    Function GetDateTimeString()
+        Dim dd, MM, yy, hh, nn, ss
+        Dim dateValue, timeValue, dtsNow
+
+        'Store DateTimeStamp once.
+        dtsNow = Now()
+
+        'Individual date components
+        MM = Right("00" & Month(dtsNow), 2)
+        dd = Right("00" & Day(dtsNow), 2)
+        yy = Year(dtsNow)
+        hh = Right("00" & Hour(dtsNow), 2)
+        nn = Right("00" & Minute(dtsNow), 2)
+        ss = Right("00" & Second(dtsNow), 2)
+
+        'Build the date string in the format mm-dd-yyyy
+        dateValue = MM & dd & yy
+
+        'Build the time string in the format hh:mm:ss
+        timeValue = hh & nn & ss
+
+        'Concatenate both together to build the timestamp MMddyyyy_hhmmss
+        GetDateTimeString = dateValue & "_" & timeValue
+    End Function
+
+REM  Returns name of first file found in directory that matches the first and second 
+REM  segments of the strFilenameMatch as delimited by the strDelimiter
+    Function GetFileNameSingleWildcard(strDirectory, strFilenameMatch, strDelimiter)
+    Dim objFS, objDir, objFiles, objFile, strMatchArray
+
+    Set objFS = CreateObject("Scripting.FileSystemObject")
+
+    ' This function expects a single delimiter
+    strMatchArray=Split(strFilenameMatch,strDelimiter)
+    if UBound(strMatchArray) <> 1 then
+        ' return empty string for invalid number of wildcards
+        Exit Function
+    End if
+
+    Set objDir = objFS.GetFolder(strDirectory)
+    Set objFiles = objDir.Files
+
+    For Each objFile in ObjFiles
+        ' check first segment and then second segment for match
+        if (instr(1,objFile.Name, strMatchArray(0)) > 0) And (instr(Len(strMatchArray(0)),objFile.Name, strMatchArray(1)) > 0) then
+            GetFileNameSingleWildcard = objFile.Name
+            Exit For
+        End if
+    Next
+
+    End Function
+
+    Sub InstallVPN
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-core-vpn-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive PRE_DEPLOY_DISABLE_VPN=0 " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallSBL
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-sbl-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallDART
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-dart-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallNAM
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-nam-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallUmbrella
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-umbrella-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallAnyConnectDisableVPN
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-core-vpn-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive PRE_DEPLOY_DISABLE_VPN=1 " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+        
+    Sub InstallPosture
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-posture-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallISEPosture
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-iseposture-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallNVM
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-nvm-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallThousandEyes
+        strInstallFile = GetFileNameSingleWildcard(strScriptDir, "cisco-secure-client-win-*-thousandeyes-predeploy-k9.msi", "*")
+        strLogFile = objFSO.GetBaseName(strInstallFile) & "-install-" & GetDateTimeString & ".log"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallZTA
+        strInstallFile = GetFileNameSingleWildcard(strScriptDir, "cisco-secure-client-win-*-zta-predeploy-k9.msi", "*")
+        strLogFile = objFSO.GetBaseName(strInstallFile) & "-install-" & GetDateTimeString & ".log"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub ExitHTA
+        self.close()
+    End Sub
+</script>
+</head>
+<style>
+p  {
+    margin: 8px;
+}
+</style>
+<body id="body" style="background-image=url('Setup/cues_bg.jpg');font-family:'Times New Roman',serif;font-size:24;color=white" onload="Initialize">
+Select the Cisco Secure Client <span id="version">0.0.0</span> modules you wish to install:
+<p>
+<span class="tooltip" title="Installs the module that enables VPN capabilities.">
+<input type="checkbox" id="vpn" name="CheckboxVPN" checked onclick="CheckDependsVPN">
+<label for="vpn">Core & AnyConnect VPN</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that allows a VPN session and/or network logon to be established prior to a user logging onto the system.">
+<input type="checkbox" id="sbl" name="CheckboxSBL" checked onclick="CheckSBLDependsOnSBLClick">
+<label for="sbl">Start Before Login</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that provides Layer 2 device management and authentication for access to both wired and wireless networks.">
+<input type="checkbox" id="nam" name="CheckboxNAM" checked onClick="CheckDependsNAM">
+<label for="nam">Network Access Manager</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that provides the Cisco Secure Client with the ability to identify the operating system, antivirus, antispyware, and firewall software installed on the host prior to creating a remote access connection to the secure gateway.">
+<input type="checkbox" id="posture" name="CheckboxPosture" checked onclick="CheckPostureDepends">
+<label for="posture">Secure Firewall Posture</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the Network Visibility module which collects application telemetry data.">
+<input type="checkbox" id="NVM" name="CheckboxNVM" checked onclick="CheckNVMDepends">
+<label for="NVM">Network Visibility Module</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that enables Umbrella.">
+<input type="checkbox" id="umbrella" name="CheckboxUmbrella" checked onclick="CheckAllFalse">
+<label for="umbrella">Umbrella</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that provides the Cisco Secure Client with the functionality needed to authenticate to wired or wireless networks controlled by the Identity Services Engine, including examination and any needed remediation of the connecting host environment.">
+<input type="checkbox" id="iseposture" name="CheckboxISEPosture" checked onclick="CheckAllFalse">
+<label for="iseposture">ISE Posture</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that enables ThousandEyes.">
+<input type="checkbox" id="thousandeyes" name="CheckboxThousandEyes" checked onclick="CheckAllFalse">
+<label for="thousandeyes">ThousandEyes</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that enables ZTA.">
+<input type="checkbox" id="zta" name="CheckboxZTA" checked onclick="CheckAllFalse">
+<label for="zta">Zero Trust Access</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the entire suite of Cisco Secure Client software components.">
+<input type="checkbox" id="all" name="CheckboxALL" checked onClick="CheckAll">
+<label for="all">Select All</label>
+</span>
+</p>
+<p style="margin-top:28px">
+<span class="tooltip" title="Installs the diagnostics module that collects Cisco Secure Client troubleshooting information.">
+<input type="checkbox" id="dart" name="CheckboxDART" checked>
+<label for="dart">Diagnostic And Reporting Tool</label>
+</span>
+</p>
+<br>
+<p style="text-align:right">
+<span class="tooltip" title="Locks down the permissions of the Windows Services for each module that is installed. This will prevent any user from stopping the service, including local administrators.">
+<input type="checkbox" id="lockdown" name="CheckboxLOCKDOWN" onclick="SetLockDownFlag">
+<label for="lockdown">Lock Down Component Services</label>
+</span>
+</p>
+<p>
+<input type="submit" value="Install Selected" id="run_button" style="font-size:20;" onClick="TestCheckboxes">
+</p>
+</body>
+</html>
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/debug-uninstall.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/debug-uninstall.ps1
new file mode 100644
index 0000000..82a45f8
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/debug-uninstall.ps1	
@@ -0,0 +1,22 @@
+# Debug the Get-CiscoInstalledProducts function
+. "C:\code\Cisco Secure Client\uninstall.ps1" -DebugPreference 'Continue'
+
+# Get the products
+$products = Get-CiscoInstalledProducts
+
+Write-Host "`nTotal products found: $($products.Count)"
+Write-Host "Products array type: $($products.GetType().Name)"
+
+for ($i = 0; $i -lt $products.Count; $i++) {
+    $p = $products[$i]
+    Write-Host "`n[$i] Type: $($p.GetType().Name)"
+    if ($p -is [hashtable]) {
+        Write-Host "    Name: $($p['Name'])"
+        Write-Host "    Code: $($p['Code'])"
+        Write-Host "    Order: $($p['Order'])"
+    } elseif ($p -is [string]) {
+        Write-Host "    String value: '$p'"
+    } else {
+        Write-Host "    Unknown type value: $p"
+    }
+}
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/install.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/install.ps1
new file mode 100644
index 0000000..8f68a12
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/install.ps1	
@@ -0,0 +1,363 @@
+<#
+.SYNOPSIS
+    Installs Cisco Secure Client with Umbrella component for DNS filtering.
+
+.DESCRIPTION
+    This script installs Cisco Secure Client components in the following order:
+    1. Core VPN component (with VPN disabled for organizations using alternate VPN)
+    2. Umbrella component (for DNS-layer security)
+    3. DART component (diagnostics and reporting tool)
+    
+    Designed for Intune Win32 app deployment.
+
+.NOTES
+    Version:        1.0
+    Creation Date:  2025-01-12
+    Purpose:        Intune Win32 App Installation Script
+    Compatibility:  PowerShell 5.1
+#>
+
+#region Script Configuration
+$ScriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
+$LogPath = "$env:ProgramData\Microsoft\IntuneManagementExtension\Logs"
+$LogFile = Join-Path $LogPath "CiscoSecureClient_Install_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
+$MaxRetries = 3
+$RetryDelay = 5
+#endregion
+
+#region Logging Functions
+function Write-Log {
+    param(
+        [Parameter(Mandatory=$true)]
+        [string]$Message,
+        
+        [Parameter(Mandatory=$false)]
+        [ValidateSet('Info','Warning','Error')]
+        [string]$Level = 'Info'
+    )
+    
+    $TimeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $LogMessage = "$TimeStamp [$Level] $Message"
+    
+    # Write to log file
+    Add-Content -Path $LogFile -Value $LogMessage -Force
+    
+    # Also write to console for Intune
+    switch ($Level) {
+        'Warning' { Write-Warning $Message }
+        'Error' { Write-Error $Message }
+        default { Write-Output $Message }
+    }
+}
+#endregion
+
+#region Installation Functions
+function Install-MSIPackage {
+    param(
+        [Parameter(Mandatory=$true)]
+        [string]$MSIPath,
+        
+        [Parameter(Mandatory=$true)]
+        [string]$LogName,
+        
+        [Parameter(Mandatory=$false)]
+        [string]$Arguments = "/qn /norestart"
+    )
+    
+    $MSILogFile = Join-Path $LogPath "${LogName}_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
+    $MSIName = Split-Path -Leaf $MSIPath
+    
+    Write-Log "Installing $MSIName..."
+    
+    # Build the full argument string
+    $ArgumentList = "/i `"$MSIPath`" $Arguments /l*v `"$MSILogFile`""
+    
+    $Process = Start-Process -FilePath "msiexec.exe" -ArgumentList $ArgumentList -Wait -PassThru
+    
+    if ($Process.ExitCode -eq 0) {
+        Write-Log "$MSIName installed successfully."
+        return $true
+    }
+    elseif ($Process.ExitCode -eq 3010) {
+        Write-Log "$MSIName installed successfully but requires a reboot." -Level Warning
+        return $true
+    }
+    else {
+        Write-Log "$MSIName installation failed with exit code: $($Process.ExitCode)" -Level Error
+        return $false
+    }
+}
+
+function Test-Prerequisites {
+    Write-Log "Checking prerequisites..."
+    
+    # Check for minimum Windows version (Windows 10 1809 or later recommended)
+    $OSVersion = [System.Environment]::OSVersion.Version
+    if ($OSVersion.Major -lt 10) {
+        Write-Log "Windows 10 or later is required. Current version: $($OSVersion.ToString())" -Level Error
+        return $false
+    }
+    
+    # Check for administrator privileges
+    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
+        Write-Log "Script must be run with administrator privileges." -Level Error
+        return $false
+    }
+    
+    # Check if another installation is in progress
+    $MsiExecProcesses = Get-Process -Name "msiexec" -ErrorAction SilentlyContinue | Where-Object { $_.Id -ne $PID }
+    if ($MsiExecProcesses) {
+        Write-Log "Another installation is in progress. Waiting..." -Level Warning
+        Start-Sleep -Seconds 30
+    }
+    
+    Write-Log "Prerequisites check passed."
+    return $true
+}
+#endregion
+
+#region Main Installation Logic
+try {
+    # Create log directory if it doesn't exist
+    if (-not (Test-Path $LogPath)) {
+        New-Item -ItemType Directory -Path $LogPath -Force | Out-Null
+    }
+    
+    Write-Log "=== Cisco Secure Client Installation Started ==="
+    Write-Log "Script Path: $ScriptPath"
+    
+    # Initialize installation results for marker file
+    $installationStartTime = Get-Date
+    $installationResults = @{
+        InstallationTimestamp = $installationStartTime.ToString('yyyy-MM-dd HH:mm:ss')
+        InstallationStatus = "InProgress"
+        ComputerName = $env:COMPUTERNAME
+        UserContext = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
+        ScriptVersion = "1.0"
+        InstalledVersion = $null
+        ComponentsInstalled = @{}
+        ComponentsFailed = @{}
+        ErrorInfo = @()
+        TotalExecutionSeconds = 0
+    }
+    
+    # Check prerequisites
+    if (-not (Test-Prerequisites)) {
+        Write-Log "Prerequisites check failed. Exiting." -Level Error
+        exit 1
+    }
+    
+    # Define MSI packages to install (per Cisco documentation)
+    $MSIPackages = @(
+        @{
+            Name = "Core VPN"
+            File = "cisco-secure-client-win-5.1.10.233-core-vpn-predeploy-k9.msi"
+            Arguments = "PRE_DEPLOY_DISABLE_VPN=1 /qn /norestart"
+            LogName = "vpninstall"
+        },
+        @{
+            Name = "Umbrella"
+            File = "cisco-secure-client-win-5.1.10.233-umbrella-predeploy-k9.msi"
+            Arguments = "PRE_DEPLOY_DISABLE_VPN=1 /qn /norestart"
+            LogName = "umbrellainstall"
+        },
+        @{
+            Name = "DART"
+            File = "cisco-secure-client-win-5.1.10.233-dart-predeploy-k9.msi"
+            Arguments = "/qn /norestart"
+            LogName = "dartinstall"
+        }
+    )
+    
+    $FailedInstalls = @()
+    
+    # Install each package
+    foreach ($Package in $MSIPackages) {
+        # First try the subdirectory location
+        $MSIPath = Join-Path $ScriptPath "cisco-secure-client-win-5.1.10.233-predeploy-k9\$($Package.File)"
+        
+        # If not found in subdirectory, try the root directory
+        if (-not (Test-Path $MSIPath)) {
+            $MSIPath = Join-Path $ScriptPath $Package.File
+        }
+        
+        if (-not (Test-Path $MSIPath)) {
+            Write-Log "MSI file not found: $($Package.File)" -Level Error
+            $FailedInstalls += $Package.Name
+            continue
+        }
+        
+        Write-Log "Installing $($Package.Name) component..."
+        
+        $RetryCount = 0
+        $Success = $false
+        
+        while ($RetryCount -lt $MaxRetries -and -not $Success) {
+            if ($RetryCount -gt 0) {
+                Write-Log "Retry attempt $RetryCount for $($Package.Name)..." -Level Warning
+                Start-Sleep -Seconds $RetryDelay
+            }
+            
+            $Success = Install-MSIPackage -MSIPath $MSIPath -LogName $Package.LogName -Arguments $Package.Arguments
+            $RetryCount++
+        }
+        
+        if (-not $Success) {
+            $FailedInstalls += $Package.Name
+            $installationResults.ComponentsFailed[$Package.Name] = @{
+                Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
+                Reason = "Installation failed after $MaxRetries attempts"
+            }
+        } else {
+            $installationResults.ComponentsInstalled[$Package.Name] = @{
+                Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
+                Version = "5.1.10.233"
+            }
+        }
+    }
+    
+    # Update installation results
+    $installationResults.InstalledVersion = "5.1.10.233"
+    $executionTime = (Get-Date) - $installationStartTime
+    $installationResults.TotalExecutionSeconds = [math]::Round($executionTime.TotalSeconds, 2)
+    
+    # Check installation results
+    if ($FailedInstalls.Count -eq 0) {
+        $installationResults.InstallationStatus = "Success"
+        Write-Log "=== Cisco Secure Client Installation Completed Successfully ==="
+        
+        # Verify services per documentation (wait for services to initialize)
+        Write-Log "Waiting for services to initialize..."
+        Start-Sleep -Seconds 15
+        
+        # Expected services per installation documentation
+        $ExpectedServices = @(
+            @{Name = "csc_umbrellaagent"; DisplayName = "Cisco Secure Client - Umbrella"},
+            @{Name = "vpnagent"; DisplayName = "Cisco Secure Client Agent"},
+            @{Name = "acwebsecagent"; DisplayName = "Cisco Secure Client Web Security Agent"}
+        )
+        
+        $ServiceStatus = @()
+        $AllServicesRunning = $true
+        
+        foreach ($ServiceInfo in $ExpectedServices) {
+            $Service = Get-Service -Name $ServiceInfo.Name -ErrorAction SilentlyContinue
+            
+            if ($Service) {
+                $ServiceStatus += "$($ServiceInfo.DisplayName): $($Service.Status)"
+                Write-Log "Service $($ServiceInfo.Name) status: $($Service.Status)"
+                
+                # Try to start service if not running
+                if ($Service.Status -ne 'Running') {
+                    Write-Log "Attempting to start $($ServiceInfo.Name)..." -Level Warning
+                    try {
+                        Start-Service -Name $ServiceInfo.Name -ErrorAction Stop
+                        Start-Sleep -Seconds 5
+                        $Service = Get-Service -Name $ServiceInfo.Name
+                        Write-Log "Service $($ServiceInfo.Name) is now: $($Service.Status)"
+                    }
+                    catch {
+                        Write-Log "Failed to start $($ServiceInfo.Name): $_" -Level Warning
+                        $AllServicesRunning = $false
+                    }
+                }
+            }
+            else {
+                if ($ServiceInfo.Name -eq "vpnagent" -or $ServiceInfo.Name -eq "acwebsecagent") {
+                    Write-Log "Service $($ServiceInfo.Name) not found (expected - VPN is disabled via PRE_DEPLOY_DISABLE_VPN=1)" -Level Info
+                    $ServiceStatus += "$($ServiceInfo.DisplayName): Not Found (VPN Disabled)"
+                } else {
+                    Write-Log "Service $($ServiceInfo.Name) not found" -Level Warning
+                    $ServiceStatus += "$($ServiceInfo.DisplayName): Not Found"
+                }
+            }
+        }
+        
+        Write-Log "Service Status Summary: $($ServiceStatus -join ', ')"
+        
+        # Installation is successful even if some services aren't running immediately
+        # They may start after a reboot
+        if (-not $AllServicesRunning) {
+            Write-Log "Some services are not running. A reboot may be required." -Level Warning
+        }
+        
+        Write-Log "Installation completed. To verify Umbrella policies, visit: http://examplemalwaredomain.com"
+        
+        # Save installation marker file
+        try {
+            $markerDir = "C:\ProgramData\CiscoSecureClient"
+            $markerFile = Join-Path $markerDir "installation-results.json"
+            
+            if (-not (Test-Path $markerDir)) {
+                New-Item -Path $markerDir -ItemType Directory -Force | Out-Null
+            }
+            
+            $installationResults | ConvertTo-Json -Depth 10 | Set-Content -Path $markerFile -Encoding UTF8
+            Write-Log "Installation marker file saved to: $markerFile"
+        }
+        catch {
+            Write-Log "Failed to save installation marker file: $_" -Level Warning
+        }
+        
+        exit 0
+    }
+    else {
+        $installationResults.InstallationStatus = "Failed"
+        Write-Log "=== Installation Failed ===" -Level Error
+        Write-Log "Failed components: $($FailedInstalls -join ', ')" -Level Error
+        
+        # Save installation marker file even on failure
+        try {
+            $markerDir = "C:\ProgramData\CiscoSecureClient"
+            $markerFile = Join-Path $markerDir "installation-results.json"
+            
+            if (-not (Test-Path $markerDir)) {
+                New-Item -Path $markerDir -ItemType Directory -Force | Out-Null
+            }
+            
+            $installationResults.ErrorInfo += @{
+                ErrorMessage = "Failed to install components: $($FailedInstalls -join ', ')"
+                ErrorTimestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
+            }
+            
+            $installationResults | ConvertTo-Json -Depth 10 | Set-Content -Path $markerFile -Encoding UTF8
+            Write-Log "Installation marker file saved with failure status to: $markerFile"
+        }
+        catch {
+            Write-Log "Failed to save installation marker file: $_" -Level Warning
+        }
+        
+        exit 1
+    }
+}
+catch {
+    Write-Log "Unexpected error during installation: $_" -Level Error
+    Write-Log "Stack Trace: $($_.ScriptStackTrace)" -Level Error
+    
+    # Save installation marker file even on unexpected error
+    try {
+        $installationResults.InstallationStatus = "Error"
+        $installationResults.ErrorInfo += @{
+            ErrorMessage = $_.Exception.Message
+            ErrorType = $_.Exception.GetType().FullName
+            ErrorTimestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
+            StackTrace = $_.ScriptStackTrace
+        }
+        
+        $markerDir = "C:\ProgramData\CiscoSecureClient"
+        $markerFile = Join-Path $markerDir "installation-results.json"
+        
+        if (-not (Test-Path $markerDir)) {
+            New-Item -Path $markerDir -ItemType Directory -Force | Out-Null
+        }
+        
+        $installationResults | ConvertTo-Json -Depth 10 | Set-Content -Path $markerFile -Encoding UTF8
+        Write-Log "Installation marker file saved with error status to: $markerFile"
+    }
+    catch {
+        Write-Log "CRITICAL: Failed to save installation marker file even in error handler: $_" -Level Error
+    }
+    
+    exit 1
+}
+#endregion
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/logging/logging.psm1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/logging/logging.psm1
new file mode 100644
index 0000000..5efbcb4
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/logging/logging.psm1	
@@ -0,0 +1,825 @@
+#region Logging Function
+
+
+function Write-AppDeploymentLog {
+    [CmdletBinding()]
+    Param (
+        [Parameter(Mandatory = $true)]
+        [string]$Message,
+        [Parameter()]
+        [ValidateSet('Information', 'Warning', 'Error', 'Debug')]
+        [string]$Level = 'Information',
+        [Parameter()]
+        [ValidateSet('EnableDebug', 'SilentMode', 'Off')]
+        [string]$Mode = 'Off'
+    )
+
+    # Determine logging mode - check EnableDebug first, then parameter, then default to Off
+    $loggingMode = if ($EnableDebug) { 
+        'EnableDebug' 
+    } elseif ($Mode -ne 'Off') { 
+        $Mode 
+    } else { 
+        'Off' 
+    }
+
+    # Exit early if logging is completely disabled
+    if ($loggingMode -eq 'Off') {
+        return
+    }
+
+    # Enhanced caller information using improved logic from Write-EnhancedLog
+    $callStack = Get-PSCallStack
+    
+    # Simplified and corrected function name detection logic
+    $callerFunction = '<Unknown>'
+    if ($callStack.Count -ge 2) {
+        $caller = $callStack[1]
+        
+        # Use the same simple approach as Write-EnhancedLog that works correctly
+        if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+            # This is a function name
+            $callerFunction = $caller.Command
+        } else {
+            # This is either main script execution or a script file name - use MainScript
+            $callerFunction = 'MainScript'
+        }
+    }
+    
+    # Get parent script name
+    $parentScriptName = try {
+        Get-ParentScriptName
+    } catch {
+        "UnknownScript"
+    }
+    
+    # Get line number and script name for detailed logging
+    $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+    $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+        Split-Path -Leaf $callStack[1].ScriptName 
+    } else { 
+        $parentScriptName 
+    }
+
+    # Create enhanced caller information combining both approaches
+    $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+    $detailedCallerInfo = "[$scriptFileName`:$lineNumber $callerFunction]"
+
+    $timeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $fileLogMessage = "[$timeStamp] [$Level] $enhancedCallerInfo - $Message"
+    $consoleLogMessage = "[$Level] $enhancedCallerInfo - $Message" # No timestamp for console
+
+    #region Local File Logging
+    # Skip all file logging if DisableFileLogging is set
+    if ($script:DisableFileLogging) {
+        return
+    }
+    
+    # Use session-based paths if available, otherwise fall back to per-call generation
+    if ($script:SessionLogFilePath -and $script:SessionFullLogDirectory) {
+        $logFilePath = $script:SessionLogFilePath
+        $logDirectory = $script:SessionFullLogDirectory
+    } else {
+        # Fallback to old method if session variables aren't set
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        $logDirectory = "C:\ProgramData\CiscoSecureClient\Logs"
+        $fullLogDirectory = Join-Path -Path $logDirectory -ChildPath $dateFolder
+        $fullLogDirectory = Join-Path -Path $fullLogDirectory -ChildPath $parentScriptName
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.log"
+        $logFilePath = Join-Path -Path $fullLogDirectory -ChildPath $logFileName
+        $logDirectory = $fullLogDirectory
+    }
+    
+    if (-not (Test-Path -Path $logDirectory)) {
+        New-Item -ItemType Directory -Path $logDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+    }
+    
+    if (Test-Path -Path $logDirectory) {
+        Add-Content -Path $logFilePath -Value $fileLogMessage -ErrorAction SilentlyContinue
+        
+        # Log rotation for local files (keep max 7 files)
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $logFiles = Get-ChildItem -Path $logDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.log" | Sort-Object LastWriteTime -Descending
+            if ($logFiles.Count -gt 7) {
+                $filesToRemove = $logFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for log rotation
+        }
+    }
+    #endregion Local File Logging
+
+    #region Network Share CSV Logging
+    # Network logging: Only save CSV format logs under a parent job folder for better organization
+    try {
+        $hostname = $env:COMPUTERNAME
+        $jobName = "CiscoSecureClient"  # Parent job folder name
+        $networkBasePath = "\\AZR1PSCCM02\.logs\$jobName\$hostname"
+        
+        # Test network connectivity first
+        $networkAvailable = Test-Path "\\AZR1PSCCM02\.logs" -ErrorAction SilentlyContinue
+        
+        if ($networkAvailable) {
+            # Use session-based paths if available
+            if ($script:SessionDateFolder -and $script:SessionParentScript -and $script:SessionCSVFileName) {
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $script:SessionDateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionParentScript
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionCSVFileName
+            } else {
+                # Fallback method
+                $dateFolder = Get-Date -Format "yyyy-MM-dd"
+                $parentScriptName = Get-ParentScriptName
+                $userContext = Get-CurrentUser
+                $callingScript = Get-CallingScriptName
+                $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+                
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $dateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $parentScriptName
+                $networkCSVFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $networkCSVFileName
+            }
+            
+            if (-not (Test-Path -Path $fullNetworkCSVPath)) {
+                New-Item -ItemType Directory -Path $fullNetworkCSVPath -Force -ErrorAction SilentlyContinue | Out-Null
+            }
+            
+            if (Test-Path -Path $fullNetworkCSVPath) {
+                # Create CSV entry for network logging
+                $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+                $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+                $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+                
+                # Get caller information
+                $callStack = Get-PSCallStack
+                $callerFunction = '<Unknown>'
+                if ($callStack.Count -ge 2) {
+                    $caller = $callStack[1]
+                    if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+                        $callerFunction = $caller.Command
+                    } else {
+                        $callerFunction = 'MainScript'
+                    }
+                }
+                
+                $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+                $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+                    Split-Path -Leaf $callStack[1].ScriptName 
+                } else { 
+                    $parentScriptName 
+                }
+                
+                $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+                
+                $networkCSVEntry = [PSCustomObject]@{
+                    Timestamp       = $timeStamp
+                    Level           = $Level
+                    ParentScript    = $parentScriptName
+                    CallingScript   = $callingScript
+                    ScriptName      = $scriptFileName
+                    FunctionName    = $callerFunction
+                    LineNumber      = $lineNumber
+                    Message         = $Message
+                    Hostname        = $env:COMPUTERNAME
+                    UserType        = $userContext.UserType
+                    UserName        = $userContext.UserName
+                    FullUserContext = $userContext.FullUserContext
+                    CallerInfo      = $enhancedCallerInfo
+                    JobName         = $jobName
+                    LogType         = "NetworkCSV"
+                }
+                
+                # Check if network CSV exists, if not create with headers
+                if (-not (Test-Path -Path $networkCSVFile)) {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -ErrorAction SilentlyContinue
+                } else {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -Append -ErrorAction SilentlyContinue
+                }
+                
+                # Network CSV log rotation (keep max 5 files per machine per script)
+                try {
+                    $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+                    $networkCSVFiles = Get-ChildItem -Path $fullNetworkCSVPath -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+                    if ($networkCSVFiles.Count -gt 5) {
+                        $filesToRemove = $networkCSVFiles | Select-Object -Skip 5
+                        foreach ($file in $filesToRemove) {
+                            Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                        }
+                    }
+                }
+                catch {
+                    # Silent error handling for network CSV log rotation
+                }
+            }
+        }
+    }
+    catch {
+        # Silent error handling for network CSV logging - don't interfere with main script
+    }
+    #endregion Network Share CSV Logging
+
+    #region CSV Logging
+    try {
+        # Use session-based paths if available
+        if ($script:SessionCSVFilePath -and $script:SessionFullCSVDirectory) {
+            $csvLogPath = $script:SessionCSVFilePath
+            $csvDirectory = $script:SessionFullCSVDirectory
+        } else {
+            # Fallback method
+            $userContext = Get-CurrentUser
+            $callingScript = Get-CallingScriptName
+            $parentScriptName = Get-ParentScriptName
+            $dateFolder = Get-Date -Format "yyyy-MM-dd"
+            $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+            
+            $csvLogDirectory = "C:\ProgramData\CiscoSecureClient\Logs\CSV"
+            $fullCSVDirectory = Join-Path -Path $csvLogDirectory -ChildPath $dateFolder
+            $fullCSVDirectory = Join-Path -Path $fullCSVDirectory -ChildPath $parentScriptName
+            $csvFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+            $csvLogPath = Join-Path -Path $fullCSVDirectory -ChildPath $csvFileName
+            $csvDirectory = $fullCSVDirectory
+        }
+        
+        if (-not (Test-Path -Path $csvDirectory)) {
+            New-Item -ItemType Directory -Path $csvDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+        }
+        
+        # Use session context if available, otherwise get fresh context
+        $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+        $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+        $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+        
+        $csvEntry = [PSCustomObject]@{
+            Timestamp       = $timeStamp
+            Level           = $Level
+            ParentScript    = $parentScriptName
+            CallingScript   = $callingScript
+            ScriptName      = $scriptFileName
+            FunctionName    = $callerFunction
+            LineNumber      = $lineNumber
+            Message         = $Message
+            Hostname        = $env:COMPUTERNAME
+            UserType        = $userContext.UserType
+            UserName        = $userContext.UserName
+            FullUserContext = $userContext.FullUserContext
+            CallerInfo      = $enhancedCallerInfo
+        }
+        
+        # Check if CSV exists, if not create with headers
+        if (-not (Test-Path -Path $csvLogPath)) {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -ErrorAction SilentlyContinue
+        } else {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -Append -ErrorAction SilentlyContinue
+        }
+        
+        # CSV log rotation
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $csvFiles = Get-ChildItem -Path $csvDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+            if ($csvFiles.Count -gt 7) {
+                $filesToRemove = $csvFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for CSV log rotation
+        }
+    }
+    catch {
+        # Silent error handling for CSV logging
+    }
+    #endregion CSV Logging
+
+    #region Console Output (only in EnableDebug mode)
+    if ($loggingMode -eq 'EnableDebug') {
+        switch ($Level.ToUpper()) {
+            'ERROR' { Write-Host $consoleLogMessage -ForegroundColor Red }
+            'WARNING' { Write-Host $consoleLogMessage -ForegroundColor Yellow }
+            'INFORMATION' { Write-Host $consoleLogMessage -ForegroundColor White }
+            'DEBUG' { Write-Host $consoleLogMessage -ForegroundColor Gray }
+        }
+    }
+    #endregion Console Output
+}
+
+function Write-EnhancedLog {
+    [CmdletBinding()]
+    param (
+        [string]$Message,
+        [string]$Level = 'INFO',
+        [string]$LoggingMode = 'SilentMode'
+    )
+
+    # Get the PowerShell call stack to determine the actual calling function
+    $callStack = Get-PSCallStack
+    $callerFunction = if ($callStack.Count -ge 2) { $callStack[1].Command } else { '<Unknown>' }
+
+    # Get the parent script name
+    $parentScriptName = Get-ParentScriptName
+
+    # Map enhanced log levels to CiscoApp log levels
+    $mappedLevel = switch ($Level.ToUpper()) {
+        'CRITICAL' { 'Error' }
+        'ERROR'    { 'Error' }
+        'WARNING'  { 'Warning' }
+        'INFO'     { 'Information' }
+        'DEBUG'    { 'Debug' }
+        'NOTICE'   { 'Information' }
+        'IMPORTANT' { 'Information' }
+        'OUTPUT'   { 'Information' }
+        'SIGNIFICANT' { 'Information' }
+        'VERBOSE'  { 'Debug' }
+        'VERYVERBOSE' { 'Debug' }
+        'SOMEWHATVERBOSE' { 'Debug' }
+        'SYSTEM'   { 'Information' }
+        'INTERNALCOMMENT' { 'Debug' }
+        default    { 'Information' }
+    }
+
+    # Format message with caller information
+    $formattedMessage = "[$parentScriptName.$callerFunction] $Message"
+
+    # Use the existing Write-AppDeploymentLog function
+    Write-AppDeploymentLog -Message $formattedMessage -Level $mappedLevel -Mode $LoggingMode
+}
+
+#region Helper Functions
+
+
+#region Error Handling
+function Handle-Error {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [System.Management.Automation.ErrorRecord]$ErrorRecord,
+        [string]$CustomMessage = "",
+        [string]$LoggingMode = "SilentMode"
+    )
+
+    try {
+        if ($PSVersionTable.PSVersion.Major -ge 7) {
+            $fullErrorDetails = Get-Error -InputObject $ErrorRecord | Out-String
+        } else {
+            $fullErrorDetails = $ErrorRecord.Exception | Format-List * -Force | Out-String
+        }
+
+        $errorMessage = if ($CustomMessage) {
+            "$CustomMessage - Exception: $($ErrorRecord.Exception.Message)"
+        } else {
+            "Exception Message: $($ErrorRecord.Exception.Message)"
+        }
+
+        Write-AppDeploymentLog -Message $errorMessage -Level Error -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Full Exception Details: $fullErrorDetails" -Level Debug -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Script Line Number: $($ErrorRecord.InvocationInfo.ScriptLineNumber)" -Level Debug -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Position Message: $($ErrorRecord.InvocationInfo.PositionMessage)" -Level Debug -Mode $LoggingMode
+    } 
+    catch {
+        # Fallback error handling in case of an unexpected error in the try block
+        Write-AppDeploymentLog -Message "An error occurred while handling another error. Original Exception: $($ErrorRecord.Exception.Message)" -Level Error -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Handler Exception: $($_.Exception.Message)" -Level Error -Mode $LoggingMode
+    }
+}
+#endregion Error Handling
+
+function Get-ParentScriptName {
+    [CmdletBinding()]
+    param ()
+
+    try {
+        # Get the current call stack
+        $callStack = Get-PSCallStack
+
+        # If there is a call stack, return the top-most script name
+        if ($callStack.Count -gt 0) {
+            foreach ($frame in $callStack) {
+                if ($frame.ScriptName) {
+                    $parentScriptName = $frame.ScriptName
+                    # Write-EnhancedLog -Message "Found script in call stack: $parentScriptName" -Level "INFO"
+                }
+            }
+
+            if (-not [string]::IsNullOrEmpty($parentScriptName)) {
+                $parentScriptName = [System.IO.Path]::GetFileNameWithoutExtension($parentScriptName)
+                return $parentScriptName
+            }
+        }
+
+        # If no script name was found, return 'UnknownScript'
+        Write-EnhancedLog -Message "No script name found in the call stack." -Level "WARNING"
+        return "UnknownScript"
+    }
+    catch {
+        Write-EnhancedLog -Message "An error occurred while retrieving the parent script name: $_" -Level "ERROR"
+        return "UnknownScript"
+    }
+}
+
+function Get-CurrentUser {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the current user context
+        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
+        $computerName = $env:COMPUTERNAME
+        
+        # Check if running as SYSTEM
+        if ($currentUser -like "*SYSTEM*" -or $currentUser -eq "NT AUTHORITY\SYSTEM") {
+            return @{
+                UserType = "SYSTEM"
+                UserName = "LocalSystem"
+                ComputerName = $computerName
+                FullUserContext = "SYSTEM-LocalSystem"
+            }
+        }
+        
+        # Extract domain and username
+        if ($currentUser.Contains('\')) {
+            $domain = $currentUser.Split('\')[0]
+            $userName = $currentUser.Split('\')[1]
+        } else {
+            $domain = $env:USERDOMAIN
+            $userName = $currentUser
+        }
+        
+        # Determine user type based on group membership
+        $userType = "User"
+        try {
+            $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
+            if ($isAdmin) {
+                $userType = "Admin"
+            }
+        }
+        catch {
+            # If we can't determine admin status, default to User
+            $userType = "User"
+        }
+        
+        # Sanitize names for file naming (remove invalid characters)
+        $userName = $userName -replace '[<>:"/\\|?*]', '_'
+        $userType = $userType -replace '[<>:"/\\|?*]', '_'
+        
+        return @{
+            UserType = $userType
+            UserName = $userName
+            ComputerName = $computerName
+            FullUserContext = "$userType-$userName"
+        }
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to get current user context: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        return @{
+            UserType = "Unknown"
+            UserName = "UnknownUser"
+            ComputerName = $env:COMPUTERNAME
+            FullUserContext = "Unknown-UnknownUser"
+        }
+    }
+}
+
+function Get-CallingScriptName {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the call stack
+        $callStack = Get-PSCallStack
+        
+        # Look for the actual calling script (not this script or logging functions)
+        $callingScript = "UnknownCaller"
+        
+        # Skip internal logging functions and Discovery script itself
+        $skipFunctions = @('Write-AppDeploymentLog', 'Write-EnhancedLog', 'Handle-Error', 'Get-CallingScriptName', 'Get-CurrentUser')
+        $skipScripts = @('Discovery', 'Discovery.ps1')
+        
+        # Start from index 1 to skip the current function
+        for ($i = 1; $i -lt $callStack.Count; $i++) {
+            $frame = $callStack[$i]
+            
+            # Check if this frame should be skipped
+            $shouldSkip = $false
+            
+            # Skip if it's one of our internal functions
+            if ($frame.Command -and $frame.Command -in $skipFunctions) {
+                $shouldSkip = $true
+            }
+            
+            # Skip if it's the Discovery script itself
+            if ($frame.ScriptName) {
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                if ($scriptName -in $skipScripts) {
+                    $shouldSkip = $true
+                }
+            }
+            
+            # If we shouldn't skip this frame, use it
+            if (-not $shouldSkip) {
+                if ($frame.ScriptName) {
+                    $callingScript = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                    break
+                }
+                elseif ($frame.Command -and $frame.Command -ne "<ScriptBlock>") {
+                    $callingScript = $frame.Command
+                    break
+                }
+            }
+        }
+        
+        # If we still haven't found a caller, determine the execution context
+        if ($callingScript -eq "UnknownCaller") {
+            # Check execution context
+            if ($callStack.Count -le 3) {
+                # Very short call stack suggests direct execution
+                $callingScript = "DirectExecution"
+            }
+            elseif ($MyInvocation.InvocationName -and $MyInvocation.InvocationName -ne "Get-CallingScriptName") {
+                # Use the invocation name if available
+                $callingScript = $MyInvocation.InvocationName
+            }
+            elseif ($PSCommandPath) {
+                # Check if we have a command path (script execution)
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($PSCommandPath)
+                if ($scriptName -and $scriptName -notin $skipScripts) {
+                    $callingScript = $scriptName
+                } else {
+                    $callingScript = "PowerShellExecution"
+                }
+            }
+            else {
+                # Check the host name to determine execution context
+                $hostName = $Host.Name
+                switch ($hostName) {
+                    "ConsoleHost" { $callingScript = "PowerShellConsole" }
+                    "Windows PowerShell ISE Host" { $callingScript = "PowerShell_ISE" }
+                    "ServerRemoteHost" { $callingScript = "RemoteExecution" }
+                    "Visual Studio Code Host" { $callingScript = "VSCode" }
+                    default { $callingScript = "PowerShellHost-$hostName" }
+                }
+            }
+        }
+        
+        return $callingScript
+    }
+    catch {
+        # In case of any error, provide a meaningful fallback
+        try {
+            $hostName = $Host.Name
+            return "ErrorFallback-$hostName"
+        }
+        catch {
+            return "ErrorFallback-Unknown"
+        }
+    }
+}
+
+
+#region Transcript Management Functions
+function Start-CiscoAppTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LogDirectory = "C:\ProgramData\CiscoSecureClient\Logs",
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-AppDeploymentLog -Message "Transcript not started - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $null
+        }
+        
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create directory structure: Logs/Transcript/{Date}/{ParentScript}
+        $transcriptDirectory = Join-Path -Path $LogDirectory -ChildPath "Transcript"
+        $fullTranscriptDirectory = Join-Path -Path $transcriptDirectory -ChildPath $dateFolder
+        $fullTranscriptDirectory = Join-Path -Path $fullTranscriptDirectory -ChildPath $parentScriptName
+        
+        if (-not (Test-Path -Path $fullTranscriptDirectory)) {
+            New-Item -ItemType Directory -Path $fullTranscriptDirectory -Force | Out-Null
+        }
+        
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        $transcriptPath = Join-Path -Path $fullTranscriptDirectory -ChildPath $transcriptFileName
+        
+        # Start transcript with error handling and suppress all console output
+        try {
+            Start-Transcript -Path $transcriptPath -ErrorAction Stop | Out-Null
+            Write-AppDeploymentLog -Message "Transcript started successfully at: $transcriptPath" -Level Information -Mode $LoggingMode
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Failed to start transcript at $transcriptPath" -LoggingMode $LoggingMode
+            return $null
+        }
+        
+        # Transcript rotation
+        try {
+            $transcriptFiles = Get-ChildItem -Path $fullTranscriptDirectory -Filter "*-*-*-*-$parentScriptName-transcript*.log" | Sort-Object LastWriteTime -Descending
+            if ($transcriptFiles.Count -gt 7) {
+                $filesToRemove = $transcriptFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                    Write-AppDeploymentLog -Message "Removed old transcript file: $($file.FullName)" -Level Debug -Mode $LoggingMode
+                }
+            }
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error during transcript file rotation" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptPath
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Start-CiscoAppTranscript function" -LoggingMode $LoggingMode
+        return $null
+    }
+}
+
+function Stop-CiscoAppTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-AppDeploymentLog -Message "Transcript not stopped - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $false
+        }
+        
+        # Check if transcript is running before attempting to stop
+        $transcriptRunning = $false
+        try {
+            # Try to stop transcript and suppress all console output
+            Stop-Transcript -ErrorAction Stop | Out-Null
+            $transcriptRunning = $true
+            Write-AppDeploymentLog -Message "Transcript stopped successfully." -Level Information -Mode $LoggingMode
+        }
+        catch [System.InvalidOperationException] {
+            # This is expected if no transcript is running
+            Write-AppDeploymentLog -Message "No active transcript to stop." -Level Debug -Mode $LoggingMode
+        }
+        catch {
+            # Other transcript-related errors
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error stopping transcript" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptRunning
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Stop-CiscoAppTranscript function" -LoggingMode $LoggingMode
+        return $false
+    }
+}
+
+function Get-TranscriptFilePath {
+    [CmdletBinding()]
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$TranscriptsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+    
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: Transcript/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+        
+        # Generate timestamp for unique transcript file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the transcript file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-transcript-{Timestamp}.log
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        
+        # Combine the full path
+        $transcriptFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $transcriptFileName
+        
+        return $transcriptFilePath
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to generate transcript file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-fallback-$timestamp.log"
+    }
+}
+#endregion Transcript Management Functions
+function Get-CSVLogFilePath {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [string]$LogsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: PSF/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+
+        # Generate timestamp for unique log file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the log file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-log-{Timestamp}.csv
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-$timestamp.csv"
+        
+        # Combine the full path
+        $csvLogFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $logFileName
+        
+        return $csvLogFilePath
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to generate CSV log file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-fallback-$timestamp.csv"
+    }
+}
+
+
+
+
+#endregion Helper Functions
+
+
+#endregion Logging Function
+
+# Export module members
+Export-ModuleMember -Function @(
+    'Write-AppDeploymentLog',
+    'Write-EnhancedLog',
+    'Handle-Error',
+    'Get-ParentScriptName',
+    'Get-CurrentUser',
+    'Get-CallingScriptName',
+    'Start-CiscoAppTranscript',
+    'Stop-CiscoAppTranscript',
+    'Get-TranscriptFilePath',
+    'Get-CSVLogFilePath'
+)
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/logging/logging.psm1.backup b/Win32Apps-Gallery/Cisco/Cisco Secure Client/logging/logging.psm1.backup
new file mode 100644
index 0000000..953bc10
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/logging/logging.psm1.backup	
@@ -0,0 +1,811 @@
+#region Logging Function
+
+
+function Write-ActiveBarVulnLog {
+    [CmdletBinding()]
+    Param (
+        [Parameter(Mandatory = $true)]
+        [string]$Message,
+        [Parameter()]
+        [ValidateSet('Information', 'Warning', 'Error', 'Debug')]
+        [string]$Level = 'Information',
+        [Parameter()]
+        [ValidateSet('EnableDebug', 'SilentMode', 'Off')]
+        [string]$Mode = 'Off'
+    )
+
+    # Determine logging mode - check EnableDebug first, then parameter, then default to Off
+    $loggingMode = if ($EnableDebug) { 
+        'EnableDebug' 
+    } elseif ($Mode -ne 'Off') { 
+        $Mode 
+    } else { 
+        'Off' 
+    }
+
+    # Exit early if logging is completely disabled
+    if ($loggingMode -eq 'Off') {
+        return
+    }
+
+    # Enhanced caller information using improved logic from Write-EnhancedLog
+    $callStack = Get-PSCallStack
+    
+    # Simplified and corrected function name detection logic
+    $callerFunction = '<Unknown>'
+    if ($callStack.Count -ge 2) {
+        $caller = $callStack[1]
+        
+        # Use the same simple approach as Write-EnhancedLog that works correctly
+        if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+            # This is a function name
+            $callerFunction = $caller.Command
+        } else {
+            # This is either main script execution or a script file name - use MainScript
+            $callerFunction = 'MainScript'
+        }
+    }
+    
+    # Get parent script name
+    $parentScriptName = try {
+        Get-ParentScriptName
+    } catch {
+        "UnknownScript"
+    }
+    
+    # Get line number and script name for detailed logging
+    $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+    $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+        Split-Path -Leaf $callStack[1].ScriptName 
+    } else { 
+        $parentScriptName 
+    }
+
+    # Create enhanced caller information combining both approaches
+    $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+    $detailedCallerInfo = "[$scriptFileName`:$lineNumber $callerFunction]"
+
+    $timeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $fileLogMessage = "[$timeStamp] [$Level] $enhancedCallerInfo - $Message"
+    $consoleLogMessage = "[$Level] $enhancedCallerInfo - $Message" # No timestamp for console
+
+    #region Local File Logging
+    # Skip all file logging if DisableFileLogging is set
+    if ($script:DisableFileLogging) {
+        return
+    }
+    
+    # Use session-based paths if available, otherwise fall back to per-call generation
+    if ($script:SessionLogFilePath -and $script:SessionFullLogDirectory) {
+        $logFilePath = $script:SessionLogFilePath
+        $logDirectory = $script:SessionFullLogDirectory
+    } else {
+        # Fallback to old method if session variables aren't set
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        $logDirectory = "C:\ProgramData\ActiveBarVuln\Logs"
+        $fullLogDirectory = Join-Path -Path $logDirectory -ChildPath $dateFolder
+        $fullLogDirectory = Join-Path -Path $fullLogDirectory -ChildPath $parentScriptName
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.log"
+        $logFilePath = Join-Path -Path $fullLogDirectory -ChildPath $logFileName
+        $logDirectory = $fullLogDirectory
+    }
+    
+    if (-not (Test-Path -Path $logDirectory)) {
+        New-Item -ItemType Directory -Path $logDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+    }
+    
+    if (Test-Path -Path $logDirectory) {
+        Add-Content -Path $logFilePath -Value $fileLogMessage -ErrorAction SilentlyContinue
+        
+        # Log rotation for local files (keep max 7 files)
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $logFiles = Get-ChildItem -Path $logDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.log" | Sort-Object LastWriteTime -Descending
+            if ($logFiles.Count -gt 7) {
+                $filesToRemove = $logFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for log rotation
+        }
+    }
+    #endregion Local File Logging
+
+    #region Network Share CSV Logging
+    # Network logging: Only save CSV format logs under a parent job folder for better organization
+    try {
+        $hostname = $env:COMPUTERNAME
+        $jobName = "ActiveBarVuln"  # Parent job folder name
+        $networkBasePath = "\\AZR1PSCCM02\.logs\$jobName\$hostname"
+        
+        # Test network connectivity first
+        $networkAvailable = Test-Path "\\AZR1PSCCM02\.logs" -ErrorAction SilentlyContinue
+        
+        if ($networkAvailable) {
+            # Use session-based paths if available
+            if ($script:SessionDateFolder -and $script:SessionParentScript -and $script:SessionCSVFileName) {
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $script:SessionDateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionParentScript
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionCSVFileName
+            } else {
+                # Fallback method
+                $dateFolder = Get-Date -Format "yyyy-MM-dd"
+                $parentScriptName = Get-ParentScriptName
+                $userContext = Get-CurrentUser
+                $callingScript = Get-CallingScriptName
+                $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+                
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $dateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $parentScriptName
+                $networkCSVFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $networkCSVFileName
+            }
+            
+            if (-not (Test-Path -Path $fullNetworkCSVPath)) {
+                New-Item -ItemType Directory -Path $fullNetworkCSVPath -Force -ErrorAction SilentlyContinue | Out-Null
+            }
+            
+            if (Test-Path -Path $fullNetworkCSVPath) {
+                # Create CSV entry for network logging
+                $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+                $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+                $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+                
+                # Get caller information
+                $callStack = Get-PSCallStack
+                $callerFunction = '<Unknown>'
+                if ($callStack.Count -ge 2) {
+                    $caller = $callStack[1]
+                    if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+                        $callerFunction = $caller.Command
+                    } else {
+                        $callerFunction = 'MainScript'
+                    }
+                }
+                
+                $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+                $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+                    Split-Path -Leaf $callStack[1].ScriptName 
+                } else { 
+                    $parentScriptName 
+                }
+                
+                $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+                
+                $networkCSVEntry = [PSCustomObject]@{
+                    Timestamp       = $timeStamp
+                    Level           = $Level
+                    ParentScript    = $parentScriptName
+                    CallingScript   = $callingScript
+                    ScriptName      = $scriptFileName
+                    FunctionName    = $callerFunction
+                    LineNumber      = $lineNumber
+                    Message         = $Message
+                    Hostname        = $env:COMPUTERNAME
+                    UserType        = $userContext.UserType
+                    UserName        = $userContext.UserName
+                    FullUserContext = $userContext.FullUserContext
+                    CallerInfo      = $enhancedCallerInfo
+                    JobName         = $jobName
+                    LogType         = "NetworkCSV"
+                }
+                
+                # Check if network CSV exists, if not create with headers
+                if (-not (Test-Path -Path $networkCSVFile)) {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -ErrorAction SilentlyContinue
+                } else {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -Append -ErrorAction SilentlyContinue
+                }
+                
+                # Network CSV log rotation (keep max 5 files per machine per script)
+                try {
+                    $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+                    $networkCSVFiles = Get-ChildItem -Path $fullNetworkCSVPath -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+                    if ($networkCSVFiles.Count -gt 5) {
+                        $filesToRemove = $networkCSVFiles | Select-Object -Skip 5
+                        foreach ($file in $filesToRemove) {
+                            Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                        }
+                    }
+                }
+                catch {
+                    # Silent error handling for network CSV log rotation
+                }
+            }
+        }
+    }
+    catch {
+        # Silent error handling for network CSV logging - don't interfere with main script
+    }
+    #endregion Network Share CSV Logging
+
+    #region CSV Logging
+    try {
+        # Use session-based paths if available
+        if ($script:SessionCSVFilePath -and $script:SessionFullCSVDirectory) {
+            $csvLogPath = $script:SessionCSVFilePath
+            $csvDirectory = $script:SessionFullCSVDirectory
+        } else {
+            # Fallback method
+            $userContext = Get-CurrentUser
+            $callingScript = Get-CallingScriptName
+            $parentScriptName = Get-ParentScriptName
+            $dateFolder = Get-Date -Format "yyyy-MM-dd"
+            $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+            
+            $csvLogDirectory = "C:\ProgramData\ActiveBarVuln\Logs\CSV"
+            $fullCSVDirectory = Join-Path -Path $csvLogDirectory -ChildPath $dateFolder
+            $fullCSVDirectory = Join-Path -Path $fullCSVDirectory -ChildPath $parentScriptName
+            $csvFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+            $csvLogPath = Join-Path -Path $fullCSVDirectory -ChildPath $csvFileName
+            $csvDirectory = $fullCSVDirectory
+        }
+        
+        if (-not (Test-Path -Path $csvDirectory)) {
+            New-Item -ItemType Directory -Path $csvDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+        }
+        
+        # Use session context if available, otherwise get fresh context
+        $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+        $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+        $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+        
+        $csvEntry = [PSCustomObject]@{
+            Timestamp       = $timeStamp
+            Level           = $Level
+            ParentScript    = $parentScriptName
+            CallingScript   = $callingScript
+            ScriptName      = $scriptFileName
+            FunctionName    = $callerFunction
+            LineNumber      = $lineNumber
+            Message         = $Message
+            Hostname        = $env:COMPUTERNAME
+            UserType        = $userContext.UserType
+            UserName        = $userContext.UserName
+            FullUserContext = $userContext.FullUserContext
+            CallerInfo      = $enhancedCallerInfo
+        }
+        
+        # Check if CSV exists, if not create with headers
+        if (-not (Test-Path -Path $csvLogPath)) {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -ErrorAction SilentlyContinue
+        } else {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -Append -ErrorAction SilentlyContinue
+        }
+        
+        # CSV log rotation
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $csvFiles = Get-ChildItem -Path $csvDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+            if ($csvFiles.Count -gt 7) {
+                $filesToRemove = $csvFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for CSV log rotation
+        }
+    }
+    catch {
+        # Silent error handling for CSV logging
+    }
+    #endregion CSV Logging
+
+    #region Console Output (only in EnableDebug mode)
+    if ($loggingMode -eq 'EnableDebug') {
+        switch ($Level.ToUpper()) {
+            'ERROR' { Write-Host $consoleLogMessage -ForegroundColor Red }
+            'WARNING' { Write-Host $consoleLogMessage -ForegroundColor Yellow }
+            'INFORMATION' { Write-Host $consoleLogMessage -ForegroundColor White }
+            'DEBUG' { Write-Host $consoleLogMessage -ForegroundColor Gray }
+        }
+    }
+    #endregion Console Output
+}
+
+function Write-EnhancedLog {
+    [CmdletBinding()]
+    param (
+        [string]$Message,
+        [string]$Level = 'INFO',
+        [string]$LoggingMode = 'SilentMode'
+    )
+
+    # Get the PowerShell call stack to determine the actual calling function
+    $callStack = Get-PSCallStack
+    $callerFunction = if ($callStack.Count -ge 2) { $callStack[1].Command } else { '<Unknown>' }
+
+    # Get the parent script name
+    $parentScriptName = Get-ParentScriptName
+
+    # Map enhanced log levels to ActiveBar log levels
+    $mappedLevel = switch ($Level.ToUpper()) {
+        'CRITICAL' { 'Error' }
+        'ERROR'    { 'Error' }
+        'WARNING'  { 'Warning' }
+        'INFO'     { 'Information' }
+        'DEBUG'    { 'Debug' }
+        'NOTICE'   { 'Information' }
+        'IMPORTANT' { 'Information' }
+        'OUTPUT'   { 'Information' }
+        'SIGNIFICANT' { 'Information' }
+        'VERBOSE'  { 'Debug' }
+        'VERYVERBOSE' { 'Debug' }
+        'SOMEWHATVERBOSE' { 'Debug' }
+        'SYSTEM'   { 'Information' }
+        'INTERNALCOMMENT' { 'Debug' }
+        default    { 'Information' }
+    }
+
+    # Format message with caller information
+    $formattedMessage = "[$parentScriptName.$callerFunction] $Message"
+
+    # Use the existing Write-ActiveBarVulnLog function
+    Write-ActiveBarVulnLog -Message $formattedMessage -Level $mappedLevel -Mode $LoggingMode
+}
+
+#region Helper Functions
+
+
+#region Error Handling
+function Handle-Error {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [System.Management.Automation.ErrorRecord]$ErrorRecord,
+        [string]$CustomMessage = "",
+        [string]$LoggingMode = "SilentMode"
+    )
+
+    try {
+        if ($PSVersionTable.PSVersion.Major -ge 7) {
+            $fullErrorDetails = Get-Error -InputObject $ErrorRecord | Out-String
+        } else {
+            $fullErrorDetails = $ErrorRecord.Exception | Format-List * -Force | Out-String
+        }
+
+        $errorMessage = if ($CustomMessage) {
+            "$CustomMessage - Exception: $($ErrorRecord.Exception.Message)"
+        } else {
+            "Exception Message: $($ErrorRecord.Exception.Message)"
+        }
+
+        Write-ActiveBarVulnLog -Message $errorMessage -Level Error -Mode $LoggingMode
+        Write-ActiveBarVulnLog -Message "Full Exception Details: $fullErrorDetails" -Level Debug -Mode $LoggingMode
+        Write-ActiveBarVulnLog -Message "Script Line Number: $($ErrorRecord.InvocationInfo.ScriptLineNumber)" -Level Debug -Mode $LoggingMode
+        Write-ActiveBarVulnLog -Message "Position Message: $($ErrorRecord.InvocationInfo.PositionMessage)" -Level Debug -Mode $LoggingMode
+    } 
+    catch {
+        # Fallback error handling in case of an unexpected error in the try block
+        Write-ActiveBarVulnLog -Message "An error occurred while handling another error. Original Exception: $($ErrorRecord.Exception.Message)" -Level Error -Mode $LoggingMode
+        Write-ActiveBarVulnLog -Message "Handler Exception: $($_.Exception.Message)" -Level Error -Mode $LoggingMode
+    }
+}
+#endregion Error Handling
+
+function Get-ParentScriptName {
+    [CmdletBinding()]
+    param ()
+
+    try {
+        # Get the current call stack
+        $callStack = Get-PSCallStack
+
+        # If there is a call stack, return the top-most script name
+        if ($callStack.Count -gt 0) {
+            foreach ($frame in $callStack) {
+                if ($frame.ScriptName) {
+                    $parentScriptName = $frame.ScriptName
+                    # Write-EnhancedLog -Message "Found script in call stack: $parentScriptName" -Level "INFO"
+                }
+            }
+
+            if (-not [string]::IsNullOrEmpty($parentScriptName)) {
+                $parentScriptName = [System.IO.Path]::GetFileNameWithoutExtension($parentScriptName)
+                return $parentScriptName
+            }
+        }
+
+        # If no script name was found, return 'UnknownScript'
+        Write-EnhancedLog -Message "No script name found in the call stack." -Level "WARNING"
+        return "UnknownScript"
+    }
+    catch {
+        Write-EnhancedLog -Message "An error occurred while retrieving the parent script name: $_" -Level "ERROR"
+        return "UnknownScript"
+    }
+}
+
+function Get-CurrentUser {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the current user context
+        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
+        $computerName = $env:COMPUTERNAME
+        
+        # Check if running as SYSTEM
+        if ($currentUser -like "*SYSTEM*" -or $currentUser -eq "NT AUTHORITY\SYSTEM") {
+            return @{
+                UserType = "SYSTEM"
+                UserName = "LocalSystem"
+                ComputerName = $computerName
+                FullUserContext = "SYSTEM-LocalSystem"
+            }
+        }
+        
+        # Extract domain and username
+        if ($currentUser.Contains('\')) {
+            $domain = $currentUser.Split('\')[0]
+            $userName = $currentUser.Split('\')[1]
+        } else {
+            $domain = $env:USERDOMAIN
+            $userName = $currentUser
+        }
+        
+        # Determine user type based on group membership
+        $userType = "User"
+        try {
+            $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
+            if ($isAdmin) {
+                $userType = "Admin"
+            }
+        }
+        catch {
+            # If we can't determine admin status, default to User
+            $userType = "User"
+        }
+        
+        # Sanitize names for file naming (remove invalid characters)
+        $userName = $userName -replace '[<>:"/\\|?*]', '_'
+        $userType = $userType -replace '[<>:"/\\|?*]', '_'
+        
+        return @{
+            UserType = $userType
+            UserName = $userName
+            ComputerName = $computerName
+            FullUserContext = "$userType-$userName"
+        }
+    }
+    catch {
+        Write-ActiveBarVulnLog -Message "Failed to get current user context: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        return @{
+            UserType = "Unknown"
+            UserName = "UnknownUser"
+            ComputerName = $env:COMPUTERNAME
+            FullUserContext = "Unknown-UnknownUser"
+        }
+    }
+}
+
+function Get-CallingScriptName {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the call stack
+        $callStack = Get-PSCallStack
+        
+        # Look for the actual calling script (not this script or logging functions)
+        $callingScript = "UnknownCaller"
+        
+        # Skip internal logging functions and Discovery script itself
+        $skipFunctions = @('Write-ActiveBarVulnLog', 'Write-EnhancedLog', 'Handle-Error', 'Get-CallingScriptName', 'Get-CurrentUser')
+        $skipScripts = @('Discovery', 'Discovery.ps1')
+        
+        # Start from index 1 to skip the current function
+        for ($i = 1; $i -lt $callStack.Count; $i++) {
+            $frame = $callStack[$i]
+            
+            # Check if this frame should be skipped
+            $shouldSkip = $false
+            
+            # Skip if it's one of our internal functions
+            if ($frame.Command -and $frame.Command -in $skipFunctions) {
+                $shouldSkip = $true
+            }
+            
+            # Skip if it's the Discovery script itself
+            if ($frame.ScriptName) {
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                if ($scriptName -in $skipScripts) {
+                    $shouldSkip = $true
+                }
+            }
+            
+            # If we shouldn't skip this frame, use it
+            if (-not $shouldSkip) {
+                if ($frame.ScriptName) {
+                    $callingScript = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                    break
+                }
+                elseif ($frame.Command -and $frame.Command -ne "<ScriptBlock>") {
+                    $callingScript = $frame.Command
+                    break
+                }
+            }
+        }
+        
+        # If we still haven't found a caller, determine the execution context
+        if ($callingScript -eq "UnknownCaller") {
+            # Check execution context
+            if ($callStack.Count -le 3) {
+                # Very short call stack suggests direct execution
+                $callingScript = "DirectExecution"
+            }
+            elseif ($MyInvocation.InvocationName -and $MyInvocation.InvocationName -ne "Get-CallingScriptName") {
+                # Use the invocation name if available
+                $callingScript = $MyInvocation.InvocationName
+            }
+            elseif ($PSCommandPath) {
+                # Check if we have a command path (script execution)
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($PSCommandPath)
+                if ($scriptName -and $scriptName -notin $skipScripts) {
+                    $callingScript = $scriptName
+                } else {
+                    $callingScript = "PowerShellExecution"
+                }
+            }
+            else {
+                # Check the host name to determine execution context
+                $hostName = $Host.Name
+                switch ($hostName) {
+                    "ConsoleHost" { $callingScript = "PowerShellConsole" }
+                    "Windows PowerShell ISE Host" { $callingScript = "PowerShell_ISE" }
+                    "ServerRemoteHost" { $callingScript = "RemoteExecution" }
+                    "Visual Studio Code Host" { $callingScript = "VSCode" }
+                    default { $callingScript = "PowerShellHost-$hostName" }
+                }
+            }
+        }
+        
+        return $callingScript
+    }
+    catch {
+        # In case of any error, provide a meaningful fallback
+        try {
+            $hostName = $Host.Name
+            return "ErrorFallback-$hostName"
+        }
+        catch {
+            return "ErrorFallback-Unknown"
+        }
+    }
+}
+
+
+#region Transcript Management Functions
+function Start-ActiveBarTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LogDirectory = "C:\ProgramData\ActiveBarVuln\Logs",
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-ActiveBarVulnLog -Message "Transcript not started - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $null
+        }
+        
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create directory structure: Logs/Transcript/{Date}/{ParentScript}
+        $transcriptDirectory = Join-Path -Path $LogDirectory -ChildPath "Transcript"
+        $fullTranscriptDirectory = Join-Path -Path $transcriptDirectory -ChildPath $dateFolder
+        $fullTranscriptDirectory = Join-Path -Path $fullTranscriptDirectory -ChildPath $parentScriptName
+        
+        if (-not (Test-Path -Path $fullTranscriptDirectory)) {
+            New-Item -ItemType Directory -Path $fullTranscriptDirectory -Force | Out-Null
+        }
+        
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        $transcriptPath = Join-Path -Path $fullTranscriptDirectory -ChildPath $transcriptFileName
+        
+        # Start transcript with error handling and suppress all console output
+        try {
+            Start-Transcript -Path $transcriptPath -ErrorAction Stop | Out-Null
+            Write-ActiveBarVulnLog -Message "Transcript started successfully at: $transcriptPath" -Level Information -Mode $LoggingMode
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Failed to start transcript at $transcriptPath" -LoggingMode $LoggingMode
+            return $null
+        }
+        
+        # Transcript rotation
+        try {
+            $transcriptFiles = Get-ChildItem -Path $fullTranscriptDirectory -Filter "*-*-*-*-$parentScriptName-transcript*.log" | Sort-Object LastWriteTime -Descending
+            if ($transcriptFiles.Count -gt 7) {
+                $filesToRemove = $transcriptFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                    Write-ActiveBarVulnLog -Message "Removed old transcript file: $($file.FullName)" -Level Debug -Mode $LoggingMode
+                }
+            }
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error during transcript file rotation" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptPath
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Start-ActiveBarTranscript function" -LoggingMode $LoggingMode
+        return $null
+    }
+}
+
+function Stop-ActiveBarTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-ActiveBarVulnLog -Message "Transcript not stopped - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $false
+        }
+        
+        # Check if transcript is running before attempting to stop
+        $transcriptRunning = $false
+        try {
+            # Try to stop transcript and suppress all console output
+            Stop-Transcript -ErrorAction Stop | Out-Null
+            $transcriptRunning = $true
+            Write-ActiveBarVulnLog -Message "Transcript stopped successfully." -Level Information -Mode $LoggingMode
+        }
+        catch [System.InvalidOperationException] {
+            # This is expected if no transcript is running
+            Write-ActiveBarVulnLog -Message "No active transcript to stop." -Level Debug -Mode $LoggingMode
+        }
+        catch {
+            # Other transcript-related errors
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error stopping transcript" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptRunning
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Stop-ActiveBarTranscript function" -LoggingMode $LoggingMode
+        return $false
+    }
+}
+
+function Get-TranscriptFilePath {
+    [CmdletBinding()]
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$TranscriptsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+    
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: Transcript/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+        
+        # Generate timestamp for unique transcript file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the transcript file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-transcript-{Timestamp}.log
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        
+        # Combine the full path
+        $transcriptFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $transcriptFileName
+        
+        return $transcriptFilePath
+    }
+    catch {
+        Write-ActiveBarVulnLog -Message "Failed to generate transcript file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-fallback-$timestamp.log"
+    }
+}
+#endregion Transcript Management Functions
+function Get-CSVLogFilePath {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [string]$LogsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: PSF/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+
+        # Generate timestamp for unique log file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the log file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-log-{Timestamp}.csv
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-$timestamp.csv"
+        
+        # Combine the full path
+        $csvLogFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $logFileName
+        
+        return $csvLogFilePath
+    }
+    catch {
+        Write-ActiveBarVulnLog -Message "Failed to generate CSV log file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-fallback-$timestamp.csv"
+    }
+}
+
+
+
+
+#endregion Helper Functions
+
+
+#endregion Logging Function
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-get-products.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-get-products.ps1
new file mode 100644
index 0000000..bfdcef4
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-get-products.ps1	
@@ -0,0 +1,116 @@
+# Load the functions without running the main script
+$ErrorActionPreference = 'Stop'
+
+# Define the logging function
+function Write-Log {
+    param([string]$Message, [string]$Level = 'Info')
+    Write-Host "[$Level] $Message"
+}
+
+# Define the Get-CiscoInstalledProducts function
+function Get-CiscoInstalledProducts {
+    Write-Log "Searching for installed Cisco Secure Client components..."
+    
+    $InstalledProducts = @()
+    
+    # Known product codes for version 5.1.10.233
+    $KnownProducts = @(
+        @{
+            Name = "Cisco Secure Client - Diagnostics and Reporting Tool"
+            Code = "{B68CDB22-0490-4275-9645-ECF202869592}"
+            Order = 1
+        },
+        @{
+            Name = "Cisco Secure Client - Umbrella"
+            Code = "{51DAD0BB-84FA-4942-A00C-D4014529D6A5}"
+            Order = 2
+        },
+        @{
+            Name = "Cisco Secure Client - AnyConnect VPN"
+            Code = "{A39D1E16-8CCD-44EC-9ADF-33C04A3F590F}"
+            Order = 3
+        }
+    )
+    
+    # Check registry for installed components
+    $RegistryPaths = @(
+        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
+        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
+    )
+    
+    foreach ($Path in $RegistryPaths) {
+        if (Test-Path $Path) {
+            $Items = Get-ChildItem -Path $Path -ErrorAction SilentlyContinue
+            
+            foreach ($Item in $Items) {
+                $App = Get-ItemProperty -Path $Item.PSPath -ErrorAction SilentlyContinue
+                
+                if ($App.DisplayName -like "*Cisco Secure Client*" -or $App.DisplayName -like "*Cisco AnyConnect*") {
+                    # Check if it's a known product
+                    $KnownProduct = $KnownProducts | Where-Object { $_.Code -eq $Item.PSChildName }
+                    
+                    if ($KnownProduct) {
+                        $InstalledProducts += @{
+                            Name = $KnownProduct.Name
+                            Code = $KnownProduct.Code
+                            Order = $KnownProduct.Order
+                            Version = $App.DisplayVersion
+                        }
+                    }
+                    else {
+                        # Unknown Cisco product
+                        $InstalledProducts += @{
+                            Name = $App.DisplayName
+                            Code = $Item.PSChildName
+                            Order = 99  # Uninstall unknown products last
+                            Version = $App.DisplayVersion
+                        }
+                    }
+                    
+                    Write-Log "Found: $($App.DisplayName) v$($App.DisplayVersion)"
+                }
+            }
+        }
+    }
+    
+    Write-Host "`nBefore sorting:"
+    Write-Host "InstalledProducts count: $($InstalledProducts.Count)"
+    Write-Host "InstalledProducts type: $($InstalledProducts.GetType().Name)"
+    
+    # Sort by order (uninstall in reverse order of installation)
+    # PowerShell 5.1 compatibility: ensure we only return hashtables
+    $SortedProducts = @()
+    foreach ($Product in $InstalledProducts) {
+        if ($Product -is [hashtable]) {
+            $SortedProducts += $Product
+        }
+    }
+    
+    Write-Host "`nAfter filtering:"
+    Write-Host "SortedProducts count: $($SortedProducts.Count)"
+    
+    # Ensure we always return an array, even with single item
+    if ($SortedProducts.Count -eq 0) {
+        return @()
+    } elseif ($SortedProducts.Count -eq 1) {
+        return @($SortedProducts[0])
+    } else {
+        return @($SortedProducts | Sort-Object -Property { $_['Order'] })
+    }
+}
+
+# Test the function
+$products = Get-CiscoInstalledProducts
+
+Write-Host "`nFinal result:"
+Write-Host "Type: $($products.GetType().Name)"
+Write-Host "Count: $($products.Count)"
+
+foreach ($p in $products) {
+    Write-Host "`nProduct:"
+    Write-Host "  Type: $($p.GetType().Name)"
+    if ($p -is [hashtable]) {
+        Write-Host "  Name: $($p['Name'])"
+        Write-Host "  Code: $($p['Code'])"
+    }
+}
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-output.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-output.ps1
new file mode 100644
index 0000000..3f57c1a
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-output.ps1	
@@ -0,0 +1,5 @@
+# Test output length
+$output = & powershell -ExecutionPolicy Bypass -File check.ps1 2>&1
+Write-Host "Output length: $($output.Length)"
+Write-Host "Output empty: $($null -eq $output -or $output.Length -eq 0)"
+Write-Host "Exit code: $LASTEXITCODE"
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-output2.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-output2.ps1
new file mode 100644
index 0000000..aeab857
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-output2.ps1	
@@ -0,0 +1,5 @@
+# Test exact output
+$output = & powershell -ExecutionPolicy Bypass -File check.ps1 2>&1
+Write-Host "Output: [$output]"
+Write-Host "Output length: $($output.Length)"
+Write-Host "Exit code: $LASTEXITCODE"
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-reg.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-reg.ps1
new file mode 100644
index 0000000..e69de29
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-services.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-services.ps1
new file mode 100644
index 0000000..9a500a2
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-services.ps1	
@@ -0,0 +1 @@
+Get-Service -Name 'csc_*', 'vpnagent', 'acwebsecagent' -ErrorAction SilentlyContinue | Select-Object Name, Status
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-uninstall-debug.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-uninstall-debug.ps1
new file mode 100644
index 0000000..9d92006
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/test-uninstall-debug.ps1	
@@ -0,0 +1,32 @@
+# Debug script to check what's in the registry
+$RegistryPaths = @(
+    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
+    "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
+)
+
+$CiscoProducts = @()
+
+foreach ($Path in $RegistryPaths) {
+    if (Test-Path $Path) {
+        $Items = Get-ChildItem -Path $Path -ErrorAction SilentlyContinue
+        
+        foreach ($Item in $Items) {
+            $App = Get-ItemProperty -Path $Item.PSPath -ErrorAction SilentlyContinue
+            
+            if ($App.DisplayName -like "*Cisco Secure Client*" -or $App.DisplayName -like "*Cisco AnyConnect*") {
+                Write-Host "Found: $($App.DisplayName)"
+                Write-Host "  Code: $($Item.PSChildName)"
+                Write-Host "  Type: $($Item.GetType().Name)"
+                $CiscoProducts += @{
+                    Name = $App.DisplayName
+                    Code = $Item.PSChildName
+                }
+            }
+        }
+    }
+}
+
+Write-Host "`nTotal found: $($CiscoProducts.Count)"
+foreach ($p in $CiscoProducts) {
+    Write-Host "Product: $($p['Name']) - Code: $($p['Code'])"
+}
\ No newline at end of file
diff --git a/Win32Apps-Gallery/Cisco/Cisco Secure Client/uninstall.ps1 b/Win32Apps-Gallery/Cisco/Cisco Secure Client/uninstall.ps1
new file mode 100644
index 0000000..7cf5054
--- /dev/null
+++ b/Win32Apps-Gallery/Cisco/Cisco Secure Client/uninstall.ps1	
@@ -0,0 +1,321 @@
+<#
+.SYNOPSIS
+    Uninstalls Cisco Secure Client components.
+
+.DESCRIPTION
+    This script uninstalls Cisco Secure Client components in reverse order:
+    1. DART component
+    2. Umbrella component
+    3. Core VPN component
+    
+    Designed for Intune Win32 app deployment.
+
+.NOTES
+    Version:        1.0
+    Creation Date:  2025-01-12
+    Purpose:        Intune Win32 App Uninstallation Script
+    Compatibility:  PowerShell 5.1
+#>
+
+#region Script Configuration
+$LogPath = "$env:ProgramData\Microsoft\IntuneManagementExtension\Logs"
+$LogFile = Join-Path $LogPath "CiscoSecureClient_Uninstall_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
+#endregion
+
+#region Logging Functions
+function Write-Log {
+    param(
+        [Parameter(Mandatory=$true)]
+        [string]$Message,
+        
+        [Parameter(Mandatory=$false)]
+        [ValidateSet('Info','Warning','Error')]
+        [string]$Level = 'Info'
+    )
+    
+    $TimeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $LogMessage = "$TimeStamp [$Level] $Message"
+    
+    # Write to log file
+    Add-Content -Path $LogFile -Value $LogMessage -Force
+    
+    # Also write to console for Intune
+    switch ($Level) {
+        'Warning' { Write-Warning $Message }
+        'Error' { Write-Error $Message }
+        default { Write-Output $Message }
+    }
+}
+#endregion
+
+#region Uninstallation Functions
+function Stop-CiscoServices {
+    Write-Log "Stopping Cisco services..."
+    
+    $CiscoServices = @(
+        "csc_umbrellaagent",
+        "vpnagent",
+        "acwebsecagent"
+    )
+    
+    foreach ($ServiceName in $CiscoServices) {
+        $Service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
+        if ($Service -and $Service.Status -eq 'Running') {
+            Write-Log "Stopping service: $ServiceName"
+            Stop-Service -Name $ServiceName -Force -ErrorAction SilentlyContinue
+            Start-Sleep -Seconds 2
+        }
+    }
+}
+
+function Stop-CiscoProcesses {
+    Write-Log "Stopping Cisco processes..."
+    
+    $CiscoProcesses = @(
+        "vpnui",
+        "vpnagent",
+        "csc_umbrellaagent",
+        "acwebsecagent"
+    )
+    
+    foreach ($ProcessName in $CiscoProcesses) {
+        $Processes = Get-Process -Name $ProcessName -ErrorAction SilentlyContinue
+        if ($Processes) {
+            Write-Log "Stopping process: $ProcessName"
+            $Processes | Stop-Process -Force -ErrorAction SilentlyContinue
+            Start-Sleep -Seconds 1
+        }
+    }
+}
+
+function Uninstall-CiscoComponent {
+    param(
+        [Parameter(Mandatory=$true)]
+        [string]$ProductName,
+        
+        [Parameter(Mandatory=$true)]
+        [string]$ProductCode
+    )
+    
+    Write-Log "Uninstalling $ProductName..."
+    
+    # Sanitize product name for log file
+    $LogFileName = $ProductName -replace '[^\w\-\.]', '_'
+    $UninstallLogFile = Join-Path $LogPath "${LogFileName}_Uninstall_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
+    $ArgumentList = "/x `"$ProductCode`" /qn /norestart /l*v `"$UninstallLogFile`""
+    
+    $Process = Start-Process -FilePath "msiexec.exe" -ArgumentList $ArgumentList -Wait -PassThru
+    
+    if ($Process.ExitCode -eq 0) {
+        Write-Log "$ProductName uninstalled successfully."
+        return $true
+    }
+    elseif ($Process.ExitCode -eq 3010) {
+        Write-Log "$ProductName uninstalled successfully but requires a reboot." -Level Warning
+        return $true
+    }
+    else {
+        Write-Log "$ProductName uninstallation failed with exit code: $($Process.ExitCode)" -Level Error
+        return $false
+    }
+}
+
+function Get-CiscoInstalledProducts {
+    Write-Log "Searching for installed Cisco Secure Client components..."
+    
+    $InstalledProducts = @()
+    
+    # Known product codes for version 5.1.10.233
+    $KnownProducts = @(
+        @{
+            Name = "Cisco Secure Client - Diagnostics and Reporting Tool"
+            Code = "{B68CDB22-0490-4275-9645-ECF202869592}"
+            Order = 1
+        },
+        @{
+            Name = "Cisco Secure Client - Umbrella"
+            Code = "{51DAD0BB-84FA-4942-A00C-D4014529D6A5}"
+            Order = 2
+        },
+        @{
+            Name = "Cisco Secure Client - AnyConnect VPN"
+            Code = "{A39D1E16-8CCD-44EC-9ADF-33C04A3F590F}"
+            Order = 3
+        }
+    )
+    
+    # Check registry for installed components
+    $RegistryPaths = @(
+        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
+        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
+    )
+    
+    foreach ($Path in $RegistryPaths) {
+        if (Test-Path $Path) {
+            $Items = Get-ChildItem -Path $Path -ErrorAction SilentlyContinue
+            
+            foreach ($Item in $Items) {
+                $App = Get-ItemProperty -Path $Item.PSPath -ErrorAction SilentlyContinue
+                
+                if ($App.DisplayName -like "*Cisco Secure Client*" -or $App.DisplayName -like "*Cisco AnyConnect*") {
+                    # Check if it's a known product
+                    $KnownProduct = $KnownProducts | Where-Object { $_.Code -eq $Item.PSChildName }
+                    
+                    if ($KnownProduct) {
+                        $InstalledProducts += @{
+                            Name = $KnownProduct.Name
+                            Code = $KnownProduct.Code
+                            Order = $KnownProduct.Order
+                            Version = $App.DisplayVersion
+                        }
+                    }
+                    else {
+                        # Unknown Cisco product - validate that we have a proper GUID as product code
+                        if ($Item.PSChildName -match "^\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\}$") {
+                            $InstalledProducts += @{
+                                Name = $App.DisplayName
+                                Code = $Item.PSChildName
+                                Order = 99  # Uninstall unknown products last
+                                Version = $App.DisplayVersion
+                            }
+                        } else {
+                            Write-Log "Skipping registry entry with invalid product code format: $($App.DisplayName) [Code: $($Item.PSChildName)]" -Level Warning
+                        }
+                    }
+                    
+                    Write-Log "Found: $($App.DisplayName) v$($App.DisplayVersion)"
+                }
+            }
+        }
+    }
+    
+    # Sort by order (uninstall in reverse order of installation)
+    # PowerShell 5.1 compatibility: ensure we only return hashtables
+    $SortedProducts = @()
+    foreach ($Product in $InstalledProducts) {
+        if ($Product -is [hashtable]) {
+            $SortedProducts += $Product
+        }
+    }
+    
+    # Ensure we always return an array, even with single item
+    if ($SortedProducts.Count -eq 0) {
+        return @()
+    } elseif ($SortedProducts.Count -eq 1) {
+        return @($SortedProducts[0])
+    } else {
+        return @($SortedProducts | Sort-Object -Property { $_['Order'] })
+    }
+}
+#endregion
+
+#region Main Uninstallation Logic
+try {
+    # Create log directory if it doesn't exist
+    if (-not (Test-Path $LogPath)) {
+        New-Item -ItemType Directory -Path $LogPath -Force | Out-Null
+    }
+    
+    Write-Log "=== Cisco Secure Client Uninstallation Started ==="
+    
+    # Check for administrator privileges
+    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
+        Write-Log "Script must be run with administrator privileges." -Level Error
+        exit 1
+    }
+    
+    # Stop services and processes
+    Stop-CiscoServices
+    Stop-CiscoProcesses
+    
+    # Get installed Cisco products
+    $InstalledProducts = Get-CiscoInstalledProducts
+    
+    if ($InstalledProducts.Count -eq 0) {
+        Write-Log "No Cisco Secure Client components found to uninstall."
+        exit 0
+    }
+    
+    Write-Log "Found $($InstalledProducts.Count) component(s) to uninstall:"
+    foreach ($Product in $InstalledProducts) {
+        if ($Product -and $Product['Name']) {
+            Write-Log "  - $($Product['Name']) v$($Product['Version']) [Code: $($Product['Code'])]"
+        } else {
+            Write-Log "  - Invalid entry detected (missing name/code data)"
+        }
+    }
+    
+    # Uninstall each component
+    $FailedUninstalls = @()
+    $ValidProducts = @()
+    $SkippedProducts = 0
+    
+    foreach ($Product in $InstalledProducts) {
+        # Ensure we have valid data
+        if (-not $Product -or -not $Product['Name'] -or -not $Product['Code']) {
+            $SkippedProducts++
+            if ($Product -and $Product['Name']) {
+                Write-Log "Skipping invalid product entry: $($Product['Name']) (missing product code)" -Level Warning
+            } elseif ($Product -and $Product['Code']) {
+                Write-Log "Skipping invalid product entry: Code $($Product['Code']) (missing product name)" -Level Warning  
+            } else {
+                Write-Log "Skipping invalid product entry: Completely malformed registry data" -Level Warning
+            }
+            continue
+        }
+        
+        $ValidProducts += $Product
+    }
+    
+    if ($SkippedProducts -gt 0) {
+        Write-Log "Skipped $SkippedProducts invalid registry entries. Proceeding with $($ValidProducts.Count) valid components."
+    }
+    
+    # Process valid products
+    foreach ($Product in $ValidProducts) {
+        Write-Log "Uninstalling: $($Product['Name'])"
+        $Success = Uninstall-CiscoComponent -ProductName $Product['Name'] -ProductCode $Product['Code']
+        
+        if (-not $Success) {
+            $FailedUninstalls += $Product['Name']
+        }
+        
+        # Wait between uninstalls
+        Start-Sleep -Seconds 3
+    }
+    
+    # Clean up remaining folders if all components uninstalled successfully
+    if ($FailedUninstalls.Count -eq 0) {
+        Write-Log "Cleaning up remaining folders..."
+        
+        $FoldersToRemove = @(
+            "${env:ProgramFiles}\Cisco\Cisco Secure Client",
+            "${env:ProgramFiles(x86)}\Cisco\Cisco Secure Client",
+            "${env:ProgramFiles}\Cisco\Cisco AnyConnect Secure Mobility Client",
+            "${env:ProgramFiles(x86)}\Cisco\Cisco AnyConnect Secure Mobility Client",
+            "${env:ProgramData}\Cisco\Cisco Secure Client",
+            "${env:ProgramData}\Cisco\Cisco AnyConnect Secure Mobility Client"
+        )
+        
+        foreach ($Folder in $FoldersToRemove) {
+            if (Test-Path $Folder) {
+                Write-Log "Removing folder: $Folder"
+                Remove-Item -Path $Folder -Recurse -Force -ErrorAction SilentlyContinue
+            }
+        }
+        
+        Write-Log "=== Cisco Secure Client Uninstallation Completed Successfully ==="
+        exit 0
+    }
+    else {
+        Write-Log "=== Uninstallation Failed ===" -Level Error
+        Write-Log "Failed to uninstall: $($FailedUninstalls -join ', ')" -Level Error
+        exit 1
+    }
+}
+catch {
+    Write-Log "Unexpected error during uninstallation: $_" -Level Error
+    Write-Log "Stack Trace: $($_.ScriptStackTrace)" -Level Error
+    exit 1
+}
+#endregion
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/.DS_Store b/Win32Apps-Source/Cisco Secure Client/.DS_Store
new file mode 100644
index 0000000..17eb8a7
Binary files /dev/null and b/Win32Apps-Source/Cisco Secure Client/.DS_Store differ
diff --git a/Win32Apps-Source/Cisco Secure Client/.archive/Umbrella-Detection-Script.ps1 b/Win32Apps-Source/Cisco Secure Client/.archive/Umbrella-Detection-Script.ps1
new file mode 100644
index 0000000..adad8f1
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/.archive/Umbrella-Detection-Script.ps1	
@@ -0,0 +1,8 @@
+$UmbrellaService = Get-Service -Name "csc_umbrellaagent" -ErrorAction SilentlyContinue
+if ($UmbrellaService -and $UmbrellaService.Status -eq "Running") {
+    Write-Host "Umbrella service is installed and running"
+    Exit 0
+} else {
+    Write-Host "Umbrella service is not installed or not running"
+    Exit 1
+}
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/.claude/settings.local.json b/Win32Apps-Source/Cisco Secure Client/.claude/settings.local.json
new file mode 100644
index 0000000..0ba5c25
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/.claude/settings.local.json	
@@ -0,0 +1,35 @@
+{
+  "permissions": {
+    "allow": [
+      "Bash(pwsh:*)",
+      "Bash(powershell.exe:*)",
+      "Bash(python3:*)",
+      "Bash(cp:*)",
+      "Bash(sed:*)",
+      "Bash(powershell:*)",
+      "Bash(echo $?)",
+      "Bash(echo $LASTEXITCODE)",
+      "Bash(echo:*)",
+      "Bash(ls:*)",
+      "Bash(find:*)",
+      "Bash(awk:*)",
+      "Bash(cat:*)",
+      "Bash(git --version)",
+      "Bash(curl:*)",
+      "Bash(wget:*)",
+      "Bash(tar:*)",
+      "Bash(gzip:*)",
+      "Bash(node:*)",
+      "Bash(npm:*)",
+      "Bash(pip --version)",
+      "Bash(apt:*)",
+      "Bash(cut:*)",
+      "Bash(ssh:*)",
+      "Bash(rsync:*)",
+      "Bash(make:*)",
+      "Bash(gcc:*)",
+      "Bash(rm:*)"
+    ],
+    "deny": []
+  }
+}
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/CLAUDE.md b/Win32Apps-Source/Cisco Secure Client/CLAUDE.md
new file mode 100644
index 0000000..34f2e70
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/CLAUDE.md	
@@ -0,0 +1,30 @@
+**PowerShell 5.1 vs 7 Compatibility Issues:**
+<?xml version="1.0" encoding="UTF-8"?>
+<PowerShellCodingStandards version="1.0">
+  <!-- CRITICAL STANDARDS -->
+  <!-- Variables: Never place colons after variable names ($var: value), use proper spacing or ${var}: -->
+  <!-- Operators: Use -and, -or, -not, -eq, -ne, -gt, -lt, -ge, -le; NEVER use &&, ||, !, ==, !=, >, <, >=, <= -->
+  <!-- Null: Place $null on LEFT side of comparisons: ($null -eq $var) NOT ($var -eq $null) -->
+  <!-- Conditionals: Use ($result = if ($cond) { $true } else { $false }) NOT ternary operators -->
+  <!-- Special Ops: NEVER use PowerShell 7+ operators (??, ?.) in PowerShell 5.1 code -->
+  <!-- Params: Never use reserved parameter names (Verbose, Debug, ErrorAction, etc.) -->
+  <!-- Variables: Never reassign automatic variables like $PSScriptRoot or $MyInvocation -->
+  <!-- Strings: Use ASCII-compatible chars, not Unicode symbols like ? or ? -->
+  <!-- String Multiplication: Use parentheses for string multiplication in concatenation: ("=" * 60) NOT "="*60 -->
+  <!-- Modules: Place all Export-ModuleMember statements ONLY in the main .psm1 file -->
+  <!-- Functions: Always include complete comment-based help for all functions -->
+  <!-- Organization: Use #region/#endregion markers for logical code sections -->
+  <!-- Comments: Include detailed comments for initialization, logic, loops, error handling -->
+  <!-- CRITICAL: NEVER USE PESTER FOR TESTING UNDER ANY CIRCUMSTANCES! -->
+  <!-- Use script-based testing with functions and try/catch blocks instead -->
+  <!-- If lint errors persist after a few attempts, do not continue trying to fix them. Instead, inform the human user about the persistent errors and request manual intervention. -->
+  
+  <!-- COMMAND LINE EXECUTION BEST PRACTICES -->
+  <!-- PowerShell -Command: Prone to escaping issues with $, {}, quotes, <, > characters -->
+  <!-- PowerShell -File: Much more reliable for complex scripts - write to .ps1 file first -->
+  <!-- Unix Tools: Prefer grep, awk, sed for text processing - more predictable and composable -->
+  <!-- Mixed Approach: Use PowerShell for Windows-specific tasks (registry, WMI), Unix tools for general processing -->
+  <!-- Complex Commands: For multi-line or complex PowerShell, ALWAYS use script files instead of -Command -->
+  <!-- Escaping: When using -Command, be extremely careful with special characters and quotes -->
+  <!-- Path Handling: Use forward slashes in Git Bash, backslashes in PowerShell scripts -->
+</PowerShellCodingStandards>
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/Cisco Secure Client Installation procedure.docx b/Win32Apps-Source/Cisco Secure Client/Cisco Secure Client Installation procedure.docx
new file mode 100644
index 0000000..ca571fa
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/Cisco Secure Client Installation procedure.docx	
@@ -0,0 +1,84 @@
+                                       
+                                       
+                                       
+                                       
+                  Cisco Secure Client Installation Procedure
+                                   Version 1
+                                       
+                                       
+                                       
+                                       
+                                       
+                                       
+                                       
+                                       
+                                       
+
+
+
+
+
+
+
+
+
+Contents
+
+Purpose	3
+Scope	3
+Steps	3
+Installation Verification	4
+
+
+
+
+
+Purpose 	
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+This procedure instructs on how to install Umbrella Cisco Secure client on end user's devices.
+Scope
+
+ETS internal and external clients
+Steps
+
+ Copy and paste installation folder (Provided by ETS SOC) on device's C drive.
+ Installation folder should have below (or similar) files.
+
+ Now Run Command Prompt as an admin and switch to a file path where Installation package folder has been saved. 
+ 
+ Now run the following 3 commands one by one. Please make sure that the software version you have matches with the command.
+
+msiexec /package cisco-secure-client-win-5.1.10.233-core-vpn-predeploy-k9.msi PRE_DEPLOY_DISABLE_VPN=1 /norestart /passive /lvx* vpninstall.log
+
+msiexec /package cisco-secure-client-win-5.1.10.233-umbrella-predeploy-k9.msi PRE_DEPLOY_DISABLE_VPN=1 /norestart /passive /lvx* umbrellainstall.log
+
+msiexec /package cisco-secure-client-win-5.1.10.233-dart-predeploy-k9.msi /norestart /passive /lvx* dartinstall.log
+
+ Commands should run without any error messages.
+
+
+Installation Verification
+ Open "Service" on target device and you should see following 3 services populated and running.
+
+ To verify if Umbrella Policies are being applied to this device or not, please visit test domain "http://examplemalwaredomain.com [HYPERLINK: http://examplemalwaredomain.com/]"
+ You should see below (or similar) block page if installation was successful.
+   
+ 
+
+
+
+
+
+
+Revision History:
+
+
+Revision Date
+Action
+Author
+07/10/2025
+Initial Document
+Kaushal Patel
+
diff --git a/Win32Apps-Source/Cisco Secure Client/Cisco-icon.png b/Win32Apps-Source/Cisco Secure Client/Cisco-icon.png
new file mode 100644
index 0000000..9847b3d
Binary files /dev/null and b/Win32Apps-Source/Cisco Secure Client/Cisco-icon.png differ
diff --git a/Win32Apps-Source/Cisco Secure Client/Umbrella Connector/.DS_Store b/Win32Apps-Source/Cisco Secure Client/Umbrella Connector/.DS_Store
new file mode 100644
index 0000000..a9663e6
Binary files /dev/null and b/Win32Apps-Source/Cisco Secure Client/Umbrella Connector/.DS_Store differ
diff --git a/Win32Apps-Source/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-Windows-Service/Config.dat b/Win32Apps-Source/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-Windows-Service/Config.dat
new file mode 100644
index 0000000..e323fbf
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-Windows-Service/Config.dat	
@@ -0,0 +1,14 @@
+{
+    "LogLevel" : "1",
+    "SyncServer" : "https://api.opendns.com/v2/",
+    "Org_ID" : "8329794",
+    "Org_Token" : "d1c3f944503fcca3f8a4cdee2d39ba2b758e6a014dfca082f1884934a237675c",
+    "FedRamp" : "0",
+    "TokenGenerationURL": "https://api.umbrella.com/auth/v2/token",
+    "Credentials" : { 
+        "ClientApiKey": "",
+        "ClientApiSecret": ""
+    },
+    "SyncGwServer" : "https://api.umbrella.com",
+    "AuthType" : "fallback"
+}
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-WindowsConfigurationScript-2025-07-09 (1).wsf b/Win32Apps-Source/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-WindowsConfigurationScript-2025-07-09 (1).wsf
new file mode 100644
index 0000000..635fa88
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/Umbrella Connector/Cisco-Windows-Service/Cisco-WindowsConfigurationScript-2025-07-09 (1).wsf	
@@ -0,0 +1,1606 @@
+<job>
+<script Language="VBScript">
+Option Explicit
+
+'*************************************************************************************************************
+' START MAIN
+'*************************************************************************************************************
+
+' GLOBAL DEFINITIONS
+
+' This will now be the default sAMAccountName, if the user leaves the prompt for Service Account name empty. 
+Const ACCOUNT_NAME = "Cisco_Connector"
+
+' Check this is being launched by cscript
+'********************************************************
+if (instr(lcase(WScript.FullName), "wscript")) Then
+    MsgBox "Use " & chr(34) & "cscript " & WScript.ScriptName & chr(34) & " to run this script." & vbcrlf & vbcrlf & _
+            "This script must be run from an elevated command prompt", vbCritical, "DCSetup: Incorrect scripting engine"
+    WScript.Quit
+End if
+
+' Needed globals
+'********************************************************
+Dim gOS ' Can be 0=Reserved,1=2003,2=2008,3=2012,4=Win7,5=Other,6=2016,7=2019,8=Microsoft Windows Server Standard,9=Microsoft Windows Server Datacenter,10=2022
+Dim gFunctionalLevel ' Can be 0=mixed, 1=2003-interim, 2=2003, 3=2008, 4=2008r2, 5=2012, 6=2016r2, 7=2016
+Dim gSP
+Dim gR2 ' Empty means it's not R2
+Dim gDomain
+Dim gDomainFull
+Dim gOrgID
+Dim gCustomerID_Token
+Dim gIntIP
+Dim gServerLabel
+Dim gAssetType
+Dim gToken
+Dim gAccessToken
+Dim gUptime
+Dim gCloudEndpoint
+Dim gTokenEndpoint
+Dim gAuthType
+Dim gApiGwURL
+Dim gVersion
+Dim gDomainFullyQualifiedDomain
+Dim gAccountName
+Dim gClientId
+Dim gClientSecret
+Dim gFedramp
+Dim gOauthAuthentication
+Dim gFWChecked, gFWEnabled, gFWRemoteAdmin, gADUserExists, gRDCPermissions, gELRMember, gForceNetBios
+Dim gManageELPSet
+Dim gForceUserExists, gForceFW, gForceAdmin, gForceFL, gForceRegister, gForceNonVA
+Dim gAccountSID
+Dim gObjSvc, gObjSecurity
+Dim gObjRegistry
+Dim regdec
+Dim decision
+
+gDomainFullyQualifiedDomain = ""
+gOrgID = "8329794"
+gClientId = ""
+gClientSecret = ""
+gTokenEndpoint = "https://api.umbrella.com/auth/v2/token"
+gFedramp = "0"
+gAuthType = "fallback"
+gApiGwURL = "https://api.umbrella.com"
+
+gCustomerID_Token = "d1c3f944503fcca3f8a4cdee2d39ba2b758e6a014dfca082f1884934a237675c"
+gCloudEndpoint = "https://api.opendns.com/v2/"
+gOS = 0
+gFunctionalLevel = 0
+gSP = ""
+gR2 = ""
+gVersion = "1.1.26"
+gServerLabel = "DefaultLabel"
+gAssetType = "domain_controller" ' Means DC
+gToken = ""
+gAccessToken = ""
+gUptime = 0
+gOauthAuthentication = "0"
+If (gFedramp) = "1" Then
+   gOauthAuthentication = "1"
+End If
+
+If (((gAuthType = "enhanced") Or (gAuthType = "fallback")) And ((gClientId <> "") And (gClientSecret <> ""))) Then
+   gOauthAuthentication = "1"
+   gCloudEndpoint = gApiGwURL
+ElseIf (((gAuthType = "legacy") Or (gAuthType = "fallback")) And (gCustomerID_Token <> "")) Then
+   gOauthAuthentication = "0"
+Else
+   gOauthAuthentication = "99"
+   gCloudEndpoint = ""
+End If
+
+' Make sure there is a trailing slash on the endpoint
+If (Right(gCloudEndpoint, 1) <> "/") Then
+   gCloudEndpoint = gCloudEndpoint + "/"
+End If
+
+' Globals that are set during Test functions, and must be True to be considered "configured"
+gFWChecked = True
+gFWEnabled = False
+gFWRemoteAdmin = False
+gADUserExists = False
+gRDCPermissions = False
+gELRMember = False
+gForceNetBios = ""
+
+gManageELPSet = False
+
+gForceUserExists = False
+gForceFW = False
+gForceAdmin = False
+gForceFL = False
+gForceRegister = False
+gForceNonVA = False 'False means VA Mode. Business as usual'
+
+' Account ID, needed by other functions
+gAccountSID = ""
+
+' Global WMI objects
+' Connect to WMI root\cimv2 namespace (needed by many other functions)
+Set gObjSvc = GetObject("WINMGMTS:root/cimv2")
+' Get the single __SystemSecurity object in this namespace
+Set gObjSecurity = gObjSvc.Get("__SystemSecurity=@")
+
+' Registry globals and constants
+Set gObjRegistry = GetObject("WINMGMTS:root/default:StdRegProv")
+Const HKEY_LOCAL_MACHINE = &H80000002
+Const DCOM_REG_PATH = "SOFTWARE\Microsoft\Ole\"
+Const DCOM_REG_KEY = "MachineLaunchRestriction"
+
+' WMI constants
+Const SE_DACL_PRESENT = &h4
+Const ACCESS_ALLOWED_ACE_TYPE = &h0
+Const ACE_ENABLE_ACCOUNT = 1 ' Read
+Const ACE_REMOTE_ENABLE = 32 ' Execute/Traverse
+Const ACE_READ_SECURITY = 131072 ' Read Control
+
+' DCOM constants
+Const DCOM_ENABLE_ACCOUNT = 1 ' Create Child
+Const DCOM_REMOTE_LAUNCH = 4 ' List Children
+Const DCOM_REMOTE_ACTIVATION = 16 ' Read Property
+
+' RDC constants
+Const ADS_RIGHT_DS_CONTROL_ACCESS = &H100
+Const ADS_ACETYPE_ACCESS_ALLOWED_OBJECT = &H5   'Allows an object to do something
+Const ADS_FLAG_OBJECT_TYPE_PRESENT = &H1   'Target object type is present in the ACE 
+Const SCHEMA_GUID_MS_REPLICATION_GET_CHANGES = "{1131F6AA-9C07-11D1-F79F-00C04FC2DCD2}"
+
+' Group constants
+Const ELR_SID = "S-1-5-32-573"
+Const DCOM_SID = "S-1-5-32-562"
+
+
+' Args
+'********************************************************
+CollectArgs()
+
+' OS Test - Do this early for conditional checks later on based on OS
+'********************************************************
+TestOS()
+
+' Check for Administrator privileges
+'********************************************************
+If (IsAdmin() <> 1) Then
+    WScript.Echo "Insufficient privileges detected!"
+    If (gForceAdmin) Then
+        WScript.Echo "Installation will be allowed to continue. However, if the script"
+        WScript.Echo "encounters errors, please make sure it is run from an administrator acccount."
+    Else
+        WScript.Echo "Please run this script as an Administrator user."
+        WScript.Echo "Or, right-click the Command Prompt icon and 'Run as Administrator'."
+        WScript.Echo "If you wish to continue anyway, run the script with the '--forceAdmin true' argument."
+        WScript.Quit
+    End If
+End If
+
+' Detect Config
+'********************************************************
+WScript.Echo "Testing configuration..."
+gIntIP = GetIPAddress()
+
+If (gDomain = "") Then
+	If (gForceNetBios) = "" Then
+		gDomain = GetComputerDomainName() ' This is actually NetBIOS name
+	Else
+		gDomain = gForceNetBios
+	End If
+End If
+
+gDomainFull = GetComputerFullDomainName()
+gServerLabel = GetComputerHostName()
+gDomainFullyQualifiedDomain = GetDomainFullName()
+WScript.Echo  "Full Computer Domain : " & gDomainFullyQualifiedDomain
+
+'The following if block is to check if CollectArgs has set a value for gAccountName with the --username parameter, else set to default - Cisco_Connector
+If gAccountName = "" Then
+    gAccountName = ACCOUNT_NAME
+End If
+
+
+If (gForceRegister) Then
+   WScript.Echo "Forcing Register"
+   If gOauthAuthentication="0" Then   
+      SendAssetRegister()
+      SendAssetUpdate()
+   ElseIf gOauthAuthentication="1" Then
+      SendForAuthToken()
+      SendAssetRegisterEnhancedAuth()
+      SendForAuthToken()
+      SendAssetUpdateEnhancedAuth()         
+   Else
+      WScript.Echo("Register failure. Unauthorized, missing mandatory credentials.")
+   End If
+   WScript.Echo "Exiting before configuration!"
+   WScript.Quit
+End If
+
+TestRemoteAdmin()
+TestADUser()
+If (gADUserExists And (gAccountSID <> "")) Then
+   ' Tests that require an AD user already configured
+   TestRDC()
+   TestELR()
+   TestManageELPolicy()
+Else
+   'WScript.Echo "Skipping tests that require an AD User..."
+End If
+
+' Alert admin to state, ask if he wants auto config
+WScript.Echo ""
+WScript.Echo "***********************************************"
+WScript.Echo "Local Platform Configuration"
+WScript.Echo ""
+WScript.Echo "Local OS: " & OSToString(gOS)
+WScript.Echo "Functional Level: " & FLToString(gFunctionalLevel)
+WScript.Echo "Local IP: " & gIntIP
+WScript.Echo "Domain:   " & gDomainFull & " (" & gDomain & ")"
+WScript.Echo "Label:    " & gServerLabel
+If (gFWChecked) Then 
+   WScript.Echo "Firewall Enabled: " & gFWEnabled
+   WScript.Echo ""
+   WScript.Echo "Remote Admin Enabled: " & gFWRemoteAdmin
+Else
+   WScript.Echo "Firewall Enabled: unknown" 
+   WScript.Echo ""
+   WScript.Echo "Remote Admin Enabled: unknown"
+End If
+
+If (((gOS = 2) Or (gOS = 3) Or (gOS = 6) Or (gOS = 7) or (gOS = 8) or (gOS = 9) or (gOS = 10)) And (gFunctionalLevel >= 3)) Then
+   ' Windows Server 2008, 2012 and 2016 (functional level) can be fully configured
+   ' Event Log Reader membership only exists in 2008+
+   WScript.Echo "AD User Exists: " & gADUserExists
+   WScript.Echo "RDC Permissions Set: " & gRDCPermissions
+   If (gForceNonVA = False) Then
+        WScript.Echo ""
+        WScript.Echo "Manage Event Log Policy Set: " & gManageELPSet
+        WScript.Echo ""
+        WScript.Echo "Event Log Readers MemberOf: " & gELRMember
+   End If
+   WScript.Echo "***********************************************"
+   WScript.Echo ""
+
+   ' Outcome
+   ' If we're already configured in full, we don't need to do anything
+   If (IsConfiguredInFull()) Then
+      WScript.Echo "Domain Controller is fully configured!"
+        AutoRegisterDC()
+   ElseIf (gADUserExists = False) Then
+      WScript.Echo "Could not find user " & gAccountName & " in domain " + gDomain + _
+          ".  Please create one, or use the --forceDomain DOMAIN or --forceUserExists true command line argument."
+   Else
+      WScript.Echo "Your platform is supported for auto-configure."
+
+      ' Decide if they want to auto config
+      decision = UserInput("Do you want us to auto configure this Domain Controller (y or n)?")
+      
+      If InStr(decision,"y")=1 Then
+         If (DoAutoConfig2008()) Then
+            ' Radio home results
+            AutoRegisterDC()
+         End If
+
+      ElseIf InStr(decision,"n")=1 Then
+         WScript.Echo ""
+         WScript.Echo ""
+         WScript.Echo "INFO:"
+         WScript.Echo "*-----------------------------------------------------------"
+         WScript.Echo "Use the settings table above to decide if you will need to "
+         WScript.Echo "manually configure your Domain Controller."
+         WScript.Echo "Check the documentation for further details."
+         WScript.Echo "*-----------------------------------------------------------"
+      Else
+         WScript.Echo "Didn't understand input, please re-run to configure"
+      End If
+   End If
+ElseIf ((gOS = 1) Or (gOS = 2) Or (gOS = 3) Or (gOS = 6) Or (gOS = 7) or (gOS = 8) or (gOS = 9) or (gOS = 10)) Then
+   ' Windows Server 2003 functional levels (on any OS)
+   ' Can't QUITE be fully configured; WMI must be done manually
+   WScript.Echo "AD User Exists: " & gADUserExists
+   WScript.Echo "RDC Permissions Set: " & gRDCPermissions
+   If (gForceNonVA = False) Then
+        WScript.Echo ""
+        WScript.Echo "Manage Event Log Policy Set: " & gManageELPSet
+        WScript.Echo ""
+   End If
+   WScript.Echo "***********************************************"
+   WScript.Echo ""
+
+   ' Outcome
+   ' If we're already configured in full, we don't need to do anything
+   If (IsConfiguredInFull()) Then
+     ' Radio home results
+      WScript.Echo "Domain Controller is fully configured!"
+        AutoRegisterDC()
+   ElseIf (gADUserExists = false) Then
+      WScript.Echo "Could not find user " & gAccountName & "  in domain " + gDomain
+      WScript.Echo "Please create one, or add the expected domain as a command line argument."
+      WScript.Echo "If you are sure this message is in error, you can use --forceUserExists true to force the script to continue."
+   Else
+      WScript.Echo "Your platform is supported for auto-configure."
+
+      ' Decide if they want to auto config
+      decision = UserInput("Do you want us to auto configure this Domain Controller (y or n)?")
+      
+      If InStr(decision,"y")=1 Then
+         If (DoAutoConfig2003()) Then
+            ' Radio home results
+            AutoRegisterDC()
+         End If
+
+      ElseIf InStr(decision,"n")=1 Then
+         WScript.Echo ""
+         WScript.Echo ""
+         WScript.Echo "INFO:"
+         WScript.Echo "*-----------------------------------------------------------"
+         WScript.Echo "Use the settings table above to decide if you will need to "
+         WScript.Echo "manually configure your Domain Controller."
+         WScript.Echo "Check the documentation for further details."
+         WScript.Echo "*-----------------------------------------------------------"
+      Else
+         WScript.Echo "Didn't understand input, please re-run to configure"
+      End If
+   End If
+Else
+   WScript.Echo ""
+   WScript.Echo "CONFIG FAILED - Reason: Your platform is not supported"
+   WScript.Echo "Please choose a Domain Controller running at least Windows Server 2003"
+End If
+
+'*************************************************************************************************************
+' END MAIN
+'*************************************************************************************************************
+
+
+' FUNCTIONS
+'*************************************************************************************************************
+
+' Auto Config Functions
+'*****************************
+Function DoAutoConfig2008()
+   WScript.Echo ""
+   WScript.Echo "Configuring system..."
+   
+   ' Configure the firewall, if necessary (Just always run, if firewall is off, doesn't hurt)
+   
+   If (gForceNonVA = False) Then
+      WScript.Echo "Setting Remote Admin permissions on firewall..."
+      SetRemoteAdmin()
+      SetRemoteEventLog()
+      TestRemoteAdmin()
+   End If
+   
+   ' Set other permissions, if necessary and able
+   If (gADUserExists And (gAccountSID <> "")) Then
+      ' Set RDC permissions, if necessary
+      If (gRDCPermissions = False) Then
+         WScript.Echo "Setting RDC permissions..."
+         SetRDC()
+         TestRDC()
+      End If
+
+      ' Add to Event Log Reader group, if necessary
+      If (gELRMember = False) Then
+      	 ' Check if Non VA mode is NOT set
+            WScript.Echo "Adding to Event Log Readers group..."
+            SetELR()
+            TestELR()
+      End If
+      
+      ' The Event Log policy is not required for 2008
+
+   End If
+   
+   If (IsConfiguredInFull()) Then
+      WScript.Echo "Auto Configuration complete in full!"
+      DoAutoConfig2008 = True
+   Else
+      WScript.Echo "Auto Configuration incomplete!"
+      WScript.Echo "You may re-run this script to verify settings."
+      DoAutoConfig2008 = False
+   End If
+End Function
+
+' Version specific 2003
+Function DoAutoConfig2003()
+   Dim override
+   WScript.Echo ""
+   WScript.Echo "Configuring system..."
+   
+   ' Configure the firewall, if necessary (Just always run, if firewall is off, doesn't hurt)
+   
+   If (gForceNonVA = False) Then
+      WScript.Echo "Setting Remote Admin permissions on firewall..."
+      SetRemoteAdmin()
+      SetRemoteEventLog()
+      TestRemoteAdmin()
+   End If
+   
+   ' Set other permissions, if necessary and able
+   If (gADUserExists And (gAccountSID <> "")) Then
+      ' Set RDC permissions, if necessary
+      If (gRDCPermissions = False) Then
+         WScript.Echo "Setting RDC permissions..."
+         SetRDC()
+         TestRDC()
+      End If
+
+      ' There is no Event Log Readers group in 2003, so don't check that
+      
+      ' This policy SHOULD be set for 2003, but consider it just a warning
+      If (gManageELPSet = False) Then
+          WScript.Echo ""
+          WScript.Echo "ERROR: "
+          WScript.Echo "*------------------------------------------------------------------------------"
+          WScript.Echo "You must edit the following Group Policy and apply it to all 2003 DCs: "
+          WScript.Echo ""
+          WScript.Echo "  Computer Configuration\Policies\Windows Settings\Security Settings\"
+          WScript.Echo "    Local Policies\User Rights Assignment\Manage auditing and security log"
+          WScript.Echo ""
+          WScript.Echo "You must add the " & gAccountName & " user to the setting and gpupdate!"
+          WScript.Echo "*------------------------------------------------------------------------------"
+          WScript.Echo ""
+      End If
+   End If
+   
+   If (IsConfiguredInFull()) Then
+      WScript.Echo "Auto Config complete in full!"
+      DoAutoConfig2003 = True
+   Else
+      WScript.Echo ""
+      override = UserInput("Do you want to force register anyway (y or n)?")
+      If InStr(override,"y")=1 Then
+         DoAutoConfig2003 = True
+      ElseIf InStr(override,"n")=1 Then
+         WScript.Echo ""
+         WScript.Echo "Auto Config incomplete!"
+         WScript.Echo "You will need to manually set WMI permissions and correct any errors."
+         WScript.Echo "Then you may re-run this script and force register."
+         DoAutoConfig2003 = False
+      Else
+         WScript.Echo "Didn't understand input, please re-run to configure"
+      End If
+   End If
+End Function
+
+' OS Test Function
+'*****************************
+Sub TestOS()
+   Dim strComputer
+   Dim colItems
+   Dim strOS, objItem, lastBoot
+   Dim lastBootDate
+
+   strComputer = "."
+
+   Set colItems = gObjSvc.ExecQuery("SELECT * FROM Win32_OperatingSystem",,48)
+
+   For Each objItem in colItems     
+      strOS = objItem.Caption    
+      gSP = objItem.ServicePackMajorVersion
+      gR2 = objItem.OtherTypeDescription
+      lastBoot = objItem.LastBootUpTime
+      Wscript.Echo "The System OS received from system  : " & strOS
+      Wscript.Echo "The OS version received from system : " & objItem.Version
+   Next
+   
+   If InStr(strOS,"2003")<>0 Then
+      gOS = 1 ' OS is 2003 of some flavor
+   ElseIf InStr(strOS,"2008")<>0 Then
+      gOS = 2 ' OS is 2008 of some flavor
+   ElseIf InStr(strOS,"2011")<>0 Then
+      gOS = 2 ' OS is SBS 2011, mark it as 2008
+   ElseIf InStr(strOS,"2012")<>0 Then
+      gOS = 3 ' OS is 2012 of some flavor
+   ElseIf InStr(strOS,"7")<>0 Then
+      gOS = 4 ' OS is Win 7
+   ElseIf InStr(strOS,"2016")<>0 Then
+      gOS = 6 ' OS is 2016 of some flavor
+   ElseIf InStr(strOS,"2019")<>0 Then
+      gOS = 7 ' OS is 2019 of some flavor
+   ElseIf InStr(strOS, "Microsoft Windows Server Standard")<>0 Then
+      gOS = 8 ' OS is Server Standard
+   ElseIf InStr(strOS, "Microsoft Windows Server Datacenter")<>0 Then
+      gOS = 9 ' OS is 2019 of some flavor
+   ElseIf InStr(strOS, "2022")<>0 Then
+      gOS = 9 ' OS is 2022 of some flavor
+   Else
+      WScript.Echo "OS reported as " & strOS
+      gOS = 5 ' OS is some other thing we don't support
+   End If
+
+   ' Check forest functional level
+   GetFunctionalLevel()
+   
+   ' Calculate the uptime (in seconds)
+   lastBootDate = WMIDateStringToDate(lastBoot)   
+   gUptime = DateDiff("s", lastBootDate, Now)
+End Sub
+
+Sub GetFunctionalLevel()
+    On Error Resume Next
+
+    Dim objRootDSE, objPartitions
+    Dim strFFL
+
+    If (gForceFL) Then
+       Exit Sub
+    End If
+    
+
+    Set objRootDSE = GetObject("LDAP://RootDSE")
+    If (Err.Number <> 0) Then
+       WScript.Echo "Could not determine Domain Functional Level!"
+       WScript.Echo "Please try the --forceFL [2003|2008|2012|2016] flag."
+       Err.Clear
+       Exit Sub
+    End If
+
+    Set objPartitions = GetObject("LDAP://CN=Partitions," & objRootDSE.Get("configurationNamingContext"))
+    If (Err.Number <> 0) Then
+       WScript.Echo "Could not determine Domain Functional Level!"
+       WScript.Echo "Please try the --forceFL [2003|2008|2012|2016] flag."
+       Err.Clear
+       Exit Sub
+    End If
+
+    strFFL = objPartitions.Get("msDS-Behavior-Version")
+    If (Err.Number <> 0) Then
+       WScript.Echo "Could not determine Domain Functional Level!"
+       WScript.Echo "Please try the --forceFL [2003|2008|2012|2016] flag."
+       Err.Clear
+       Exit Sub
+    End If
+    'Wscript.Echo "Forest Functional level: " & strFFL
+
+    If strFFL = 0 Then
+        Wscript.Echo "This is a mixed-level forest."
+    ElseIf strFFL = 1 Then
+        Wscript.Echo "This is a Windows Server 2003 interim-level forest."
+    ElseIf strFFL = 2 Then
+        Wscript.Echo "This is a Windows Server 2003 forest."
+    ElseIf strFFL = 3 Then
+        Wscript.Echo "This is a Windows Server 2008 forest."
+    ElseIf strFFL = 4 Then
+        Wscript.Echo "This is a Windows Server 2008R2 forest."
+    ElseIf strFFL = 5 Then
+        Wscript.Echo "This is a Windows Server 2012 forest."
+    ElseIf strFFL = 6 Then
+        Wscript.Echo "This is a Windows Server 2012R2 forest."
+    ElseIf strFFL = 7 Then
+        Wscript.Echo "This is a Windows Server 2016 forest."
+    Else
+        Wscript.Echo "This is an unknown forest."
+    End If
+
+    gFunctionalLevel = strFFL
+
+End Sub
+
+' Firewall Settings Functions
+'*****************************
+
+' Test firewall settings
+Sub TestRemoteAdmin()
+   On Error Resume Next
+   Dim objFirewall, objPolicy
+   Dim objAdminSettings
+
+   Set objFirewall = CreateObject("HNetCfg.FwMgr")
+   Set objPolicy = objFirewall.LocalPolicy.CurrentProfile
+   gFWEnabled = objPolicy.FirewallEnabled
+
+   Set objAdminSettings = objPolicy.RemoteAdminSettings
+   gFWRemoteAdmin = objAdminSettings.Enabled
+   If Err.Number <> 0 Then
+      WScript.Echo "Could not check firewall settings!"
+      WScript.Echo "If the Windows Firewall/ICS service is disabled, this is normal."
+      gFWChecked = false
+      Err.Clear
+   End If
+End Sub
+
+' Sets firewall based on OS
+' Must run TestOS() first, as this function depends on gOS
+' Doesn't actually set the firewall, just pokes the hole for RemoteAdmin
+Sub SetRemoteAdmin()
+   On Error Resume Next
+   Dim WshShell
+   Dim objFirewall, objPolicy, objAdminSettings
+
+   If ((gOS = 1) And (gSP > 0)) Then
+      ' Win 2003 SP1+ command
+      ' Without SP1, there is no "netsh firewall"... 
+      '   just an ICF (Internet Connection Firewall)
+
+      Set WshShell = WScript.CreateObject("WScript.Shell")
+      WshShell.Run "netsh firewall set service type = remoteadmin mode = enable"
+   ElseIf ((gOS = 2) Or (gOS = 3) Or (gOS = 6) Or (gOS = 7) Or (gOS = 8) Or (gOS = 9) or (gOS = 10)) Then
+      ' Enable Remote Administration (FIREWALL)
+      Set objFirewall = CreateObject("HNetCfg.FwMgr")
+      If Err.Number <> 0 Then
+         WScript.Echo 
+         WScript.Echo "Error setting RemoteAdmin!  If Windows Firewall service is disabled, " 
+         WScript.Echo "   run this script with the '--forceFirewall true' argument."
+         WScript.Echo 
+      Else
+         Set objPolicy = objFirewall.LocalPolicy.CurrentProfile
+         Set objAdminSettings = objPolicy.RemoteAdminSettings
+         objAdminSettings.Enabled = True   
+      End If
+   End If
+End Sub
+
+' This function to enable the Remote Event Log Management firewall rule for reading Logon events from Event Viewer directly
+Sub SetRemoteEventLog()
+	Dim WshShell
+
+	WScript.Echo "Enabling Remote Event Log Management firewall rule"
+    Set WshShell = WScript.CreateObject("WScript.Shell")
+    WshShell.Run "netsh advfirewall firewall set rule group=""Remote Event Log Management"" new enable=yes"
+End Sub
+
+' AD User Functions
+'*****************************
+
+' Check to see if the desired AD user exists at all
+' Also sets the gAccountSID global to that user's SID
+Sub TestADUser()
+   On Error Resume Next 
+   Dim objAccount
+   
+   gADUserExists = False
+   
+   ' Get the SID for the given user
+   Set objAccount = gObjSvc.Get("Win32_UserAccount.Name='" & gAccountName & "',Domain='" & gDomain & "'")
+   If Err.Number <> 0 Then
+      WScript.Echo "Could not find user " & gDomain & "\" & gAccountName
+      gAccountSID = ""
+      gADUserExists = False
+      Err.Clear
+   Else
+      gAccountSID = objAccount.SID
+      gADUserExists = True
+   End If
+End Sub
+
+' RDC Functions
+'*****************************
+
+' Checks the Replicating Directory Changes permission on the account name (gAccountName)
+' Depends on TestADUser passing and setting gDomain and gAccountSID properly
+Sub TestRDC
+    Dim objRootLDAP, strPathToDomain, objDomain, objDescriptor
+    Dim objACE
+
+    Set objRootLDAP = GetObject("LDAP://rootDSE")
+    strPathToDomain = "LDAP://" & objRootLDAP.Get("defaultNamingContext") ' e.g. string dc=mydomain,dc=com
+    Set objDomain = GetObject(strPathToDomain)
+    Set objDescriptor = objDomain.Get("ntSecurityDescriptor")
+
+    For Each objACE In objDescriptor.DiscretionaryAcl
+        ' Get ACE entries, looking for account name (gAccountName)
+        If (lcase(objACE.Trustee) = lcase(gDomain & "\" & gAccountName)) Then
+            ' We found the right user, now make sure it's active and has the right permissions
+            If ((objACE.AceType = ADS_ACETYPE_ACCESS_ALLOWED_OBJECT) And _
+                (objACE.Flags = ADS_FLAG_OBJECT_TYPE_PRESENT) And _
+                (objACE.AccessMask = ADS_RIGHT_DS_CONTROL_ACCESS) And _
+                (objACE.ObjectType = SCHEMA_GUID_MS_REPLICATION_GET_CHANGES)) _
+            Then
+                ' Everything checks out
+                gRDCPermissions = True
+                WScript.Echo "RDC Permissions Set: " & gRDCPermissions
+
+                'WScript.Echo "Trustee: " & objACE.Trustee
+                'WScript.Echo "      AceFlags  : " & objACE.AceFlags
+                'WScript.Echo "      AceType   : " & objACE.AceType
+                'WScript.Echo "      Flags     : " & objACE.Flags
+                'WScript.Echo "      ObjectType: " & objACE.objectType
+                'WScript.Echo "      AccessMask: " & objACE.AccessMask
+            
+                ' DS Control Access right.
+                ' Grants the ability to to perform an operation restricted by an
+                ' extended access right. Must specify a rights GUID identifying a
+                ' controlAccessRight object in the Extended-Rights container in the
+                ' configuration partition.
+                'If ((objACE.AccessMask And ADS_RIGHT_DS_CONTROL_ACCESS) <> 0) Then
+                '    Call ListRights(objACE, "ADS_RIGHT_DS_CONTROL_ACCESS")
+                'End If
+             End If
+        Else
+            'WScript.Echo "Skipping " + objACE.Trustee            
+        End If
+    Next
+End Sub
+
+' Sets the Replicating Directory Changes permission on gAccountName (the account name)
+' Depends on TestADUser passing and setting gDomain and gAccountSID properly
+Sub SetRDC
+    Dim objRootLDAP, strPathToDomain, objDomain, objDescriptor
+    Dim objNewAce
+
+    Set objRootLDAP = GetObject("LDAP://rootDSE")
+    strPathToDomain = "LDAP://" & objRootLDAP.Get("defaultNamingContext") ' e.g. string dc=mydomain,dc=com
+    Set objDomain = GetObject(strPathToDomain)
+    Set objDescriptor = objDomain.Get("ntSecurityDescriptor")
+
+    ' Create the new ACE with proper permissions
+
+    Set objNewAce = createObject("AccessControlEntry")
+    objNewAce.AceFlags = 0
+    objNewAce.AceType = ADS_ACETYPE_ACCESS_ALLOWED_OBJECT
+    objNewAce.Flags = ADS_FLAG_OBJECT_TYPE_PRESENT
+    objNewAce.Trustee = gAccountSID
+    objNewAce.AccessMask = ADS_RIGHT_DS_CONTROL_ACCESS 
+    objNewAce.ObjectType = SCHEMA_GUID_MS_REPLICATION_GET_CHANGES
+    objNewAce.InheritedObjectType = SCHEMA_GUID_MS_REPLICATION_GET_CHANGES
+
+    ' Add the new ACE to the DACL
+    objDescriptor.DiscretionaryAcl.AddAce objNewAce
+    objDomain.Put "ntSecurityDescriptor", Array(objDescriptor)
+    objDomain.SetInfo
+End Sub
+
+' ELR Functions
+'*****************************
+
+' Checks that account (gAccountName) is a member of the "Event Log Readers" group
+' Depends on TestADUser passing and setting gAccountSID properly
+Sub TestELR
+    On Error Resume Next
+    Dim objELR
+    Dim objUser, memberGroup
+
+   ' Get our Event Log Readers group
+    Set objELR = GetObject("LDAP://" & gDomainFull & "/<sid=" & ELR_SID & ">")
+	If (objELR.DistinguishedName = "") Then
+	    Set objELR = GetObject("LDAP://CN=Event Log Readers,CN=Builtin," & gDomainFullyQualifiedDomain)
+	    If (objELR.DistinguishedName = "") Then
+	        Set objELR = GetObject("LDAP://<sid=" & ELR_SID & ">")
+		End If
+	End If
+	
+    If (Err.Number <> 0) Then
+        ' Server 2003 likely doesn't have an Event Log Readers group, so don't complain
+        If (gFunctionalLevel >= 3) Then
+            WScript.Echo "Could not find Event Log Readers group"
+        End If
+        
+        Err.Clear
+        Exit Sub
+    End If
+    
+    WScript.Echo  "ELR Group Domain : " & objELR.DistinguishedName
+
+    ' Get all groups that gAccountSID belongs to
+    Set objUser = GetObject("LDAP://" & gDomainFull & "/<sid=" & gAccountSID & ">")
+    For Each memberGroup in objUser.Groups
+        ' Find a group with the same DN as ELR; this is easier than checking SIDs
+        WScript.Echo  gAccountName & " member of Group DN : " & memberGroup.DistinguishedName
+        If (memberGroup.DistinguishedName = objELR.DistinguishedName) Then
+            gELRMember = True
+        End If
+    Next
+End Sub
+
+' Adds the account (gAccountName) to the Event Log Readers group
+' Depends on TestADUser passing and setting gAccountSID properly
+Sub SetELR
+    Dim objELR
+    Dim objUser
+
+    ' Get our Event Log Readers group
+    Set objELR = GetObject("LDAP://" & gDomainFull & "/<sid=" & ELR_SID & ">")
+	If (objELR.DistinguishedName = "") Then
+	    Set objELR = GetObject("LDAP://CN=Event Log Readers,CN=Builtin," & gDomainFullyQualifiedDomain)
+	    If (objELR.DistinguishedName = "") Then
+	        Set objELR = GetObject("LDAP://<sid=" & ELR_SID & ">")
+		End If
+	End If
+    WScript.Echo  "ELR Group Domain : " & objELR.DistinguishedName
+    ' Get our account (gAccountName) user
+    Set objUser = GetObject("LDAP://<sid=" & gAccountSID & ">")
+
+    ' Add our user to the ELR group
+    objELR.Add(objUser.AdsPath)
+End Sub
+
+' Policy Functions
+'*****************************
+
+' Checks Computer Configuration\Policies\Windows Settings\Security Settings\Local Policies\User Rights Assignment\Manage audit and security log
+' Depends on TestADUser passing and setting gDomain properly
+Sub TestManageELPolicy
+    Dim objWMIService, strComputer
+    Dim objItem, colItems, strAccountList
+
+    ' Since this should be running on a DC, let's just assume if RSOP allows it here it will be allowed everywhere
+    strComputer = "."
+    Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\rsop\computer")
+
+    Set colItems = objWMIService.ExecQuery("Select * from RSOP_UserPrivilegeRight")
+    For Each objItem in colItems
+        If (objItem.UserRight = "SeSecurityPrivilege") Then
+            ' Make sure the account (gAccountName) appears in this list
+            For Each strAccountList in objItem.AccountList
+                If (lcase(strAccountList) = lcase(gDomain & "\" & gAccountName)) Then
+                    gManageELPSet = true
+                End If
+            Next
+        End If
+    Next
+End Sub
+
+' Human readable string for OS
+'*****************************
+Function OSToString(OS)
+
+Dim strOS 
+
+If OS = 1 Then
+   strOS = "Windows 2003"
+ElseIf OS = 2 Then
+   strOS = "Windows Server 2008"
+ElseIf OS = 3 Then
+   strOS = "Windows Server 2012"
+ElseIf OS = 4 Then
+   strOS = "Win 7"
+ElseIf OS = 6 Then
+   strOS = "Windows Server 2016"
+ElseIf OS = 7 Then
+   strOS = "Windows Server 2019"
+ElseIf OS = 8 Then
+   strOS = "Microsoft Windows Server Standard"
+ElseIf OS = 9 Then
+   strOS = "Microsoft Windows Server Datacenter"
+ElseIf OS = 10 Then
+   strOS = "Windows Server 2022"
+Else
+   strOS = "Unsupported OS"
+End If
+
+If gR2 <> "" Then
+strOS = strOS & " " & gR2
+End If
+
+If gSP <> 0 Then
+strOS = strOS & " Service Pack " & gSP
+End If
+
+OSToString = strOS
+
+End Function
+
+Function FLToString(FL)
+
+    Dim strFL
+
+    If FL = 0 Then
+        strFL = "Server 2000 Forest"
+    ElseIf FL = 1 Then
+        strFL = "Server 2003 interim-level Forest"
+    ElseIf FL = 2 Then
+        strFL = "Server 2003 Forest"
+    ElseIf FL = 3 Then
+        strFL = "Server 2008 Forest"
+    ElseIf FL = 4 Then
+        strFL = "Server 2008 R2 Forest"
+    ElseIf FL = 5 Then
+        strFL = "Server 2012 Forest"
+    ElseIf FL = 6 Then
+        strFL = "Server 2012 R2 Forest"
+    ElseIf FL = 7 Then
+        strFL = "Server 2016 Forest"
+    Else
+        strFL = "unknown forest"
+    End If
+
+    FLToString = strFL
+
+End Function
+
+
+' Input Function
+'*****************************
+Function UserInput( myPrompt )
+
+WScript.StdOut.Write myPrompt & " "
+UserInput = WScript.StdIn.ReadLine
+
+End Function
+
+Sub AutoRegisterDC()
+    WScript.Echo ""
+    regdec = UserInput("Would you like to register this Domain Controller (y or n)?")
+    If InStr(regdec,"y")=1 Then
+         ' Radio home results
+         If gOauthAuthentication="0" Then   
+            SendAssetRegister()
+            SendAssetUpdate()
+         ElseIf gOauthAuthentication="1" Then
+            SendForAuthToken()
+            SendAssetRegisterEnhancedAuth()
+            SendForAuthToken()
+            SendAssetUpdateEnhancedAuth()         
+         Else
+            WScript.Echo("Register failure. Unauthorized, missing mandatory credentials.")
+         End If
+    End If
+End Sub
+
+' Transport Functions
+'*****************************
+Sub SendAssetRegister()
+
+   Dim url
+   Dim objHTTP
+   Dim data
+
+   WScript.Echo("Registering Domain Controller in cloud...")
+
+   url = gCloudEndpoint + "OnPremAsset.register"
+
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+   
+   Call objHTTP.Open("POST", url, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/x-www-form-urlencoded"
+   
+   data = "api_key=298CF21F81C788EDA27E85C3E2E2C415" & _
+      "&type=" & gAssetType & "&org_id=" & gOrgID & _
+      "&ipaddress_internal=" & gIntIP & "&label=" & gServerLabel & _
+      "&org_token=" & gCustomerID_Token
+
+   On Error Resume Next
+   objHTTP.send(data)
+   
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error sending Domain Controller registration:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("Please verify that the Domain Controller can access the Cisco API ")
+      WScript.Echo("(" & gCloudEndpoint & ") at port 443!")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+
+   'WScript.Echo("Register Response (" & objHTTP.status & "): " & objHTTP.responseText
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Register Success!")
+      gToken = objHTTP.responseText
+   Else
+      WScript.Echo("Register failure, response (" & _
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+   
+End Sub
+
+Sub SendForAuthToken()
+   Dim tokenUrl
+   Dim objHTTP
+   Dim data
+   Dim responseJsonString
+   Dim accessTokenPos
+   Dim accessTokenEndPos
+
+   WScript.Echo("Fetching token...")
+
+   tokenUrl = gTokenEndpoint
+
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+
+   Call objHTTP.Open("GET", tokenUrl, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/json"
+   objHTTP.setRequestHeader "Authorization", "Basic " & EncodeBase64(gClientId & ":" & gClientSecret)
+
+   data = ""
+
+   On Error Resume Next
+   objHTTP.send(data)
+
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error fetching token:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("Please verify that API is accessible ")
+      WScript.Echo("(" & gTokenEndpoint & ") at port 443!")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+
+   'WScript.Echo("Auth token request response (" & objHTTP.status & "): " & objHTTP.responseText)
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Auth token fetched!")
+      responseJsonString = objHTTP.responseText
+      accessTokenPos = InStr(responseJsonString, """access_token""") + Len("""access_token"":")
+      accessTokenEndPos = InStr(accessTokenPos, responseJsonString, ",")
+      gAccessToken = replace(Mid(responseJsonString, accessTokenPos, accessTokenEndPos - accessTokenPos), chr(34), "")
+   Else
+      WScript.Echo("Register failure, response (" & _
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+
+End Sub
+
+Sub SendAssetRegisterEnhancedAuth()
+   Dim url
+   Dim objHTTP
+   Dim data
+   Dim responseJsonString
+   Dim assetidPos
+   Dim assetidEndPos
+
+   WScript.Echo("Registering Domain Controller in cloud...")
+   
+   url = gCloudEndpoint + "/onpremappliances"
+
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+   
+   Call objHTTP.Open("POST", url, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/json"
+   objHTTP.setRequestHeader "Authorization", "Bearer " & gAccessToken
+
+   data = _
+      "{ " & vbCrLf & _
+      "   ""type"": """ & gAssetType & """, " & vbCrLf & _
+      "   ""label"": """ & gServerLabel & """, " & vbCrLf & _
+      "   ""domains"": [""" & gDomainFull & """]," & vbCrLf & _
+      "   ""ipaddress_internal"": [""" & gIntIP & """]" & vbCrLf & _
+      "}"
+
+   On Error Resume Next
+   objHTTP.send(data)
+   
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error sending Domain Controller registration:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("Please verify that the Domain Controller can access the Cisco API ")
+      WScript.Echo("(" & gCloudEndpoint & ") at port 443!")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+
+   'WScript.Echo("Register Response (" & objHTTP.status & "): " & objHTTP.responseText
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Register Success!")
+      responseJsonString = objHTTP.responseText
+      assetidPos = InStr(responseJsonString, """asset_id""") + Len("""asset_id"":")
+      assetidEndPos = InStr(assetidPos, responseJsonString, ",")
+      gToken = Mid(responseJsonString, assetidPos, assetidEndPos - assetidPos)
+   Else
+      WScript.Echo("Register failure, response (" & _
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+
+End Sub
+
+Sub SendAssetUpdateEnhancedAuth()
+   Dim serverTime
+   Dim url
+   Dim objHTTP
+   Dim data
+
+   ' Don't attempt to register unless we have a good token (via a Register)
+   If (gToken = "") Then
+      WScript.Echo("Can't update DC status in the cloud without registering!")
+      Exit Sub
+   End If
+
+   WScript.Echo("Updating DC status in cloud...")
+   
+   serverTime = DateDiff("s", "01/01/1970 00:00:00", Now())
+   
+   url = gCloudEndpoint + "onpremappliances/" + gToken + "/syncs"
+   
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+   
+   Call objHTTP.Open("POST", url, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/json"
+   objHTTP.setRequestHeader "Authorization", "Bearer " & gAccessToken
+
+   data = _
+      "{ " & vbCrLf & _
+      "   ""AssetID"": """ & gToken & """, " & vbCrLf & _
+      "   ""ConfigVersion"": ""1""," & vbCrLf & _
+      "   ""Environment"": { " & vbCrLf & _
+      "      ""Domains"": [""" & gDomainFull & """]," & vbCrLf & _
+      "      ""InternalIPs"": [""" & gIntIP & """]," & vbCrLf & _
+      "      ""ServerTime"": """ & serverTime & """" & vbCrLf & _
+      "   }, " & vbCrLf & _
+      "   ""Status"": { " & vbCrLf & _
+      "      ""Uptime"": """ & gUptime & """ " & vbCrLf & _
+      "   } " & vbCrLf & _
+      "}"
+
+   On Error Resume Next
+   objHTTP.send(data)
+   
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error sending Update:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("If the registration was successful, this may be " & _ 
+         "a problem with the UpdateStatus API call")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+   
+   'WScript.Echo("Update Response (" & objHTTP.status & "): " & objHTTP.responseText
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Update success!")
+   Else
+      WScript.Echo("Update failure, response (" & _ 
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+   
+End Sub
+
+Sub SendAssetUpdate()
+   Dim serverTime
+   Dim url
+   Dim objHTTP
+   Dim data
+
+   ' Don't attempt to register unless we have a good token (via a Register)
+   If (gToken = "") Then
+      WScript.Echo("Can't update DC status in the cloud without registering!")
+      Exit Sub
+   End If
+
+   WScript.Echo("Updating DC status in cloud...")
+   
+   serverTime = DateDiff("s", "01/01/1970 00:00:00", Now())
+   
+   url = gCloudEndpoint + "OnPremAsset.sync"
+   
+   Set objHTTP = CreateObject("MSXML2.XMLHTTP")
+   
+   Call objHTTP.Open("POST", url, FALSE)
+   objHTTP.setRequestHeader "Content-Type","application/json"
+   objHTTP.setRequestHeader "X-OpenDNS-API-Key", "298CF21F81C788EDA27E85C3E2E2C415"
+   
+   data = _
+      "{ " & vbCrLf & _
+      "   ""AssetID"": """ & gToken & """, " & vbCrLf & _
+      "   ""Org_ID"": """ & gOrgID & """, " & vbCrLf & _
+      "   ""Org_Token"": """ & gCustomerID_Token & """, " & vbCrLf & _
+      "   ""ConfigVersion"": ""1""," & vbCrLf & _
+      "   ""Environment"": { " & vbCrLf & _
+      "      ""Domains"": [""" & gDomainFull & """]," & vbCrLf & _
+      "      ""InternalIP"": """ & gIntIP & """," & vbCrLf & _
+      "      ""ServerTime"": """ & serverTime & """" & vbCrLf & _
+      "   }, " & vbCrLf & _
+      "   ""Status"": { " & vbCrLf & _
+      "      ""Uptime"": """ & gUptime & """ " & vbCrLf & _
+      "   } " & vbCrLf & _
+      "}"
+
+   On Error Resume Next
+   objHTTP.send(data)
+   
+   If (Err.Number <> 0) Then
+      WScript.Echo("")
+      WScript.Echo("*****")
+      WScript.Echo("Error sending Update:")
+      WScript.Echo(Err.Description)
+      WScript.Echo("If the Register was successful, this may be " & _ 
+         "a problem with the UpdateStatus API call")
+      WScript.Echo("*****")
+      WScript.Echo("")
+      Err.Clear
+      Exit Sub
+   End If
+   
+   'WScript.Echo("Update Response (" & objHTTP.status & "): " & objHTTP.responseText
+   If (objHTTP.status = 200) Then
+      WScript.Echo("Update success!")
+   Else
+      WScript.Echo("Update failure, response (" & _ 
+         objHTTP.status & "): " & objHTTP.responseText)
+   End If
+   
+End Sub
+
+'Function to Base64 encode a string
+Function EncodeBase64(inData)
+  Dim cOut, sOut, I
+  Dim nGroup, pOut, sGroup
+
+  Const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
+
+  'For each group of 3 bytes
+  For I = 1 To Len(inData) Step 3
+
+    'Create one long from this 3 bytes.
+    nGroup = &H10000 * Asc(Mid(inData, I, 1)) + _
+      &H100 * MyASC(Mid(inData, I + 1, 1)) + MyASC(Mid(inData, I + 2, 1))
+
+    'Oct splits the long To 8 groups with 3 bits
+    nGroup = Oct(nGroup)
+
+    'Add leading zeros
+    nGroup = String(8 - Len(nGroup), "0") & nGroup
+
+    'Convert To base64
+    pOut = Mid(Base64, CLng("&o" & Mid(nGroup, 1, 2)) + 1, 1) + _
+      Mid(Base64, CLng("&o" & Mid(nGroup, 3, 2)) + 1, 1) + _
+      Mid(Base64, CLng("&o" & Mid(nGroup, 5, 2)) + 1, 1) + _
+      Mid(Base64, CLng("&o" & Mid(nGroup, 7, 2)) + 1, 1)
+
+    'Add the part To OutPut string
+    sOut = sOut + pOut
+
+    'Add a new line For Each 76 chars In dest (76*3/4 = 57)
+    'If (I + 2) Mod 57 = 0 Then sOut = sOut + vbCrLf
+  Next
+  Select Case Len(inData) Mod 3
+    Case 1: '8 bit final
+      sOut = Left(sOut, Len(sOut) - 2) + "=="
+    Case 2: '16 bit final
+      sOut = Left(sOut, Len(sOut) - 1) + "="
+  End Select
+  EncodeBase64 = sOut
+End Function
+
+Function MyASC(OneChar)
+  If OneChar = "" Then MyASC = 0 Else MyASC = Asc(OneChar)
+End Function
+
+' Utility function to convert the WMI time format to the VBScript time format 
+Function WMIDateStringToDate(dtmBootup)
+   WMIDateStringToDate = CDate(Mid(dtmBootup, 5, 2) & "/" & _
+      Mid(dtmBootup, 7, 2) & "/" & Left(dtmBootup, 4) _
+      & " " & Mid (dtmBootup, 9, 2) & ":" & _
+      Mid(dtmBootup, 11, 2) & ":" & Mid(dtmBootup,13, 2))
+End Function
+
+
+Function GetIPAddress()
+
+Dim strComputer
+Dim objWMIService
+Dim IPConfigSet
+Dim IPConfig, i, out
+Dim notDone
+Dim IP, index
+
+strComputer = "."
+
+Set objWMIService = GetObject("winmgmts:" _
+    & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")
+
+Set IPConfigSet = objWMIService.ExecQuery _
+    ("Select * from Win32_NetworkAdapterConfiguration Where IPEnabled=TRUE")
+ 
+ReDim IPList(0)
+
+For Each IPConfig in IPConfigSet
+    If Not IsNull(IPConfig.IPAddress) Then 
+        For i=LBound(IPConfig.IPAddress) to UBound(IPConfig.IPAddress)
+            If Not IsNull(IPConfig.IPAddress(i)) Then
+                ' Strip out any IP addresses with : (no IPv6)
+                If Not (Instr(IPConfig.IPAddress(i), ":") > 0) Then
+                   out = IPConfig.IPAddress(i)
+                   IPList(UBound(IPList)) = out
+                   ReDim Preserve IPList(UBound(IPList) + 1)
+               End If
+            End If
+        Next
+    End If
+Next
+
+' Take off the empty one
+If Not UBound(IPList) = 0 Then
+    ReDim Preserve IPList(UBound(IPList) - 1)
+End If
+
+If UBound(IPList) = 0 Then
+    GetIPAddress = out
+    'WScript.Echo ""
+    'WScript.Echo "Detected IP: " & GetIPAddress
+Else
+
+notDone = true
+Do While notDone
+
+' Let user choose IP if more than one
+WScript.Echo ""
+WScript.Echo "Multiple IPs detected "
+
+index = 0
+For Each IP in IPList
+    index = index + 1   
+    WScript.Echo index & ") " & IP
+Next
+WScript.Echo ""
+
+notDone = false
+
+index = UserInput("Please enter the number of the IP you would like to use:")
+
+If Not IsNumeric(index) Then
+    WScript.Echo "Input was not a number - try again"
+    notDone = true
+Else
+    If CInt(index) > UBound(IPList)+1 Then
+        WScript.Echo "Invalid choice - choose again"
+        notDone = true
+    ElseIf (index = 0) Then
+        WScript.Echo "Invalid choice - choose again"
+        notDone = true
+    End If
+End If
+
+Loop
+ 
+GetIPAddress = IPList(index-1)
+
+WScript.Echo "You chose IP: " & GetIPAddress
+
+End If
+
+End Function
+
+' Get Domain Name
+Function GetDomainFullName()
+   Dim DomainFullyQualifiedDomainName
+   Dim DomainFullyQualifiedDomainNameArray
+   Dim DomainNameFECount
+   Dim item
+
+   DomainFullyQualifiedDomainNameArray = Split(gDomainFull,".")
+   DomainFullyQualifiedDomainName=""
+   DomainNameFECount=0
+
+   For each item in DomainFullyQualifiedDomainNameArray
+      If DomainNameFECount = 0 then
+          DomainFullyQualifiedDomainName = "DC=" + item
+      Else
+          DomainFullyQualifiedDomainName = DomainFullyQualifiedDomainName + ",DC=" + item
+      End If
+      DomainNameFECount = DomainNameFECount + 1
+   Next
+   GetDomainFullName = DomainFullyQualifiedDomainName
+End Function
+
+' Gets our domain
+Function GetComputerFullDomainName()
+   On Error Resume Next
+   Dim objItemSet, objItem
+   Set objItemSet = GetObject("winmgmts:\root\cimv2").ExecQuery("select * from Win32_ComputerSystem")
+   For Each objItem in objItemSet
+      GetComputerFullDomainName = lcase(objItem.Domain)
+   Next
+End Function
+
+' Gets our domain without the suffix
+Function GetComputerDomainName()
+   On Error Resume Next
+   Dim objItemSet, objItem, sysInfo
+	If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		Set objItemSet = GetObject("winmgmts:\root\cimv2").ExecQuery("select * from Win32_NTDomain")
+		For Each objItem in objItemSet
+			GetComputerDomainName = objItem.DomainName
+			' If there are multiple domains, just take the first and ignore the rest...
+		Exit For
+		Next
+	End If
+	If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		Set sysInfo = CreateObject("ADSystemInfo")
+		GetComputerDomainName = sysInfo.DomainShortName
+	End If
+	If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty)  then
+        Set WshNetwork = CreateObject("Wscript.Network")
+		GetComputerDomainName = WshNetwork.UserDomain
+   End If
+   If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		Set wshShell = CreateObject( "WScript.Shell" )
+		strNETBIOSName = wshShell.ExpandEnvironmentStrings( "%USERDOMAIN%" )
+		GetComputerDomainName = strNETBIOSName
+	End If
+	If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		Set objSysInfo = CreateObject( "WinNTSystemInfo" )
+		strDomainName = objSysInfo.DomainName
+		GetComputerDomainName = strDomainName
+	End If
+   If (GetComputerDomainName = "") Or (GetComputerDomainName = Empty) then
+		WScript.Echo "NetBIOS name for domain could not be found. Please re-run this script with parameter ""--forcenetbios <NetBIOS>"""
+		WScript.Echo "Example: cscript Cisco-WindowsConfigurationScript-********.wsf --forcenetbios <NetBIOS>"
+		WScript.Quit
+   End If
+End Function
+
+' Gets our hostname
+Function GetComputerHostName()
+   On Error Resume Next
+   Dim objItemSet, objItem
+   Set objItemSet = GetObject("winmgmts:\root\cimv2").ExecQuery("select * from Win32_ComputerSystem")
+   For Each objItem in objItemSet
+      GetComputerHostName = objItem.Name
+   Next
+End Function
+
+' Tells us whether we are properly configured or not
+Function IsConfiguredInFull()
+   IsConfiguredInFull = False
+   
+   ' Force user
+   If (gForceUserExists) Then
+      gADUserExists = True
+      gRDCPermissions = True
+      gELRMember = True
+   End If
+
+   ' Force firewall
+   If (gForceFW) Then
+      gFWRemoteAdmin = True
+   End If
+
+   If (gForceNonVA) Then
+        gELRMember = True
+        gManageELPSet = True
+        If (gADUserExists And gRDCPermissions And gELRMember) Then
+            IsConfiguredInFull = True
+         ElseIf (gFWRemoteAdmin And gADUserExists And gRDCPermissions And gELRMember) Then
+            IsConfiguredInFull = True
+         End If
+
+   End If
+
+   If (gFWRemoteAdmin And gADUserExists And gRDCPermissions And gELRMember) Then
+      IsConfiguredInFull = True
+   End If
+
+End Function
+
+Function IsAdmin
+    IsAdmin = 0
+    On Error Resume Next
+    Dim key
+    key = CreateObject("WScript.Shell").RegRead("HKEY_USERS\S-1-5-19\Environment\TEMP")
+    if Err.Number = 0 Then
+        IsAdmin = 1
+    End If
+    Err.Clear
+End Function
+
+Function CollectArgs
+
+Dim item, args, cur, count
+Set args = WScript.Arguments
+
+count = 0
+For Each item In args
+    If (lcase(item) = "--forceuserexists") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceUserExists = 1
+            Else
+                gForceUserExists = 0
+            End If
+            WScript.Echo "forceUser: " & gForceUserExists
+         End If
+    ElseIf (lcase(item) = "--forcefirewall") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceFW = 1
+            Else
+                gForceFW = 0
+            End If
+            WScript.Echo "forceFirewall: " & cur
+         End If
+    ElseIf (lcase(item) = "--forceadmin") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceAdmin = 1
+            Else
+                gForceAdmin = 0
+            End If
+            WScript.Echo "forceAdmin: " & cur
+         End If
+    ElseIf (lcase(item) = "--forcedomain") Then
+         If (args.length > (count+1)) Then
+            gDomain = args(count+1)
+            WScript.Echo "forceDomain: " & gDomain
+         End If
+    ElseIf (lcase(item) = "--forcefl") Then
+         If (args.length > (count+1)) Then
+            If (args(count+1) = "2003") Then
+                WScript.Echo "Forcing 2003 functional level"
+                gFunctionalLevel = 2
+                gForceFL = true
+            ElseIf (args(count+1) = "2008") Then
+                WScript.Echo "Forcing 2008 functional level"
+                gFunctionalLevel = 3
+                gForceFL = true
+            ElseIf (args(count+1) = "2012") Then
+                WScript.Echo "Forcing 2012 functional level"
+                gFunctionalLevel = 5
+                gForceFL = true
+            ElseIf (args(count+1) = "2016") Then
+                WScript.Echo "Forcing 2016 functional level"
+                gFunctionalLevel = 7
+                gForceFL = true
+            Else
+                WScript.Echo "Unknown functional level: " + args(count+1)
+                WScript.Echo "Please use --forceFl [2003|2008|2012|2016]"
+            End If
+        End If
+    ElseIf (lcase(item) = "--forceregister") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceRegister = 1
+            Else
+                gForceRegister = 0
+            End If
+            WScript.Echo "forceRegister: " & cur
+         End If
+    ElseIf (lcase(item) = "--forcenonva") Then
+        If (args.length > (count+1)) Then
+            cur = args(count+1)
+            If (cur = "true") Then
+                gForceNonVA = 1
+            Else
+                gForceNonVA = 0
+            End If
+            WScript.echo "Non VA Mode : " & gForceNonVA
+        End If
+	  ElseIf (lcase(item) = "--forcenetbios") Then
+         If (args.length > (count+1)) Then
+            cur = args(count+1)
+			      gForceNetBios = Trim(cur)
+         End If
+    ElseIf (lcase(item) = "--username") Then
+        If (args.length > (count+1)) Then
+            cur = Trim(args(count+1))
+            If (cur<>"") Then
+                gAccountName = cur
+            Else
+                gAccountName = ACCOUNT_NAME
+            End If 
+            WScript.echo "Username (Account Name) : " & gAccountName
+        End If
+    Else
+        ' Unrecognized option
+    End If
+    count = count + 1
+Next
+
+End Function
+
+Sub ListRights(objACE_Item, strRight)
+    ' Subroutine to document rights to text file.
+    ' objReport is the output file object, with global scope.
+    If (objACE_Item.objectType = "") _
+            And (objACE_Item.InheritedObjectType = "") Then
+        WScript.Echo "  " & strRight
+    Else
+        If (objACE_Item.InheritedObjectType = "") Then
+            WScript.Echo "  " & strRight & " for SchemaIDGuid: " _
+                & objACE_Item.objectType
+        Else
+            WScript.Echo "  Inherited " & strRight _
+                & " for SchemaIDGuid: " & objACE_Item.InheritedObjectType
+        End If
+    End If
+End Sub
+
+</script>
+</job>
diff --git a/Win32Apps-Source/Cisco Secure Client/check.ps1 b/Win32Apps-Source/Cisco Secure Client/check.ps1
new file mode 100644
index 0000000..5dc124f
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/check.ps1	
@@ -0,0 +1,1235 @@
+<#
+.SYNOPSIS
+    Detects if Cisco Secure Client is installed on the system.
+
+.DESCRIPTION
+    This script performs multi-method detection for Cisco Secure Client installation:
+    - Marker file analysis (checks previous installation results)
+    - Registry detection (primary method)
+    - File system detection (secondary method)
+    - Service detection (tertiary method)
+    - Process detection (to avoid disruption during active sessions)
+    
+    For Intune Win32 app deployment:
+    - Exit 0 = Application is installed (detection successful)
+    - Exit 1 = Application is not installed (detection failed)
+    
+    Runtime tracking:
+    - Script includes runtime diagnostics in output
+    - Self-terminates after 5 minutes (well within Intune's 30-minute limit)
+    - Typical execution time: < 5 seconds
+
+.PARAMETER EnableDebug
+    Switch to enable detailed debug logging to console and file.
+    When enabled, creates detailed logs in C:\ProgramData\CiscoSecureClient\Logs\
+
+.PARAMETER DisableFileLogging
+    Switch to completely disable all file logging operations.
+    When enabled, only console output will be created.
+
+.NOTES
+    Version:        1.1
+    Creation Date:  2025-01-12
+    Purpose:        Intune Win32 App Detection Script
+    Compatibility:  PowerShell 5.1
+    Logging:        Uses comprehensive logging module with CSV export
+#>
+
+[CmdletBinding()]
+param (
+    [switch]$EnableDebug = $false,
+    [switch]$DisableFileLogging = $false
+)
+
+#region Script Configuration
+$MinimumVersion = "5.1.10.233"  # Minimum required version (based on installer package)
+$ApplicationName = "Cisco Secure Client"
+$script:DisableFileLogging = $DisableFileLogging  # Set script-level variable for logging module
+
+# # Import logging module
+# $LoggingModulePath = Join-Path $PSScriptRoot "logging\logging.psm1"
+# if (Test-Path $LoggingModulePath) {
+#     # Suppress module warnings to prevent STDOUT pollution for Intune
+#     Import-Module $LoggingModulePath -Force -WarningAction SilentlyContinue
+#     $LoggingMode = if ($EnableDebug) { 'EnableDebug' } else { 'SilentMode' }
+#     Write-AppDeploymentLog -Message "=== Cisco Secure Client Detection Script Started ===" -Level Information -Mode $LoggingMode
+#     Write-AppDeploymentLog -Message "Script Version: 1.1" -Level Information -Mode $LoggingMode
+#     Write-AppDeploymentLog -Message "EnableDebug: $EnableDebug, DisableFileLogging: $DisableFileLogging" -Level Information -Mode $LoggingMode
+# } else {
+#     # Fallback if logging module not found
+#     $LoggingMode = 'Off'
+#     if ($EnableDebug) {
+#         Write-Host "WARNING: Logging module not found at: $LoggingModulePath" -ForegroundColor Yellow
+#     }
+# }
+
+# Initialize LoggingMode since module import is commented out
+$LoggingMode = if ($EnableDebug) { 'EnableDebug' } else { 'SilentMode' }
+
+#region Logging Function
+
+
+function Write-AppDeploymentLog {
+    [CmdletBinding()]
+    Param (
+        [Parameter(Mandatory = $true)]
+        [string]$Message,
+        [Parameter()]
+        [ValidateSet('Information', 'Warning', 'Error', 'Debug')]
+        [string]$Level = 'Information',
+        [Parameter()]
+        [ValidateSet('EnableDebug', 'SilentMode', 'Off')]
+        [string]$Mode = 'Off'
+    )
+
+    # Determine logging mode - check EnableDebug first, then parameter, then default to Off
+    $loggingMode = if ($EnableDebug) { 
+        'EnableDebug' 
+    } elseif ($Mode -ne 'Off') { 
+        $Mode 
+    } else { 
+        'Off' 
+    }
+
+    # Exit early if logging is completely disabled
+    if ($loggingMode -eq 'Off') {
+        return
+    }
+
+    # Enhanced caller information using improved logic from Write-EnhancedLog
+    $callStack = Get-PSCallStack
+    
+    # Simplified and corrected function name detection logic
+    $callerFunction = '<Unknown>'
+    if ($callStack.Count -ge 2) {
+        $caller = $callStack[1]
+        
+        # Use the same simple approach as Write-EnhancedLog that works correctly
+        if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+            # This is a function name
+            $callerFunction = $caller.Command
+        } else {
+            # This is either main script execution or a script file name - use MainScript
+            $callerFunction = 'MainScript'
+        }
+    }
+    
+    # Get parent script name
+    $parentScriptName = try {
+        Get-ParentScriptName
+    } catch {
+        "UnknownScript"
+    }
+    
+    # Get line number and script name for detailed logging
+    $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+    $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+        Split-Path -Leaf $callStack[1].ScriptName 
+    } else { 
+        $parentScriptName 
+    }
+
+    # Create enhanced caller information combining both approaches
+    $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+    $detailedCallerInfo = "[$scriptFileName`:$lineNumber $callerFunction]"
+
+    $timeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $fileLogMessage = "[$timeStamp] [$Level] $enhancedCallerInfo - $Message"
+    $consoleLogMessage = "[$Level] $enhancedCallerInfo - $Message" # No timestamp for console
+
+    #region Local File Logging
+    # Skip all file logging if DisableFileLogging is set
+    if ($script:DisableFileLogging) {
+        return
+    }
+    
+    # Use session-based paths if available, otherwise fall back to per-call generation
+    if ($script:SessionLogFilePath -and $script:SessionFullLogDirectory) {
+        $logFilePath = $script:SessionLogFilePath
+        $logDirectory = $script:SessionFullLogDirectory
+    } else {
+        # Fallback to old method if session variables aren't set
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        $logDirectory = "C:\ProgramData\CiscoSecureClient\Logs"
+        $fullLogDirectory = Join-Path -Path $logDirectory -ChildPath $dateFolder
+        $fullLogDirectory = Join-Path -Path $fullLogDirectory -ChildPath $parentScriptName
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.log"
+        $logFilePath = Join-Path -Path $fullLogDirectory -ChildPath $logFileName
+        $logDirectory = $fullLogDirectory
+    }
+    
+    if (-not (Test-Path -Path $logDirectory)) {
+        New-Item -ItemType Directory -Path $logDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+    }
+    
+    if (Test-Path -Path $logDirectory) {
+        Add-Content -Path $logFilePath -Value $fileLogMessage -ErrorAction SilentlyContinue
+        
+        # Log rotation for local files (keep max 7 files)
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $logFiles = Get-ChildItem -Path $logDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.log" | Sort-Object LastWriteTime -Descending
+            if ($logFiles.Count -gt 7) {
+                $filesToRemove = $logFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for log rotation
+        }
+    }
+    #endregion Local File Logging
+
+    #region Network Share CSV Logging
+    # Network logging: Only save CSV format logs under a parent job folder for better organization
+    try {
+        $hostname = $env:COMPUTERNAME
+        $jobName = "CiscoSecureClient"  # Parent job folder name
+        $networkBasePath = "\\AZR1PSCCM02\.logs\$jobName\$hostname"
+        
+        # Test network connectivity first
+        $networkAvailable = Test-Path "\\AZR1PSCCM02\.logs" -ErrorAction SilentlyContinue
+        
+        if ($networkAvailable) {
+            # Use session-based paths if available
+            if ($script:SessionDateFolder -and $script:SessionParentScript -and $script:SessionCSVFileName) {
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $script:SessionDateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionParentScript
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionCSVFileName
+            } else {
+                # Fallback method
+                $dateFolder = Get-Date -Format "yyyy-MM-dd"
+                $parentScriptName = Get-ParentScriptName
+                $userContext = Get-CurrentUser
+                $callingScript = Get-CallingScriptName
+                $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+                
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $dateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $parentScriptName
+                $networkCSVFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $networkCSVFileName
+            }
+            
+            if (-not (Test-Path -Path $fullNetworkCSVPath)) {
+                New-Item -ItemType Directory -Path $fullNetworkCSVPath -Force -ErrorAction SilentlyContinue | Out-Null
+            }
+            
+            if (Test-Path -Path $fullNetworkCSVPath) {
+                # Create CSV entry for network logging
+                $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+                $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+                $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+                
+                # Get caller information
+                $callStack = Get-PSCallStack
+                $callerFunction = '<Unknown>'
+                if ($callStack.Count -ge 2) {
+                    $caller = $callStack[1]
+                    if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+                        $callerFunction = $caller.Command
+                    } else {
+                        $callerFunction = 'MainScript'
+                    }
+                }
+                
+                $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+                $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+                    Split-Path -Leaf $callStack[1].ScriptName 
+                } else { 
+                    $parentScriptName 
+                }
+                
+                $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+                
+                $networkCSVEntry = [PSCustomObject]@{
+                    Timestamp       = $timeStamp
+                    Level           = $Level
+                    ParentScript    = $parentScriptName
+                    CallingScript   = $callingScript
+                    ScriptName      = $scriptFileName
+                    FunctionName    = $callerFunction
+                    LineNumber      = $lineNumber
+                    Message         = $Message
+                    Hostname        = $env:COMPUTERNAME
+                    UserType        = $userContext.UserType
+                    UserName        = $userContext.UserName
+                    FullUserContext = $userContext.FullUserContext
+                    CallerInfo      = $enhancedCallerInfo
+                    JobName         = $jobName
+                    LogType         = "NetworkCSV"
+                }
+                
+                # Check if network CSV exists, if not create with headers
+                if (-not (Test-Path -Path $networkCSVFile)) {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -ErrorAction SilentlyContinue
+                } else {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -Append -ErrorAction SilentlyContinue
+                }
+                
+                # Network CSV log rotation (keep max 5 files per machine per script)
+                try {
+                    $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+                    $networkCSVFiles = Get-ChildItem -Path $fullNetworkCSVPath -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+                    if ($networkCSVFiles.Count -gt 5) {
+                        $filesToRemove = $networkCSVFiles | Select-Object -Skip 5
+                        foreach ($file in $filesToRemove) {
+                            Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                        }
+                    }
+                }
+                catch {
+                    # Silent error handling for network CSV log rotation
+                }
+            }
+        }
+    }
+    catch {
+        # Silent error handling for network CSV logging - don't interfere with main script
+    }
+    #endregion Network Share CSV Logging
+
+    #region CSV Logging
+    try {
+        # Use session-based paths if available
+        if ($script:SessionCSVFilePath -and $script:SessionFullCSVDirectory) {
+            $csvLogPath = $script:SessionCSVFilePath
+            $csvDirectory = $script:SessionFullCSVDirectory
+        } else {
+            # Fallback method
+            $userContext = Get-CurrentUser
+            $callingScript = Get-CallingScriptName
+            $parentScriptName = Get-ParentScriptName
+            $dateFolder = Get-Date -Format "yyyy-MM-dd"
+            $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+            
+            $csvLogDirectory = "C:\ProgramData\CiscoSecureClient\Logs\CSV"
+            $fullCSVDirectory = Join-Path -Path $csvLogDirectory -ChildPath $dateFolder
+            $fullCSVDirectory = Join-Path -Path $fullCSVDirectory -ChildPath $parentScriptName
+            $csvFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+            $csvLogPath = Join-Path -Path $fullCSVDirectory -ChildPath $csvFileName
+            $csvDirectory = $fullCSVDirectory
+        }
+        
+        if (-not (Test-Path -Path $csvDirectory)) {
+            New-Item -ItemType Directory -Path $csvDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+        }
+        
+        # Use session context if available, otherwise get fresh context
+        $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+        $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+        $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+        
+        $csvEntry = [PSCustomObject]@{
+            Timestamp       = $timeStamp
+            Level           = $Level
+            ParentScript    = $parentScriptName
+            CallingScript   = $callingScript
+            ScriptName      = $scriptFileName
+            FunctionName    = $callerFunction
+            LineNumber      = $lineNumber
+            Message         = $Message
+            Hostname        = $env:COMPUTERNAME
+            UserType        = $userContext.UserType
+            UserName        = $userContext.UserName
+            FullUserContext = $userContext.FullUserContext
+            CallerInfo      = $enhancedCallerInfo
+        }
+        
+        # Check if CSV exists, if not create with headers
+        if (-not (Test-Path -Path $csvLogPath)) {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -ErrorAction SilentlyContinue
+        } else {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -Append -ErrorAction SilentlyContinue
+        }
+        
+        # CSV log rotation
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $csvFiles = Get-ChildItem -Path $csvDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+            if ($csvFiles.Count -gt 7) {
+                $filesToRemove = $csvFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for CSV log rotation
+        }
+    }
+    catch {
+        # Silent error handling for CSV logging
+    }
+    #endregion CSV Logging
+
+    #region Console Output (only in EnableDebug mode)
+    if ($loggingMode -eq 'EnableDebug') {
+        switch ($Level.ToUpper()) {
+            'ERROR' { Write-Host $consoleLogMessage -ForegroundColor Red }
+            'WARNING' { Write-Host $consoleLogMessage -ForegroundColor Yellow }
+            'INFORMATION' { Write-Host $consoleLogMessage -ForegroundColor White }
+            'DEBUG' { Write-Host $consoleLogMessage -ForegroundColor Gray }
+        }
+    }
+    #endregion Console Output
+}
+
+function Write-EnhancedLog {
+    [CmdletBinding()]
+    param (
+        [string]$Message,
+        [string]$Level = 'INFO',
+        [string]$LoggingMode = 'SilentMode'
+    )
+
+    # Get the PowerShell call stack to determine the actual calling function
+    $callStack = Get-PSCallStack
+    $callerFunction = if ($callStack.Count -ge 2) { $callStack[1].Command } else { '<Unknown>' }
+
+    # Get the parent script name
+    $parentScriptName = Get-ParentScriptName
+
+    # Map enhanced log levels to CiscoApp log levels
+    $mappedLevel = switch ($Level.ToUpper()) {
+        'CRITICAL' { 'Error' }
+        'ERROR'    { 'Error' }
+        'WARNING'  { 'Warning' }
+        'INFO'     { 'Information' }
+        'DEBUG'    { 'Debug' }
+        'NOTICE'   { 'Information' }
+        'IMPORTANT' { 'Information' }
+        'OUTPUT'   { 'Information' }
+        'SIGNIFICANT' { 'Information' }
+        'VERBOSE'  { 'Debug' }
+        'VERYVERBOSE' { 'Debug' }
+        'SOMEWHATVERBOSE' { 'Debug' }
+        'SYSTEM'   { 'Information' }
+        'INTERNALCOMMENT' { 'Debug' }
+        default    { 'Information' }
+    }
+
+    # Format message with caller information
+    $formattedMessage = "[$parentScriptName.$callerFunction] $Message"
+
+    # Use the existing Write-AppDeploymentLog function
+    Write-AppDeploymentLog -Message $formattedMessage -Level $mappedLevel -Mode $LoggingMode
+}
+
+#region Helper Functions
+
+
+#region Error Handling
+function Handle-Error {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [System.Management.Automation.ErrorRecord]$ErrorRecord,
+        [string]$CustomMessage = "",
+        [string]$LoggingMode = "SilentMode"
+    )
+
+    try {
+        if ($PSVersionTable.PSVersion.Major -ge 7) {
+            $fullErrorDetails = Get-Error -InputObject $ErrorRecord | Out-String
+        } else {
+            $fullErrorDetails = $ErrorRecord.Exception | Format-List * -Force | Out-String
+        }
+
+        $errorMessage = if ($CustomMessage) {
+            "$CustomMessage - Exception: $($ErrorRecord.Exception.Message)"
+        } else {
+            "Exception Message: $($ErrorRecord.Exception.Message)"
+        }
+
+        Write-AppDeploymentLog -Message $errorMessage -Level Error -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Full Exception Details: $fullErrorDetails" -Level Debug -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Script Line Number: $($ErrorRecord.InvocationInfo.ScriptLineNumber)" -Level Debug -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Position Message: $($ErrorRecord.InvocationInfo.PositionMessage)" -Level Debug -Mode $LoggingMode
+    } 
+    catch {
+        # Fallback error handling in case of an unexpected error in the try block
+        Write-AppDeploymentLog -Message "An error occurred while handling another error. Original Exception: $($ErrorRecord.Exception.Message)" -Level Error -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Handler Exception: $($_.Exception.Message)" -Level Error -Mode $LoggingMode
+    }
+}
+#endregion Error Handling
+
+function Get-ParentScriptName {
+    [CmdletBinding()]
+    param ()
+
+    try {
+        # Get the current call stack
+        $callStack = Get-PSCallStack
+
+        # If there is a call stack, return the top-most script name
+        if ($callStack.Count -gt 0) {
+            foreach ($frame in $callStack) {
+                if ($frame.ScriptName) {
+                    $parentScriptName = $frame.ScriptName
+                    # Write-EnhancedLog -Message "Found script in call stack: $parentScriptName" -Level "INFO"
+                }
+            }
+
+            if (-not [string]::IsNullOrEmpty($parentScriptName)) {
+                $parentScriptName = [System.IO.Path]::GetFileNameWithoutExtension($parentScriptName)
+                return $parentScriptName
+            }
+        }
+
+        # If no script name was found, return 'UnknownScript'
+        Write-EnhancedLog -Message "No script name found in the call stack." -Level "WARNING"
+        return "UnknownScript"
+    }
+    catch {
+        Write-EnhancedLog -Message "An error occurred while retrieving the parent script name: $_" -Level "ERROR"
+        return "UnknownScript"
+    }
+}
+
+function Get-CurrentUser {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the current user context
+        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
+        $computerName = $env:COMPUTERNAME
+        
+        # Check if running as SYSTEM
+        if ($currentUser -like "*SYSTEM*" -or $currentUser -eq "NT AUTHORITY\SYSTEM") {
+            return @{
+                UserType = "SYSTEM"
+                UserName = "LocalSystem"
+                ComputerName = $computerName
+                FullUserContext = "SYSTEM-LocalSystem"
+            }
+        }
+        
+        # Extract domain and username
+        if ($currentUser.Contains('\')) {
+            $domain = $currentUser.Split('\')[0]
+            $userName = $currentUser.Split('\')[1]
+        } else {
+            $domain = $env:USERDOMAIN
+            $userName = $currentUser
+        }
+        
+        # Determine user type based on group membership
+        $userType = "User"
+        try {
+            $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
+            if ($isAdmin) {
+                $userType = "Admin"
+            }
+        }
+        catch {
+            # If we can't determine admin status, default to User
+            $userType = "User"
+        }
+        
+        # Sanitize names for file naming (remove invalid characters)
+        $userName = $userName -replace '[<>:"/\\|?*]', '_'
+        $userType = $userType -replace '[<>:"/\\|?*]', '_'
+        
+        return @{
+            UserType = $userType
+            UserName = $userName
+            ComputerName = $computerName
+            FullUserContext = "$userType-$userName"
+        }
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to get current user context: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        return @{
+            UserType = "Unknown"
+            UserName = "UnknownUser"
+            ComputerName = $env:COMPUTERNAME
+            FullUserContext = "Unknown-UnknownUser"
+        }
+    }
+}
+
+function Get-CallingScriptName {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the call stack
+        $callStack = Get-PSCallStack
+        
+        # Look for the actual calling script (not this script or logging functions)
+        $callingScript = "UnknownCaller"
+        
+        # Skip internal logging functions and Discovery script itself
+        $skipFunctions = @('Write-AppDeploymentLog', 'Write-EnhancedLog', 'Handle-Error', 'Get-CallingScriptName', 'Get-CurrentUser')
+        $skipScripts = @('Discovery', 'Discovery.ps1')
+        
+        # Start from index 1 to skip the current function
+        for ($i = 1; $i -lt $callStack.Count; $i++) {
+            $frame = $callStack[$i]
+            
+            # Check if this frame should be skipped
+            $shouldSkip = $false
+            
+            # Skip if it's one of our internal functions
+            if ($frame.Command -and $frame.Command -in $skipFunctions) {
+                $shouldSkip = $true
+            }
+            
+            # Skip if it's the Discovery script itself
+            if ($frame.ScriptName) {
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                if ($scriptName -in $skipScripts) {
+                    $shouldSkip = $true
+                }
+            }
+            
+            # If we shouldn't skip this frame, use it
+            if (-not $shouldSkip) {
+                if ($frame.ScriptName) {
+                    $callingScript = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                    break
+                }
+                elseif ($frame.Command -and $frame.Command -ne "<ScriptBlock>") {
+                    $callingScript = $frame.Command
+                    break
+                }
+            }
+        }
+        
+        # If we still haven't found a caller, determine the execution context
+        if ($callingScript -eq "UnknownCaller") {
+            # Check execution context
+            if ($callStack.Count -le 3) {
+                # Very short call stack suggests direct execution
+                $callingScript = "DirectExecution"
+            }
+            elseif ($MyInvocation.InvocationName -and $MyInvocation.InvocationName -ne "Get-CallingScriptName") {
+                # Use the invocation name if available
+                $callingScript = $MyInvocation.InvocationName
+            }
+            elseif ($PSCommandPath) {
+                # Check if we have a command path (script execution)
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($PSCommandPath)
+                if ($scriptName -and $scriptName -notin $skipScripts) {
+                    $callingScript = $scriptName
+                } else {
+                    $callingScript = "PowerShellExecution"
+                }
+            }
+            else {
+                # Check the host name to determine execution context
+                $hostName = $Host.Name
+                switch ($hostName) {
+                    "ConsoleHost" { $callingScript = "PowerShellConsole" }
+                    "Windows PowerShell ISE Host" { $callingScript = "PowerShell_ISE" }
+                    "ServerRemoteHost" { $callingScript = "RemoteExecution" }
+                    "Visual Studio Code Host" { $callingScript = "VSCode" }
+                    default { $callingScript = "PowerShellHost-$hostName" }
+                }
+            }
+        }
+        
+        return $callingScript
+    }
+    catch {
+        # In case of any error, provide a meaningful fallback
+        try {
+            $hostName = $Host.Name
+            return "ErrorFallback-$hostName"
+        }
+        catch {
+            return "ErrorFallback-Unknown"
+        }
+    }
+}
+
+
+#region Transcript Management Functions
+function Start-CiscoAppTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LogDirectory = "C:\ProgramData\CiscoSecureClient\Logs",
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-AppDeploymentLog -Message "Transcript not started - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $null
+        }
+        
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create directory structure: Logs/Transcript/{Date}/{ParentScript}
+        $transcriptDirectory = Join-Path -Path $LogDirectory -ChildPath "Transcript"
+        $fullTranscriptDirectory = Join-Path -Path $transcriptDirectory -ChildPath $dateFolder
+        $fullTranscriptDirectory = Join-Path -Path $fullTranscriptDirectory -ChildPath $parentScriptName
+        
+        if (-not (Test-Path -Path $fullTranscriptDirectory)) {
+            New-Item -ItemType Directory -Path $fullTranscriptDirectory -Force | Out-Null
+        }
+        
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        $transcriptPath = Join-Path -Path $fullTranscriptDirectory -ChildPath $transcriptFileName
+        
+        # Start transcript with error handling and suppress all console output
+        try {
+            Start-Transcript -Path $transcriptPath -ErrorAction Stop | Out-Null
+            Write-AppDeploymentLog -Message "Transcript started successfully at: $transcriptPath" -Level Information -Mode $LoggingMode
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Failed to start transcript at $transcriptPath" -LoggingMode $LoggingMode
+            return $null
+        }
+        
+        # Transcript rotation
+        try {
+            $transcriptFiles = Get-ChildItem -Path $fullTranscriptDirectory -Filter "*-*-*-*-$parentScriptName-transcript*.log" | Sort-Object LastWriteTime -Descending
+            if ($transcriptFiles.Count -gt 7) {
+                $filesToRemove = $transcriptFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                    Write-AppDeploymentLog -Message "Removed old transcript file: $($file.FullName)" -Level Debug -Mode $LoggingMode
+                }
+            }
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error during transcript file rotation" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptPath
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Start-CiscoAppTranscript function" -LoggingMode $LoggingMode
+        return $null
+    }
+}
+
+function Stop-CiscoAppTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-AppDeploymentLog -Message "Transcript not stopped - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $false
+        }
+        
+        # Check if transcript is running before attempting to stop
+        $transcriptRunning = $false
+        try {
+            # Try to stop transcript and suppress all console output
+            Stop-Transcript -ErrorAction Stop | Out-Null
+            $transcriptRunning = $true
+            Write-AppDeploymentLog -Message "Transcript stopped successfully." -Level Information -Mode $LoggingMode
+        }
+        catch [System.InvalidOperationException] {
+            # This is expected if no transcript is running
+            Write-AppDeploymentLog -Message "No active transcript to stop." -Level Debug -Mode $LoggingMode
+        }
+        catch {
+            # Other transcript-related errors
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error stopping transcript" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptRunning
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Stop-CiscoAppTranscript function" -LoggingMode $LoggingMode
+        return $false
+    }
+}
+
+function Get-TranscriptFilePath {
+    [CmdletBinding()]
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$TranscriptsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+    
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: Transcript/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+        
+        # Generate timestamp for unique transcript file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the transcript file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-transcript-{Timestamp}.log
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        
+        # Combine the full path
+        $transcriptFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $transcriptFileName
+        
+        return $transcriptFilePath
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to generate transcript file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-fallback-$timestamp.log"
+    }
+}
+#endregion Transcript Management Functions
+function Get-CSVLogFilePath {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [string]$LogsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: PSF/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+
+        # Generate timestamp for unique log file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the log file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-log-{Timestamp}.csv
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-$timestamp.csv"
+        
+        # Combine the full path
+        $csvLogFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $logFileName
+        
+        return $csvLogFilePath
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to generate CSV log file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-fallback-$timestamp.csv"
+    }
+}
+
+
+
+
+#endregion Helper Functions
+
+
+#endregion Logging Function
+
+#endregion
+
+#region Detection Functions
+
+#region Marker File Analysis
+function Test-MarkerFile {
+    <#
+    .SYNOPSIS
+        Checks for installation marker file from previous installations
+    #>
+    param(
+        [string]$FilePath,
+        [int]$MaxAgeHours = 168  # 7 days default
+    )
+    
+    try {
+        Write-AppDeploymentLog -Message "Checking marker file: $FilePath" -Level Debug -Mode $LoggingMode
+        
+        # Check if marker file exists
+        if (-not (Test-Path -Path $FilePath)) {
+            Write-AppDeploymentLog -Message "Marker file does not exist. Installation has never been run." -Level Information -Mode $LoggingMode
+            return @{ IsValid = $false; InstallationFound = $false; Reason = "FileNotFound" }
+        }
+        
+        # Check file age
+        $fileInfo = Get-Item -Path $FilePath
+        $fileAge = (Get-Date) - $fileInfo.LastWriteTime
+        $fileAgeHours = $fileAge.TotalHours
+        
+        if ($fileAgeHours -gt $MaxAgeHours) {
+            Write-AppDeploymentLog -Message "Marker file is stale (age: $([math]::Round($fileAgeHours, 2)) hours, max: $MaxAgeHours hours)." -Level Information -Mode $LoggingMode
+            return @{ IsValid = $false; InstallationFound = $false; Reason = "FileStale"; FileAgeHours = $fileAgeHours }
+        }
+        
+        Write-AppDeploymentLog -Message "Marker file exists and is current (age: $([math]::Round($fileAgeHours, 2)) hours). Analyzing content..." -Level Debug -Mode $LoggingMode
+        
+        # Read and parse JSON content
+        $jsonContent = Get-Content -Path $FilePath -Raw -ErrorAction Stop
+        $markerData = $jsonContent | ConvertFrom-Json -ErrorAction Stop
+        
+        # Validate required fields exist
+        if (-not $markerData.InstallationTimestamp -or -not $markerData.InstallationStatus) {
+            Write-AppDeploymentLog -Message "Marker file has invalid structure. Missing required fields." -Level Warning -Mode $LoggingMode
+            return @{ IsValid = $false; InstallationFound = $false; Reason = "InvalidStructure" }
+        }
+        
+        # Check installation status
+        $status = $markerData.InstallationStatus
+        Write-AppDeploymentLog -Message "Previous installation status: $status" -Level Debug -Mode $LoggingMode
+        
+        if ($status -eq "Success") {
+            Write-AppDeploymentLog -Message "Marker file indicates successful installation." -Level Information -Mode $LoggingMode
+            return @{ 
+                IsValid = $true
+                InstallationFound = $true
+                Reason = "InstallationSuccess"
+                InstallationStatus = $status
+                InstalledVersion = $markerData.InstalledVersion
+                ComponentsInstalled = $markerData.ComponentsInstalled
+            }
+        } else {
+            Write-AppDeploymentLog -Message "Marker file indicates installation was not fully successful (status: $status)." -Level Warning -Mode $LoggingMode
+            return @{ 
+                IsValid = $true
+                InstallationFound = $false
+                Reason = "InstallationIncomplete"
+                InstallationStatus = $status
+            }
+        }
+    }
+    catch {
+        if ($null -ne (Get-Command Handle-Error -ErrorAction SilentlyContinue)) {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Failed to analyze marker file: $FilePath" -LoggingMode $LoggingMode
+        }
+        Write-AppDeploymentLog -Message "Error reading marker file. Treating as invalid." -Level Error -Mode $LoggingMode
+        return @{ IsValid = $false; InstallationFound = $false; Reason = "FileReadError"; Error = $_.Exception.Message }
+    }
+}
+#endregion Marker File Analysis
+
+function Test-CiscoProcesses {
+    <#
+    .SYNOPSIS
+        Checks for running Cisco processes to avoid disruption
+    #>
+    param()
+    
+    Write-AppDeploymentLog -Message "Checking for active Cisco processes..." -Level Debug -Mode $LoggingMode
+    
+    $ciscoProcesses = @(
+        "vpnui",           # Cisco AnyConnect VPN UI
+        "vpnagent",        # Cisco AnyConnect VPN Agent
+        "csc_umbrellaagent", # Cisco Umbrella Agent
+        "acwebsecagent"    # Cisco Web Security Agent
+    )
+    
+    foreach ($processName in $ciscoProcesses) {
+        $process = Get-Process -Name $processName -ErrorAction SilentlyContinue
+        if ($null -ne $process) {
+            Write-AppDeploymentLog -Message "Active Cisco process found: $processName (PID: $($process.Id))" -Level Information -Mode $LoggingMode
+            return $true
+        }
+    }
+    
+    Write-AppDeploymentLog -Message "No active Cisco processes found." -Level Debug -Mode $LoggingMode
+    return $false
+}
+
+function Test-CiscoRegistry {
+    <#
+    .SYNOPSIS
+        Checks registry for Cisco Secure Client installation
+    #>
+    param()
+    
+    Write-AppDeploymentLog -Message "Starting registry detection for Cisco Secure Client..." -Level Debug -Mode $LoggingMode
+    
+    $registryPaths = @(
+        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*",
+        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*",
+        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*"
+    )
+    
+    $searchPatterns = @(
+        "*Cisco Secure Client*",
+        "*Cisco AnyConnect*",
+        "*Cisco Umbrella*"
+    )
+    
+    foreach ($path in $registryPaths) {
+        if (Test-Path $path) {
+            Write-AppDeploymentLog -Message "Checking registry path: $path" -Level Debug -Mode $LoggingMode
+            $items = Get-ItemProperty -Path $path -ErrorAction SilentlyContinue
+            
+            foreach ($item in $items) {
+                if ($null -eq $item.DisplayName) { continue }
+                
+                foreach ($pattern in $searchPatterns) {
+                    if ($item.DisplayName -like $pattern) {
+                        Write-AppDeploymentLog -Message "Found matching registry entry: $($item.DisplayName)" -Level Information -Mode $LoggingMode
+                        
+                        # Version check if version info is available
+                        if ($item.DisplayVersion) {
+                            try {
+                                $installedVersion = [version]$item.DisplayVersion
+                                $requiredVersion = [version]$MinimumVersion
+                                
+                                if ($installedVersion -ge $requiredVersion) {
+                                    Write-AppDeploymentLog -Message "Version check passed: $($item.DisplayVersion) >= $MinimumVersion" -Level Information -Mode $LoggingMode
+                                    return $true
+                                } else {
+                                    Write-AppDeploymentLog -Message "Version check failed: $($item.DisplayVersion) < $MinimumVersion" -Level Warning -Mode $LoggingMode
+                                }
+                            }
+                            catch {
+                                # If version parsing fails, consider it installed
+                                Write-AppDeploymentLog -Message "Version parsing failed for $($item.DisplayName), treating as installed" -Level Warning -Mode $LoggingMode
+                                return $true
+                            }
+                        }
+                        else {
+                            # No version info, but product found
+                            Write-AppDeploymentLog -Message "Found $($item.DisplayName) in registry (no version info available)" -Level Information -Mode $LoggingMode
+                            return $true
+                        }
+                    }
+                }
+            }
+        }
+    }
+    
+    Write-AppDeploymentLog -Message "No Cisco Secure Client found in registry." -Level Debug -Mode $LoggingMode
+    return $false
+}
+
+function Test-CiscoFiles {
+    <#
+    .SYNOPSIS
+        Checks for Cisco Secure Client files in common installation paths
+    #>
+    param()
+    
+    $filePaths = @(
+        "${env:ProgramFiles}\Cisco\Cisco Secure Client\vpnui.exe",
+        "${env:ProgramFiles(x86)}\Cisco\Cisco Secure Client\vpnui.exe",
+        "${env:ProgramFiles}\Cisco\Cisco AnyConnect Secure Mobility Client\vpnui.exe",
+        "${env:ProgramFiles(x86)}\Cisco\Cisco AnyConnect Secure Mobility Client\vpnui.exe"
+    )
+    
+    foreach ($path in $filePaths) {
+        if (Test-Path -Path $path -ErrorAction SilentlyContinue) {
+            # Check file version if possible
+            try {
+                $fileInfo = Get-Item -Path $path -ErrorAction Stop
+                $fileVersion = $fileInfo.VersionInfo.ProductVersion
+                
+                if ($fileVersion) {
+                    $installedVersion = [version]$fileVersion
+                    $requiredVersion = [version]$MinimumVersion
+                    
+                    if ($installedVersion -ge $requiredVersion) {
+                        if ($VerboseOutput) {
+                            Write-Output "Found Cisco executable at: $path (version $fileVersion)"
+                        }
+                        return $true
+                    }
+                }
+                else {
+                    # File exists but no version info
+                    if ($VerboseOutput) {
+                        Write-Output "Found Cisco executable at: $path (no version info)"
+                    }
+                    return $true
+                }
+            }
+            catch {
+                # File exists but couldn't read version
+                if ($VerboseOutput) {
+                    Write-Output "Found Cisco executable at: $path (error reading version)"
+                }
+                return $true
+            }
+        }
+    }
+    
+    return $false
+}
+
+function Test-CiscoServices {
+    <#
+    .SYNOPSIS
+        Checks for Cisco services
+    #>
+    param()
+    
+    $serviceNames = @(
+        "csc_umbrellaagent",  # Cisco Umbrella Roaming Client
+        "vpnagent",           # Cisco AnyConnect Secure Mobility Agent
+        "acwebsecagent"       # Cisco AnyConnect Web Security Agent
+    )
+    
+    foreach ($serviceName in $serviceNames) {
+        $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
+        if ($null -ne $service) {
+            if ($VerboseOutput) {
+                Write-Output "Found Cisco service: $serviceName (Status: $($service.Status))"
+            }
+            return $true
+        }
+    }
+    
+    return $false
+}
+#endregion
+
+#region Main Detection Logic
+# Start timing for diagnostics
+$ScriptStartTime = Get-Date
+$MaxRuntime = 300  # 5 minutes max (well within 30-minute limit)
+
+try {
+    Write-AppDeploymentLog -Message "Starting main detection logic..." -Level Information -Mode $LoggingMode
+    
+    #region Marker File Analysis
+    $markerFilePath = "C:\ProgramData\CiscoSecureClient\installation-results.json"
+    $markerFileMaxAgeHours = 168  # 7 days
+    
+    Write-AppDeploymentLog -Message "Checking installation marker file..." -Level Information -Mode $LoggingMode
+    $markerResult = Test-MarkerFile -FilePath $markerFilePath -MaxAgeHours $markerFileMaxAgeHours
+    
+    if ($markerResult.IsValid -and $markerResult.InstallationFound) {
+        Write-AppDeploymentLog -Message "Valid marker file found indicating successful installation." -Level Information -Mode $LoggingMode
+        # Continue with other checks to verify installation is still intact
+    }
+    #endregion Marker File Analysis
+    
+    # Check if user is in active session first (least disruptive)
+    if (Test-CiscoProcesses) {
+        $RunTime = (Get-Date) - $ScriptStartTime
+        Write-AppDeploymentLog -Message "Detection completed - active processes found. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+        Write-Output "$ApplicationName is installed (active processes detected) [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+        exit 0
+    }
+    
+    # Check runtime before registry scan
+    if (((Get-Date) - $ScriptStartTime).TotalSeconds -gt $MaxRuntime) {
+        Write-AppDeploymentLog -Message "Detection timeout reached." -Level Warning -Mode $LoggingMode
+        Write-Output "Detection timeout reached. Assuming not installed. [Runtime: $MaxRuntime s]"
+        exit 1
+    }
+    
+    # Primary detection method: Registry
+    if (Test-CiscoRegistry) {
+        $RunTime = (Get-Date) - $ScriptStartTime
+        Write-AppDeploymentLog -Message "Detection completed - found in registry. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+        Write-Output "$ApplicationName is installed (registry detection) [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+        exit 0
+    }
+    
+    # Check runtime before file system scan
+    if (((Get-Date) - $ScriptStartTime).TotalSeconds -gt $MaxRuntime) {
+        Write-AppDeploymentLog -Message "Detection timeout reached." -Level Warning -Mode $LoggingMode
+        Write-Output "Detection timeout reached. Assuming not installed. [Runtime: $MaxRuntime s]"
+        exit 1
+    }
+    
+    # Secondary detection method: File system
+    if (Test-CiscoFiles) {
+        $RunTime = (Get-Date) - $ScriptStartTime
+        Write-AppDeploymentLog -Message "Detection completed - found via file system. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+        Write-Output "$ApplicationName is installed (file detection) [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+        exit 0
+    }
+    
+    # Check runtime before service scan
+    if (((Get-Date) - $ScriptStartTime).TotalSeconds -gt $MaxRuntime) {
+        Write-AppDeploymentLog -Message "Detection timeout reached." -Level Warning -Mode $LoggingMode
+        Write-Output "Detection timeout reached. Assuming not installed. [Runtime: $MaxRuntime s]"
+        exit 1
+    }
+    
+    # Tertiary detection method: Services
+    if (Test-CiscoServices) {
+        $RunTime = (Get-Date) - $ScriptStartTime
+        Write-AppDeploymentLog -Message "Detection completed - found via services. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+        Write-Output "$ApplicationName is installed (service detection) [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+        exit 0
+    }
+    
+    # If we reach here, Cisco Secure Client is not detected
+    $RunTime = (Get-Date) - $ScriptStartTime
+    
+    # Log why detection failed
+    if (-not $markerResult.IsValid) {
+        Write-AppDeploymentLog -Message "No valid installation marker found. Reason: $($markerResult.Reason)" -Level Information -Mode $LoggingMode
+    }
+    
+    Write-AppDeploymentLog -Message "Detection completed - application not found. [Total Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]" -Level Information -Mode $LoggingMode
+    Write-AppDeploymentLog -Message "=== Cisco Secure Client Detection Script Completed ===" -Level Information -Mode $LoggingMode
+    Write-Output "$ApplicationName is not installed [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+    exit 1
+}
+catch {
+    # On any error, assume not installed to trigger installation
+    $RunTime = (Get-Date) - $ScriptStartTime
+    
+    if ($null -ne (Get-Command Handle-Error -ErrorAction SilentlyContinue)) {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Detection script encountered an error" -LoggingMode $LoggingMode
+    }
+    
+    Write-AppDeploymentLog -Message "=== Cisco Secure Client Detection Script Failed ===" -Level Error -Mode $LoggingMode
+    Write-Output "Detection script error: $_ [Runtime: $($RunTime.TotalSeconds.ToString('F2'))s]"
+    exit 1
+}
+#endregion
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/.DS_Store b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/.DS_Store
new file mode 100644
index 0000000..19a264e
Binary files /dev/null and b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/.DS_Store differ
diff --git a/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Profiles/umbrella/OrgInfo.json b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Profiles/umbrella/OrgInfo.json
new file mode 100644
index 0000000..0e5422f
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Profiles/umbrella/OrgInfo.json	
@@ -0,0 +1,5 @@
+{
+    "organizationId" : "8329794",
+    "fingerprint" : "d454b12c440243e57e518f4b8476bb23",
+    "userId" : "12030419"
+}
diff --git a/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/GUI.ico b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/GUI.ico
new file mode 100644
index 0000000..a2873b9
Binary files /dev/null and b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/GUI.ico differ
diff --git a/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/cues_bg.jpg b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/cues_bg.jpg
new file mode 100644
index 0000000..f42fb03
Binary files /dev/null and b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/cues_bg.jpg differ
diff --git a/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula.html b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula.html
new file mode 100644
index 0000000..afb5b3a
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula.html	
@@ -0,0 +1,151 @@
+<html>
+
+<head>
+<meta http-equiv=Content-Type content="text/html; charset=utf-8">
+<meta name=Generator content="Microsoft Word 15 (filtered)">
+<style>
+<!--
+ /* Font Definitions */
+ @font-face
+	{font-family:Wingdings;
+	panose-1:5 0 0 0 0 0 0 0 0 0;}
+@font-face
+	{font-family:SimSun;
+	panose-1:2 1 6 0 3 1 1 1 1 1;}
+@font-face
+	{font-family:"Cambria Math";
+	panose-1:2 4 5 3 5 4 6 3 2 4;}
+@font-face
+	{font-family:Tahoma;
+	panose-1:2 11 6 4 3 5 4 4 2 4;}
+@font-face
+	{font-family:"\@SimSun";
+	panose-1:2 1 6 0 3 1 1 1 1 1;}
+ /* Style Definitions */
+ p.MsoNormal, li.MsoNormal, div.MsoNormal
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:10.0pt;
+	margin-left:0in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+a:link, span.MsoHyperlink
+	{color:#003399;
+	text-decoration:underline;}
+p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:10.0pt;
+	margin-left:.5in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:0in;
+	margin-left:.5in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:0in;
+	margin-left:.5in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
+	{margin-top:0in;
+	margin-right:0in;
+	margin-bottom:10.0pt;
+	margin-left:.5in;
+	line-height:115%;
+	font-size:11.0pt;
+	font-family:"Calibri",sans-serif;}
+.MsoChpDefault
+	{font-family:"Calibri",sans-serif;}
+.MsoPapDefault
+	{margin-bottom:10.0pt;
+	line-height:115%;}
+@page WordSection1
+	{size:8.5in 11.0in;
+	margin:1.0in 1.0in 1.0in 1.0in;}
+div.WordSection1
+	{page:WordSection1;}
+ /* List Definitions */
+ ol
+	{margin-bottom:0in;}
+ul
+	{margin-bottom:0in;}
+-->
+</style>
+
+</head>
+
+<body lang=EN-US link="#003399" vlink=purple style='word-wrap:break-word'>
+
+<div class=WordSection1>
+
+<p class=MsoNormal align=center style='text-align:center;line-height:normal'><a
+name=wp1015257></a><a name=wp1015255></a><a
+name="Supplemental_End_User_License_Agreement_"></a><b><span style='font-size:
+14.0pt;font-family:"Arial",sans-serif;color:black'>Supplemental End User
+License Agreement</span></b></p>
+
+<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
+line-height:normal'><a name=wp1015256></a><b><span style='font-family:"Arial",sans-serif;
+color:black'>IMPORTANT: READ CAREFULLY</span></b></p>
+
+<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
+line-height:normal'><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>By clicking accept or using the Cisco Technology, you agree that
+such use is governed by the Cisco End User License Agreement and the applicable
+Product Specific Terms (collectively, the &quot;EULA&quot;). You also
+acknowledge and agree that you have read the Cisco Privacy Statement. </span></p>
+
+<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
+line-height:normal'><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>If you do not have authority to bind your company and its
+affiliates, or if you do not agree with the terms of the EULA, do not click 'accept'
+and do not use the Cisco Technology. If you are a Cisco channel partner
+accepting on behalf of an end customer (&quot;customer&quot;), you must inform
+the customer that the EULA applies to customer's use of the Cisco Technology
+and provide the customer with access to all relevant terms.</span></p>
+
+<p class=MsoNormal style='margin-bottom:0in;text-align:justify;text-justify:
+inter-ideograph;line-height:normal'><span style='font-size:9.0pt;font-family:
+"Arial",sans-serif;color:black'>The latest version of documents can be found at
+the following locations.</span></p>
+
+<p class=MsoListParagraphCxSpFirst style='margin-left:40.5pt;text-indent:-22.5pt;
+line-height:normal'><span style='font-size:9.0pt;font-family:Symbol;color:black'>┬╖<span
+style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+</span></span><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>Cisco End User License Agreement: <a
+href="https://www.cisco.com/c/en/us/about/legal/cloud-and-software/end_user_license_agreement.html"
+target="_blank">https://www.cisco.com/c/en/us/about/legal/cloud-and-software/end_user_license_agreement.html</a></span></p>
+
+<p class=MsoListParagraphCxSpMiddle style='margin-left:40.5pt;text-indent:-22.5pt;
+line-height:normal'><span style='font-size:9.0pt;font-family:Symbol;color:black'>┬╖<span
+style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+</span></span><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>Applicable Product Specific Terms: <a
+href="https://www.cisco.com/c/en/us/about/legal/cloud-and-software/software-terms.html"
+target="_blank">https://www.cisco.com/c/en/us/about/legal/cloud-and-software/software-terms.html</a></span></p>
+
+<p class=MsoListParagraphCxSpLast style='margin-bottom:0in;margin-left:40.5pt;
+text-indent:-22.5pt;line-height:normal'><span style='font-size:9.0pt;
+font-family:Symbol;color:black'>┬╖<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+</span></span><span style='font-size:9.0pt;font-family:"Arial",sans-serif;
+color:black'>Cisco Privacy Statement: <a
+href="https://www.cisco.com/c/en/us/about/legal/privacy-full.html"
+target="_blank">https://www.cisco.com/c/en/us/about/legal/privacy-full.html</a></span></p>
+
+</div>
+
+</body>
+
+</html>
diff --git a/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula_dialog.html b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula_dialog.html
new file mode 100644
index 0000000..891433f
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/eula_dialog.html	
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
+<head>
+  <title>Cisco Secure Client EULA</title>
+  <meta http-equiv="MSThemeCompatible" content="Yes" />
+</head>
+<body style="background-image:url('cues_bg.jpg')">
+  <div style="text-align:center;margin:15px;">
+    <iframe src="eula.html" scrolling="auto" style="position:relative;width:550px;height:350px;"></iframe>
+    <br />
+    <input type="submit" id="accept" onclick="window.returnValue=1;self.close()" style="margin-top:10px;margin-right:10px" value="Accept" />
+    <input type="submit" id="decline" onclick="window.returnValue=0;self.close()" style="margin-top:10px" value="Decline" />
+  </div>
+</body>
+</html>
diff --git a/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/update.txt b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/update.txt
new file mode 100644
index 0000000..976ddcb
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Setup/update.txt	
@@ -0,0 +1 @@
+5,1,10,233
diff --git a/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Umbrella-Install.ps1 b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Umbrella-Install.ps1
new file mode 100644
index 0000000..75fe4ce
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/Umbrella-Install.ps1	
@@ -0,0 +1,3 @@
+Start-Process msiexec /package cisco-secure-client-win-5.1.10.233-core-vpn-predeploy-k9.msi PRE_DEPLOY_DISABLE_VPN=1 /norestart /passive /lvx* vpninstall.log
+Start-Process msiexec /package cisco-secure-client-win-5.1.10.233-umbrella-predeploy-k9.msi PRE_DEPLOY_DISABLE_VPN=1 /norestart /passive /lvx* umbrellainstall.log
+Start-Process msiexec /package cisco-secure-client-win-5.1.10.233-dart-predeploy-k9.msi /norestart /passive /lvx* dartinstall.log
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/setup.hta b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/setup.hta
new file mode 100644
index 0000000..c7c3de7
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/cisco-secure-client-win-5.1.10.233-predeploy-k9/setup.hta	
@@ -0,0 +1,538 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<!--
+*************************************************************************
+**           Copyright (c) 2015, Cisco Systems, All Rights Reserved
+*************************************************************************
+-->
+<head>
+<title>Cisco Secure Client Install Selector</title>
+<meta http-equiv="MSThemeCompatible" content="Yes">
+<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+<HTA:APPLICATION 
+     ID="installSelect" 
+     APPLICATIONNAME="Cisco Secure Client - Installer"
+     SCROLL="yes"
+     SINGLEINSTANCE="yes"
+     SELECTION="no"
+     ICON="Setup\GUI.ico">
+<script type="text/vbscript">
+    'Window_OnLoad
+    Window.ResizeTo 650, 670
+    Window.moveto 0, 0
+
+    Dim WshShell, objFSO, strVer, strTemp, Return, strReturn
+    Dim bNeedsReboot, valNeedsReboot, valNumChecked
+    Dim strLockDown, dblQuote
+    
+    strLockDown = ""
+    dblQuote  = chr(34)
+    valNeedsReboot = 3010
+
+    Set WshShell = CreateObject("WScript.Shell")
+    Set objFSO = CreateObject("Scripting.FileSystemObject")
+
+    Dim strScriptDir
+    strScriptDir = objFSO.GetParentFolderName(replace(installSelect.commandLine, dblQuote, ""))
+
+    Sub Initialize
+        Dim strVerFile
+        strVerFile = strScriptDir & "\Setup\update.txt"
+        If objFSO.FileExists(strVerFile) Then
+            Set objTextFile = objFSO.OpenTextFile(strVerFile, 1)
+            strVer = objTextFile.ReadAll
+            objTextFile.Close
+            strVer = Replace (strVer, ",", ".")
+            strVer = Replace (strVer, vbNewLine, "")
+        End If
+
+        If Not IsEmpty(strVer) Then
+            Version.InnerText = strVer
+        Else
+            Body.InnerHTML = "<p style='text-align:center'>Unable to determine Cisco Secure Client package version (missing update.txt).</p>"
+        End If
+
+        strTemp = objFSO.GetSpecialFolder(TemporaryFolder)
+        strTemp = strTemp & "\Temp\"
+    End Sub
+
+    ' Main Subroutine
+    Sub TestCheckboxes
+        valNumChecked = 0
+        strSelected = vbCrLf
+        If CheckboxVPN.Checked Then
+            strSelected = strSelected & "AnyConnect VPN" & vbCrLf
+            blnInstallVPN = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxSBL.Checked Then
+            strSelected = strSelected & "Start Before Login" & vbCrLf
+            blnInstallSBL = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxDART.Checked Then
+            strSelected = strSelected & "Diagnostic And Reporting Tool" & vbCrLf
+            blnInstallDART = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxPosture.Checked Then
+            strSelected = strSelected & "Secure Firewall Posture" & vbCrLf
+            blnInstallPosture = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxISEPosture.Checked Then
+            If blnInstallVPN Then
+                strSelected = strSelected & "ISE Posture" & vbCrLf
+                blnInstallISEPosture = true
+                valNumChecked = valNumChecked + 1
+            Else
+                strSelected = strSelected & "Stand-Alone ISE Posture" & vbCrLf
+                blnInstallISEPostureAlone = true
+                valNumChecked = valNumChecked + 1
+            End If
+        End If
+        If CheckboxNVM.Checked Then
+            strSelected = strSelected & "Network Visibility Module" & vbCrLf
+            blnInstallNVM = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxNAM.Checked Then
+            If blnInstallVPN Then
+                strSelected = strSelected & "Network Access Manager" & vbCrLf
+                blnInstallNAM = true
+                valNumChecked = valNumChecked + 1
+            Else
+                strSelected = strSelected & "Stand-Alone Network Access Manager" & vbCrLf
+                blnInstallNAMAlone = true
+                valNumChecked = valNumChecked + 1
+            End If
+        End If
+        If CheckboxUmbrella.Checked Then
+            If blnInstallVPN Then
+                strSelected = strSelected & "Umbrella" & vbCrLf
+                blnInstallUmbrella = true
+                valNumChecked = valNumChecked + 1
+            Else
+                strSelected = strSelected & "Stand-Alone Umbrella" & vbCrLf
+                blnInstallUmbrellaAlone = true
+                valNumChecked = valNumChecked + 1
+            End If
+        End If
+        If CheckboxThousandEyes.Checked Then
+            strSelected = strSelected & "ThousandEyes" & vbCrLf
+            blnInstallThousandEyes = true
+            valNumChecked = valNumChecked + 1
+        End If
+        If CheckboxZTA.Checked Then
+            If blnInstallVPN Then
+                strSelected = strSelected & "Zero Trust Access" & vbCrLf
+                blnInstallZTA = true
+                valNumChecked = valNumChecked + 1
+            Else
+                strSelected = strSelected & "Stand-Alone Zero Trust Access" & vbCrLf
+                blnInstallZTAAlone = true
+                valNumChecked = valNumChecked + 1
+            End If
+        End If
+        If valNumChecked > 0 Then
+            blnAnswer = window.confirm( "You selected the following Cisco Secure Client " & strVer & " modules to install: " & vbCrLf & strSelected & vbCrLf & "Do you wish to install these now?")
+            If Not blnAnswer Then
+                Exit Sub
+            End If
+           
+            blnAcceptedEULA = window.showModalDialog(strScriptDir & "/Setup/eula_dialog.html","","dialogwidth=650px;dialogheight=450px;status:no")
+            If blnAcceptedEULA Then
+                If blnInstallVPN Then
+                    InstallVPN
+                End If
+                If blnInstallDART Then
+                    InstallDART
+                End If
+                If blnInstallNAM Then
+                    InstallNAM
+                End If
+                If blnInstallPosture Then
+                    InstallPosture
+                End If
+                If blnInstallISEPosture Then
+                    InstallISEPosture
+                End If
+                If blnInstallNVM Then
+                    InstallNVM
+                End If
+                If blnInstallUmbrella Then
+                    InstallUmbrella
+                End If
+                If blnInstallThousandEyes Then
+                    InstallThousandEyes
+                End If
+                If blnInstallSBL Then
+                    InstallSBL
+                End If
+                If blnInstallZTA Then
+                    InstallZTA
+                End If
+                If blnInstallNAMAlone Then
+                    InstallAnyConnectDisableVPN
+                    InstallNAM
+                End If
+                If blnInstallUmbrellaAlone Then
+                    InstallAnyConnectDisableVPN
+                    InstallUmbrella
+                End If
+                If blnInstallISEPostureAlone Then
+                    InstallAnyConnectDisableVPN
+                    InstallISEPosture
+                End If
+                If blnInstallZTAAlone Then
+                    InstallAnyConnectDisableVPN
+                    InstallZTA
+                End If
+
+                If bNeedsReboot Then
+                    Msgbox "You must reboot your system for the installed changes to take effect.", vbOKOnly, "Cisco Secure Client Install Selector"
+                Else
+                    Msgbox "Installation complete.", vbOKOnly, "Cisco Secure Client Install Selector"
+                End If
+
+                ExitHTA
+            End If
+        End If
+    End Sub
+
+    ' Checkbox Dependencies Subroutines
+    Sub CheckAll
+        CheckboxVPN.Checked = CheckboxALL.Checked
+        CheckboxSBL.Checked = CheckboxALL.Checked
+        CheckboxNAM.Checked = CheckboxALL.Checked
+        CheckboxPosture.Checked = CheckboxALL.Checked
+        CheckboxISEPosture.Checked = CheckboxALL.Checked
+        CheckboxNVM.Checked = CheckboxALL.Checked
+        CheckboxUmbrella.Checked = CheckboxALL.Checked
+        CheckboxThousandEyes.Checked = CheckboxALL.Checked
+        CheckboxZTA.Checked = CheckboxALL.Checked
+    End Sub
+
+    Sub CheckDependsVPN
+        CheckSBLChecked
+        If CheckboxVPN.Checked=False Then
+            CheckboxPosture.Checked = False
+            CheckboxISEPosture.Checked = False
+            CheckboxNVM.Checked = False
+            CheckboxAll.Checked = False
+        End If
+    End Sub
+    
+    Sub CheckSBLDependsOnSBLClick
+        If CheckboxSBL.Checked Then
+            CheckboxVPN.Checked = True
+        End If
+    End Sub
+
+    Sub CheckSBLChecked
+        If CheckboxVPN.Checked=False And CheckboxNAM.Checked=False Then
+            CheckboxSBL.checked=False
+        End If
+    End Sub
+    
+    Sub CheckDependsNAM
+        CheckSBLChecked
+        If CheckboxNAM.Checked=False Then
+            CheckboxAll.Checked = False
+        End If
+    End Sub
+
+    Sub CheckPostureDepends
+        If CheckboxPosture.Checked Then
+            CheckboxVPN.Checked = True
+        End If
+        If CheckboxPosture.Checked=False Then
+            CheckboxALL.Checked = False
+        End If
+    End Sub
+ 
+    Sub CheckNVMDepends
+        If CheckboxNVM.Checked Then
+            CheckboxVPN.Checked = True
+        End If
+        If CheckboxNVM.Checked=False Then
+            CheckboxALL.Checked = False
+        End If
+    End Sub
+ 
+    Sub CheckALLFalse
+        If CheckboxNAM.Checked=False or CheckboxISEPosture.Checked=False or CheckboxNVM.Checked=False or CheckboxUmbrella.Checked=False or CheckboxThousandEyes.Checked=False or CheckboxZTA.Checked=False Then
+            CheckboxALL.Checked = False
+        End If
+    End Sub
+    
+    Sub SetLockDownFlag
+        If CheckboxLOCKDOWN.Checked Then
+            strLockDown = "LOCKDOWN=1"
+        Else
+            strLockDown = ""
+        End If
+    End Sub
+   
+    ' Install Subroutines
+    Function GetDateTimeString()
+        Dim dd, MM, yy, hh, nn, ss
+        Dim dateValue, timeValue, dtsNow
+
+        'Store DateTimeStamp once.
+        dtsNow = Now()
+
+        'Individual date components
+        MM = Right("00" & Month(dtsNow), 2)
+        dd = Right("00" & Day(dtsNow), 2)
+        yy = Year(dtsNow)
+        hh = Right("00" & Hour(dtsNow), 2)
+        nn = Right("00" & Minute(dtsNow), 2)
+        ss = Right("00" & Second(dtsNow), 2)
+
+        'Build the date string in the format mm-dd-yyyy
+        dateValue = MM & dd & yy
+
+        'Build the time string in the format hh:mm:ss
+        timeValue = hh & nn & ss
+
+        'Concatenate both together to build the timestamp MMddyyyy_hhmmss
+        GetDateTimeString = dateValue & "_" & timeValue
+    End Function
+
+REM  Returns name of first file found in directory that matches the first and second 
+REM  segments of the strFilenameMatch as delimited by the strDelimiter
+    Function GetFileNameSingleWildcard(strDirectory, strFilenameMatch, strDelimiter)
+    Dim objFS, objDir, objFiles, objFile, strMatchArray
+
+    Set objFS = CreateObject("Scripting.FileSystemObject")
+
+    ' This function expects a single delimiter
+    strMatchArray=Split(strFilenameMatch,strDelimiter)
+    if UBound(strMatchArray) <> 1 then
+        ' return empty string for invalid number of wildcards
+        Exit Function
+    End if
+
+    Set objDir = objFS.GetFolder(strDirectory)
+    Set objFiles = objDir.Files
+
+    For Each objFile in ObjFiles
+        ' check first segment and then second segment for match
+        if (instr(1,objFile.Name, strMatchArray(0)) > 0) And (instr(Len(strMatchArray(0)),objFile.Name, strMatchArray(1)) > 0) then
+            GetFileNameSingleWildcard = objFile.Name
+            Exit For
+        End if
+    Next
+
+    End Function
+
+    Sub InstallVPN
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-core-vpn-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive PRE_DEPLOY_DISABLE_VPN=0 " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallSBL
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-sbl-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallDART
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-dart-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallNAM
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-nam-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallUmbrella
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-umbrella-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallAnyConnectDisableVPN
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-core-vpn-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive PRE_DEPLOY_DISABLE_VPN=1 " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+        
+    Sub InstallPosture
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-posture-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallISEPosture
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-iseposture-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallNVM
+        strInstallFile = "cisco-secure-client-win-" & strVer & "-nvm-predeploy-k9"
+        strLogFile = strInstallFile & "-install-" & GetDateTimeString & ".log"
+        strInstallFile = strInstallFile & ".msi"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallThousandEyes
+        strInstallFile = GetFileNameSingleWildcard(strScriptDir, "cisco-secure-client-win-*-thousandeyes-predeploy-k9.msi", "*")
+        strLogFile = objFSO.GetBaseName(strInstallFile) & "-install-" & GetDateTimeString & ".log"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub InstallZTA
+        strInstallFile = GetFileNameSingleWildcard(strScriptDir, "cisco-secure-client-win-*-zta-predeploy-k9.msi", "*")
+        strLogFile = objFSO.GetBaseName(strInstallFile) & "-install-" & GetDateTimeString & ".log"
+        strMsiexecCmdLine = "msiexec /package " & dblQuote & strScriptDir & "\" & strInstallFile & dblQuote & " /norestart /passive " & strLockDown & " /lvx* " & strTemp & strLogFile
+        Return = WshShell.Run(strMsiexecCmdLine,1,True)
+        If Return=valNeedsReboot Then
+            bNeedsReboot=True
+        End If
+    End Sub
+
+    Sub ExitHTA
+        self.close()
+    End Sub
+</script>
+</head>
+<style>
+p  {
+    margin: 8px;
+}
+</style>
+<body id="body" style="background-image=url('Setup/cues_bg.jpg');font-family:'Times New Roman',serif;font-size:24;color=white" onload="Initialize">
+Select the Cisco Secure Client <span id="version">0.0.0</span> modules you wish to install:
+<p>
+<span class="tooltip" title="Installs the module that enables VPN capabilities.">
+<input type="checkbox" id="vpn" name="CheckboxVPN" checked onclick="CheckDependsVPN">
+<label for="vpn">Core & AnyConnect VPN</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that allows a VPN session and/or network logon to be established prior to a user logging onto the system.">
+<input type="checkbox" id="sbl" name="CheckboxSBL" checked onclick="CheckSBLDependsOnSBLClick">
+<label for="sbl">Start Before Login</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that provides Layer 2 device management and authentication for access to both wired and wireless networks.">
+<input type="checkbox" id="nam" name="CheckboxNAM" checked onClick="CheckDependsNAM">
+<label for="nam">Network Access Manager</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that provides the Cisco Secure Client with the ability to identify the operating system, antivirus, antispyware, and firewall software installed on the host prior to creating a remote access connection to the secure gateway.">
+<input type="checkbox" id="posture" name="CheckboxPosture" checked onclick="CheckPostureDepends">
+<label for="posture">Secure Firewall Posture</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the Network Visibility module which collects application telemetry data.">
+<input type="checkbox" id="NVM" name="CheckboxNVM" checked onclick="CheckNVMDepends">
+<label for="NVM">Network Visibility Module</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that enables Umbrella.">
+<input type="checkbox" id="umbrella" name="CheckboxUmbrella" checked onclick="CheckAllFalse">
+<label for="umbrella">Umbrella</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that provides the Cisco Secure Client with the functionality needed to authenticate to wired or wireless networks controlled by the Identity Services Engine, including examination and any needed remediation of the connecting host environment.">
+<input type="checkbox" id="iseposture" name="CheckboxISEPosture" checked onclick="CheckAllFalse">
+<label for="iseposture">ISE Posture</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that enables ThousandEyes.">
+<input type="checkbox" id="thousandeyes" name="CheckboxThousandEyes" checked onclick="CheckAllFalse">
+<label for="thousandeyes">ThousandEyes</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the module that enables ZTA.">
+<input type="checkbox" id="zta" name="CheckboxZTA" checked onclick="CheckAllFalse">
+<label for="zta">Zero Trust Access</label>
+</span>
+</p>
+<p>
+<span class="tooltip" title="Installs the entire suite of Cisco Secure Client software components.">
+<input type="checkbox" id="all" name="CheckboxALL" checked onClick="CheckAll">
+<label for="all">Select All</label>
+</span>
+</p>
+<p style="margin-top:28px">
+<span class="tooltip" title="Installs the diagnostics module that collects Cisco Secure Client troubleshooting information.">
+<input type="checkbox" id="dart" name="CheckboxDART" checked>
+<label for="dart">Diagnostic And Reporting Tool</label>
+</span>
+</p>
+<br>
+<p style="text-align:right">
+<span class="tooltip" title="Locks down the permissions of the Windows Services for each module that is installed. This will prevent any user from stopping the service, including local administrators.">
+<input type="checkbox" id="lockdown" name="CheckboxLOCKDOWN" onclick="SetLockDownFlag">
+<label for="lockdown">Lock Down Component Services</label>
+</span>
+</p>
+<p>
+<input type="submit" value="Install Selected" id="run_button" style="font-size:20;" onClick="TestCheckboxes">
+</p>
+</body>
+</html>
diff --git a/Win32Apps-Source/Cisco Secure Client/debug-uninstall.ps1 b/Win32Apps-Source/Cisco Secure Client/debug-uninstall.ps1
new file mode 100644
index 0000000..82a45f8
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/debug-uninstall.ps1	
@@ -0,0 +1,22 @@
+# Debug the Get-CiscoInstalledProducts function
+. "C:\code\Cisco Secure Client\uninstall.ps1" -DebugPreference 'Continue'
+
+# Get the products
+$products = Get-CiscoInstalledProducts
+
+Write-Host "`nTotal products found: $($products.Count)"
+Write-Host "Products array type: $($products.GetType().Name)"
+
+for ($i = 0; $i -lt $products.Count; $i++) {
+    $p = $products[$i]
+    Write-Host "`n[$i] Type: $($p.GetType().Name)"
+    if ($p -is [hashtable]) {
+        Write-Host "    Name: $($p['Name'])"
+        Write-Host "    Code: $($p['Code'])"
+        Write-Host "    Order: $($p['Order'])"
+    } elseif ($p -is [string]) {
+        Write-Host "    String value: '$p'"
+    } else {
+        Write-Host "    Unknown type value: $p"
+    }
+}
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/install.ps1 b/Win32Apps-Source/Cisco Secure Client/install.ps1
new file mode 100644
index 0000000..8f68a12
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/install.ps1	
@@ -0,0 +1,363 @@
+<#
+.SYNOPSIS
+    Installs Cisco Secure Client with Umbrella component for DNS filtering.
+
+.DESCRIPTION
+    This script installs Cisco Secure Client components in the following order:
+    1. Core VPN component (with VPN disabled for organizations using alternate VPN)
+    2. Umbrella component (for DNS-layer security)
+    3. DART component (diagnostics and reporting tool)
+    
+    Designed for Intune Win32 app deployment.
+
+.NOTES
+    Version:        1.0
+    Creation Date:  2025-01-12
+    Purpose:        Intune Win32 App Installation Script
+    Compatibility:  PowerShell 5.1
+#>
+
+#region Script Configuration
+$ScriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
+$LogPath = "$env:ProgramData\Microsoft\IntuneManagementExtension\Logs"
+$LogFile = Join-Path $LogPath "CiscoSecureClient_Install_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
+$MaxRetries = 3
+$RetryDelay = 5
+#endregion
+
+#region Logging Functions
+function Write-Log {
+    param(
+        [Parameter(Mandatory=$true)]
+        [string]$Message,
+        
+        [Parameter(Mandatory=$false)]
+        [ValidateSet('Info','Warning','Error')]
+        [string]$Level = 'Info'
+    )
+    
+    $TimeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $LogMessage = "$TimeStamp [$Level] $Message"
+    
+    # Write to log file
+    Add-Content -Path $LogFile -Value $LogMessage -Force
+    
+    # Also write to console for Intune
+    switch ($Level) {
+        'Warning' { Write-Warning $Message }
+        'Error' { Write-Error $Message }
+        default { Write-Output $Message }
+    }
+}
+#endregion
+
+#region Installation Functions
+function Install-MSIPackage {
+    param(
+        [Parameter(Mandatory=$true)]
+        [string]$MSIPath,
+        
+        [Parameter(Mandatory=$true)]
+        [string]$LogName,
+        
+        [Parameter(Mandatory=$false)]
+        [string]$Arguments = "/qn /norestart"
+    )
+    
+    $MSILogFile = Join-Path $LogPath "${LogName}_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
+    $MSIName = Split-Path -Leaf $MSIPath
+    
+    Write-Log "Installing $MSIName..."
+    
+    # Build the full argument string
+    $ArgumentList = "/i `"$MSIPath`" $Arguments /l*v `"$MSILogFile`""
+    
+    $Process = Start-Process -FilePath "msiexec.exe" -ArgumentList $ArgumentList -Wait -PassThru
+    
+    if ($Process.ExitCode -eq 0) {
+        Write-Log "$MSIName installed successfully."
+        return $true
+    }
+    elseif ($Process.ExitCode -eq 3010) {
+        Write-Log "$MSIName installed successfully but requires a reboot." -Level Warning
+        return $true
+    }
+    else {
+        Write-Log "$MSIName installation failed with exit code: $($Process.ExitCode)" -Level Error
+        return $false
+    }
+}
+
+function Test-Prerequisites {
+    Write-Log "Checking prerequisites..."
+    
+    # Check for minimum Windows version (Windows 10 1809 or later recommended)
+    $OSVersion = [System.Environment]::OSVersion.Version
+    if ($OSVersion.Major -lt 10) {
+        Write-Log "Windows 10 or later is required. Current version: $($OSVersion.ToString())" -Level Error
+        return $false
+    }
+    
+    # Check for administrator privileges
+    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
+        Write-Log "Script must be run with administrator privileges." -Level Error
+        return $false
+    }
+    
+    # Check if another installation is in progress
+    $MsiExecProcesses = Get-Process -Name "msiexec" -ErrorAction SilentlyContinue | Where-Object { $_.Id -ne $PID }
+    if ($MsiExecProcesses) {
+        Write-Log "Another installation is in progress. Waiting..." -Level Warning
+        Start-Sleep -Seconds 30
+    }
+    
+    Write-Log "Prerequisites check passed."
+    return $true
+}
+#endregion
+
+#region Main Installation Logic
+try {
+    # Create log directory if it doesn't exist
+    if (-not (Test-Path $LogPath)) {
+        New-Item -ItemType Directory -Path $LogPath -Force | Out-Null
+    }
+    
+    Write-Log "=== Cisco Secure Client Installation Started ==="
+    Write-Log "Script Path: $ScriptPath"
+    
+    # Initialize installation results for marker file
+    $installationStartTime = Get-Date
+    $installationResults = @{
+        InstallationTimestamp = $installationStartTime.ToString('yyyy-MM-dd HH:mm:ss')
+        InstallationStatus = "InProgress"
+        ComputerName = $env:COMPUTERNAME
+        UserContext = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
+        ScriptVersion = "1.0"
+        InstalledVersion = $null
+        ComponentsInstalled = @{}
+        ComponentsFailed = @{}
+        ErrorInfo = @()
+        TotalExecutionSeconds = 0
+    }
+    
+    # Check prerequisites
+    if (-not (Test-Prerequisites)) {
+        Write-Log "Prerequisites check failed. Exiting." -Level Error
+        exit 1
+    }
+    
+    # Define MSI packages to install (per Cisco documentation)
+    $MSIPackages = @(
+        @{
+            Name = "Core VPN"
+            File = "cisco-secure-client-win-5.1.10.233-core-vpn-predeploy-k9.msi"
+            Arguments = "PRE_DEPLOY_DISABLE_VPN=1 /qn /norestart"
+            LogName = "vpninstall"
+        },
+        @{
+            Name = "Umbrella"
+            File = "cisco-secure-client-win-5.1.10.233-umbrella-predeploy-k9.msi"
+            Arguments = "PRE_DEPLOY_DISABLE_VPN=1 /qn /norestart"
+            LogName = "umbrellainstall"
+        },
+        @{
+            Name = "DART"
+            File = "cisco-secure-client-win-5.1.10.233-dart-predeploy-k9.msi"
+            Arguments = "/qn /norestart"
+            LogName = "dartinstall"
+        }
+    )
+    
+    $FailedInstalls = @()
+    
+    # Install each package
+    foreach ($Package in $MSIPackages) {
+        # First try the subdirectory location
+        $MSIPath = Join-Path $ScriptPath "cisco-secure-client-win-5.1.10.233-predeploy-k9\$($Package.File)"
+        
+        # If not found in subdirectory, try the root directory
+        if (-not (Test-Path $MSIPath)) {
+            $MSIPath = Join-Path $ScriptPath $Package.File
+        }
+        
+        if (-not (Test-Path $MSIPath)) {
+            Write-Log "MSI file not found: $($Package.File)" -Level Error
+            $FailedInstalls += $Package.Name
+            continue
+        }
+        
+        Write-Log "Installing $($Package.Name) component..."
+        
+        $RetryCount = 0
+        $Success = $false
+        
+        while ($RetryCount -lt $MaxRetries -and -not $Success) {
+            if ($RetryCount -gt 0) {
+                Write-Log "Retry attempt $RetryCount for $($Package.Name)..." -Level Warning
+                Start-Sleep -Seconds $RetryDelay
+            }
+            
+            $Success = Install-MSIPackage -MSIPath $MSIPath -LogName $Package.LogName -Arguments $Package.Arguments
+            $RetryCount++
+        }
+        
+        if (-not $Success) {
+            $FailedInstalls += $Package.Name
+            $installationResults.ComponentsFailed[$Package.Name] = @{
+                Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
+                Reason = "Installation failed after $MaxRetries attempts"
+            }
+        } else {
+            $installationResults.ComponentsInstalled[$Package.Name] = @{
+                Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
+                Version = "5.1.10.233"
+            }
+        }
+    }
+    
+    # Update installation results
+    $installationResults.InstalledVersion = "5.1.10.233"
+    $executionTime = (Get-Date) - $installationStartTime
+    $installationResults.TotalExecutionSeconds = [math]::Round($executionTime.TotalSeconds, 2)
+    
+    # Check installation results
+    if ($FailedInstalls.Count -eq 0) {
+        $installationResults.InstallationStatus = "Success"
+        Write-Log "=== Cisco Secure Client Installation Completed Successfully ==="
+        
+        # Verify services per documentation (wait for services to initialize)
+        Write-Log "Waiting for services to initialize..."
+        Start-Sleep -Seconds 15
+        
+        # Expected services per installation documentation
+        $ExpectedServices = @(
+            @{Name = "csc_umbrellaagent"; DisplayName = "Cisco Secure Client - Umbrella"},
+            @{Name = "vpnagent"; DisplayName = "Cisco Secure Client Agent"},
+            @{Name = "acwebsecagent"; DisplayName = "Cisco Secure Client Web Security Agent"}
+        )
+        
+        $ServiceStatus = @()
+        $AllServicesRunning = $true
+        
+        foreach ($ServiceInfo in $ExpectedServices) {
+            $Service = Get-Service -Name $ServiceInfo.Name -ErrorAction SilentlyContinue
+            
+            if ($Service) {
+                $ServiceStatus += "$($ServiceInfo.DisplayName): $($Service.Status)"
+                Write-Log "Service $($ServiceInfo.Name) status: $($Service.Status)"
+                
+                # Try to start service if not running
+                if ($Service.Status -ne 'Running') {
+                    Write-Log "Attempting to start $($ServiceInfo.Name)..." -Level Warning
+                    try {
+                        Start-Service -Name $ServiceInfo.Name -ErrorAction Stop
+                        Start-Sleep -Seconds 5
+                        $Service = Get-Service -Name $ServiceInfo.Name
+                        Write-Log "Service $($ServiceInfo.Name) is now: $($Service.Status)"
+                    }
+                    catch {
+                        Write-Log "Failed to start $($ServiceInfo.Name): $_" -Level Warning
+                        $AllServicesRunning = $false
+                    }
+                }
+            }
+            else {
+                if ($ServiceInfo.Name -eq "vpnagent" -or $ServiceInfo.Name -eq "acwebsecagent") {
+                    Write-Log "Service $($ServiceInfo.Name) not found (expected - VPN is disabled via PRE_DEPLOY_DISABLE_VPN=1)" -Level Info
+                    $ServiceStatus += "$($ServiceInfo.DisplayName): Not Found (VPN Disabled)"
+                } else {
+                    Write-Log "Service $($ServiceInfo.Name) not found" -Level Warning
+                    $ServiceStatus += "$($ServiceInfo.DisplayName): Not Found"
+                }
+            }
+        }
+        
+        Write-Log "Service Status Summary: $($ServiceStatus -join ', ')"
+        
+        # Installation is successful even if some services aren't running immediately
+        # They may start after a reboot
+        if (-not $AllServicesRunning) {
+            Write-Log "Some services are not running. A reboot may be required." -Level Warning
+        }
+        
+        Write-Log "Installation completed. To verify Umbrella policies, visit: http://examplemalwaredomain.com"
+        
+        # Save installation marker file
+        try {
+            $markerDir = "C:\ProgramData\CiscoSecureClient"
+            $markerFile = Join-Path $markerDir "installation-results.json"
+            
+            if (-not (Test-Path $markerDir)) {
+                New-Item -Path $markerDir -ItemType Directory -Force | Out-Null
+            }
+            
+            $installationResults | ConvertTo-Json -Depth 10 | Set-Content -Path $markerFile -Encoding UTF8
+            Write-Log "Installation marker file saved to: $markerFile"
+        }
+        catch {
+            Write-Log "Failed to save installation marker file: $_" -Level Warning
+        }
+        
+        exit 0
+    }
+    else {
+        $installationResults.InstallationStatus = "Failed"
+        Write-Log "=== Installation Failed ===" -Level Error
+        Write-Log "Failed components: $($FailedInstalls -join ', ')" -Level Error
+        
+        # Save installation marker file even on failure
+        try {
+            $markerDir = "C:\ProgramData\CiscoSecureClient"
+            $markerFile = Join-Path $markerDir "installation-results.json"
+            
+            if (-not (Test-Path $markerDir)) {
+                New-Item -Path $markerDir -ItemType Directory -Force | Out-Null
+            }
+            
+            $installationResults.ErrorInfo += @{
+                ErrorMessage = "Failed to install components: $($FailedInstalls -join ', ')"
+                ErrorTimestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
+            }
+            
+            $installationResults | ConvertTo-Json -Depth 10 | Set-Content -Path $markerFile -Encoding UTF8
+            Write-Log "Installation marker file saved with failure status to: $markerFile"
+        }
+        catch {
+            Write-Log "Failed to save installation marker file: $_" -Level Warning
+        }
+        
+        exit 1
+    }
+}
+catch {
+    Write-Log "Unexpected error during installation: $_" -Level Error
+    Write-Log "Stack Trace: $($_.ScriptStackTrace)" -Level Error
+    
+    # Save installation marker file even on unexpected error
+    try {
+        $installationResults.InstallationStatus = "Error"
+        $installationResults.ErrorInfo += @{
+            ErrorMessage = $_.Exception.Message
+            ErrorType = $_.Exception.GetType().FullName
+            ErrorTimestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
+            StackTrace = $_.ScriptStackTrace
+        }
+        
+        $markerDir = "C:\ProgramData\CiscoSecureClient"
+        $markerFile = Join-Path $markerDir "installation-results.json"
+        
+        if (-not (Test-Path $markerDir)) {
+            New-Item -Path $markerDir -ItemType Directory -Force | Out-Null
+        }
+        
+        $installationResults | ConvertTo-Json -Depth 10 | Set-Content -Path $markerFile -Encoding UTF8
+        Write-Log "Installation marker file saved with error status to: $markerFile"
+    }
+    catch {
+        Write-Log "CRITICAL: Failed to save installation marker file even in error handler: $_" -Level Error
+    }
+    
+    exit 1
+}
+#endregion
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/logging/logging.psm1 b/Win32Apps-Source/Cisco Secure Client/logging/logging.psm1
new file mode 100644
index 0000000..5efbcb4
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/logging/logging.psm1	
@@ -0,0 +1,825 @@
+#region Logging Function
+
+
+function Write-AppDeploymentLog {
+    [CmdletBinding()]
+    Param (
+        [Parameter(Mandatory = $true)]
+        [string]$Message,
+        [Parameter()]
+        [ValidateSet('Information', 'Warning', 'Error', 'Debug')]
+        [string]$Level = 'Information',
+        [Parameter()]
+        [ValidateSet('EnableDebug', 'SilentMode', 'Off')]
+        [string]$Mode = 'Off'
+    )
+
+    # Determine logging mode - check EnableDebug first, then parameter, then default to Off
+    $loggingMode = if ($EnableDebug) { 
+        'EnableDebug' 
+    } elseif ($Mode -ne 'Off') { 
+        $Mode 
+    } else { 
+        'Off' 
+    }
+
+    # Exit early if logging is completely disabled
+    if ($loggingMode -eq 'Off') {
+        return
+    }
+
+    # Enhanced caller information using improved logic from Write-EnhancedLog
+    $callStack = Get-PSCallStack
+    
+    # Simplified and corrected function name detection logic
+    $callerFunction = '<Unknown>'
+    if ($callStack.Count -ge 2) {
+        $caller = $callStack[1]
+        
+        # Use the same simple approach as Write-EnhancedLog that works correctly
+        if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+            # This is a function name
+            $callerFunction = $caller.Command
+        } else {
+            # This is either main script execution or a script file name - use MainScript
+            $callerFunction = 'MainScript'
+        }
+    }
+    
+    # Get parent script name
+    $parentScriptName = try {
+        Get-ParentScriptName
+    } catch {
+        "UnknownScript"
+    }
+    
+    # Get line number and script name for detailed logging
+    $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+    $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+        Split-Path -Leaf $callStack[1].ScriptName 
+    } else { 
+        $parentScriptName 
+    }
+
+    # Create enhanced caller information combining both approaches
+    $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+    $detailedCallerInfo = "[$scriptFileName`:$lineNumber $callerFunction]"
+
+    $timeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $fileLogMessage = "[$timeStamp] [$Level] $enhancedCallerInfo - $Message"
+    $consoleLogMessage = "[$Level] $enhancedCallerInfo - $Message" # No timestamp for console
+
+    #region Local File Logging
+    # Skip all file logging if DisableFileLogging is set
+    if ($script:DisableFileLogging) {
+        return
+    }
+    
+    # Use session-based paths if available, otherwise fall back to per-call generation
+    if ($script:SessionLogFilePath -and $script:SessionFullLogDirectory) {
+        $logFilePath = $script:SessionLogFilePath
+        $logDirectory = $script:SessionFullLogDirectory
+    } else {
+        # Fallback to old method if session variables aren't set
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        $logDirectory = "C:\ProgramData\CiscoSecureClient\Logs"
+        $fullLogDirectory = Join-Path -Path $logDirectory -ChildPath $dateFolder
+        $fullLogDirectory = Join-Path -Path $fullLogDirectory -ChildPath $parentScriptName
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.log"
+        $logFilePath = Join-Path -Path $fullLogDirectory -ChildPath $logFileName
+        $logDirectory = $fullLogDirectory
+    }
+    
+    if (-not (Test-Path -Path $logDirectory)) {
+        New-Item -ItemType Directory -Path $logDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+    }
+    
+    if (Test-Path -Path $logDirectory) {
+        Add-Content -Path $logFilePath -Value $fileLogMessage -ErrorAction SilentlyContinue
+        
+        # Log rotation for local files (keep max 7 files)
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $logFiles = Get-ChildItem -Path $logDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.log" | Sort-Object LastWriteTime -Descending
+            if ($logFiles.Count -gt 7) {
+                $filesToRemove = $logFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for log rotation
+        }
+    }
+    #endregion Local File Logging
+
+    #region Network Share CSV Logging
+    # Network logging: Only save CSV format logs under a parent job folder for better organization
+    try {
+        $hostname = $env:COMPUTERNAME
+        $jobName = "CiscoSecureClient"  # Parent job folder name
+        $networkBasePath = "\\AZR1PSCCM02\.logs\$jobName\$hostname"
+        
+        # Test network connectivity first
+        $networkAvailable = Test-Path "\\AZR1PSCCM02\.logs" -ErrorAction SilentlyContinue
+        
+        if ($networkAvailable) {
+            # Use session-based paths if available
+            if ($script:SessionDateFolder -and $script:SessionParentScript -and $script:SessionCSVFileName) {
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $script:SessionDateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionParentScript
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionCSVFileName
+            } else {
+                # Fallback method
+                $dateFolder = Get-Date -Format "yyyy-MM-dd"
+                $parentScriptName = Get-ParentScriptName
+                $userContext = Get-CurrentUser
+                $callingScript = Get-CallingScriptName
+                $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+                
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $dateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $parentScriptName
+                $networkCSVFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $networkCSVFileName
+            }
+            
+            if (-not (Test-Path -Path $fullNetworkCSVPath)) {
+                New-Item -ItemType Directory -Path $fullNetworkCSVPath -Force -ErrorAction SilentlyContinue | Out-Null
+            }
+            
+            if (Test-Path -Path $fullNetworkCSVPath) {
+                # Create CSV entry for network logging
+                $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+                $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+                $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+                
+                # Get caller information
+                $callStack = Get-PSCallStack
+                $callerFunction = '<Unknown>'
+                if ($callStack.Count -ge 2) {
+                    $caller = $callStack[1]
+                    if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+                        $callerFunction = $caller.Command
+                    } else {
+                        $callerFunction = 'MainScript'
+                    }
+                }
+                
+                $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+                $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+                    Split-Path -Leaf $callStack[1].ScriptName 
+                } else { 
+                    $parentScriptName 
+                }
+                
+                $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+                
+                $networkCSVEntry = [PSCustomObject]@{
+                    Timestamp       = $timeStamp
+                    Level           = $Level
+                    ParentScript    = $parentScriptName
+                    CallingScript   = $callingScript
+                    ScriptName      = $scriptFileName
+                    FunctionName    = $callerFunction
+                    LineNumber      = $lineNumber
+                    Message         = $Message
+                    Hostname        = $env:COMPUTERNAME
+                    UserType        = $userContext.UserType
+                    UserName        = $userContext.UserName
+                    FullUserContext = $userContext.FullUserContext
+                    CallerInfo      = $enhancedCallerInfo
+                    JobName         = $jobName
+                    LogType         = "NetworkCSV"
+                }
+                
+                # Check if network CSV exists, if not create with headers
+                if (-not (Test-Path -Path $networkCSVFile)) {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -ErrorAction SilentlyContinue
+                } else {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -Append -ErrorAction SilentlyContinue
+                }
+                
+                # Network CSV log rotation (keep max 5 files per machine per script)
+                try {
+                    $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+                    $networkCSVFiles = Get-ChildItem -Path $fullNetworkCSVPath -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+                    if ($networkCSVFiles.Count -gt 5) {
+                        $filesToRemove = $networkCSVFiles | Select-Object -Skip 5
+                        foreach ($file in $filesToRemove) {
+                            Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                        }
+                    }
+                }
+                catch {
+                    # Silent error handling for network CSV log rotation
+                }
+            }
+        }
+    }
+    catch {
+        # Silent error handling for network CSV logging - don't interfere with main script
+    }
+    #endregion Network Share CSV Logging
+
+    #region CSV Logging
+    try {
+        # Use session-based paths if available
+        if ($script:SessionCSVFilePath -and $script:SessionFullCSVDirectory) {
+            $csvLogPath = $script:SessionCSVFilePath
+            $csvDirectory = $script:SessionFullCSVDirectory
+        } else {
+            # Fallback method
+            $userContext = Get-CurrentUser
+            $callingScript = Get-CallingScriptName
+            $parentScriptName = Get-ParentScriptName
+            $dateFolder = Get-Date -Format "yyyy-MM-dd"
+            $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+            
+            $csvLogDirectory = "C:\ProgramData\CiscoSecureClient\Logs\CSV"
+            $fullCSVDirectory = Join-Path -Path $csvLogDirectory -ChildPath $dateFolder
+            $fullCSVDirectory = Join-Path -Path $fullCSVDirectory -ChildPath $parentScriptName
+            $csvFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+            $csvLogPath = Join-Path -Path $fullCSVDirectory -ChildPath $csvFileName
+            $csvDirectory = $fullCSVDirectory
+        }
+        
+        if (-not (Test-Path -Path $csvDirectory)) {
+            New-Item -ItemType Directory -Path $csvDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+        }
+        
+        # Use session context if available, otherwise get fresh context
+        $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+        $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+        $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+        
+        $csvEntry = [PSCustomObject]@{
+            Timestamp       = $timeStamp
+            Level           = $Level
+            ParentScript    = $parentScriptName
+            CallingScript   = $callingScript
+            ScriptName      = $scriptFileName
+            FunctionName    = $callerFunction
+            LineNumber      = $lineNumber
+            Message         = $Message
+            Hostname        = $env:COMPUTERNAME
+            UserType        = $userContext.UserType
+            UserName        = $userContext.UserName
+            FullUserContext = $userContext.FullUserContext
+            CallerInfo      = $enhancedCallerInfo
+        }
+        
+        # Check if CSV exists, if not create with headers
+        if (-not (Test-Path -Path $csvLogPath)) {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -ErrorAction SilentlyContinue
+        } else {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -Append -ErrorAction SilentlyContinue
+        }
+        
+        # CSV log rotation
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $csvFiles = Get-ChildItem -Path $csvDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+            if ($csvFiles.Count -gt 7) {
+                $filesToRemove = $csvFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for CSV log rotation
+        }
+    }
+    catch {
+        # Silent error handling for CSV logging
+    }
+    #endregion CSV Logging
+
+    #region Console Output (only in EnableDebug mode)
+    if ($loggingMode -eq 'EnableDebug') {
+        switch ($Level.ToUpper()) {
+            'ERROR' { Write-Host $consoleLogMessage -ForegroundColor Red }
+            'WARNING' { Write-Host $consoleLogMessage -ForegroundColor Yellow }
+            'INFORMATION' { Write-Host $consoleLogMessage -ForegroundColor White }
+            'DEBUG' { Write-Host $consoleLogMessage -ForegroundColor Gray }
+        }
+    }
+    #endregion Console Output
+}
+
+function Write-EnhancedLog {
+    [CmdletBinding()]
+    param (
+        [string]$Message,
+        [string]$Level = 'INFO',
+        [string]$LoggingMode = 'SilentMode'
+    )
+
+    # Get the PowerShell call stack to determine the actual calling function
+    $callStack = Get-PSCallStack
+    $callerFunction = if ($callStack.Count -ge 2) { $callStack[1].Command } else { '<Unknown>' }
+
+    # Get the parent script name
+    $parentScriptName = Get-ParentScriptName
+
+    # Map enhanced log levels to CiscoApp log levels
+    $mappedLevel = switch ($Level.ToUpper()) {
+        'CRITICAL' { 'Error' }
+        'ERROR'    { 'Error' }
+        'WARNING'  { 'Warning' }
+        'INFO'     { 'Information' }
+        'DEBUG'    { 'Debug' }
+        'NOTICE'   { 'Information' }
+        'IMPORTANT' { 'Information' }
+        'OUTPUT'   { 'Information' }
+        'SIGNIFICANT' { 'Information' }
+        'VERBOSE'  { 'Debug' }
+        'VERYVERBOSE' { 'Debug' }
+        'SOMEWHATVERBOSE' { 'Debug' }
+        'SYSTEM'   { 'Information' }
+        'INTERNALCOMMENT' { 'Debug' }
+        default    { 'Information' }
+    }
+
+    # Format message with caller information
+    $formattedMessage = "[$parentScriptName.$callerFunction] $Message"
+
+    # Use the existing Write-AppDeploymentLog function
+    Write-AppDeploymentLog -Message $formattedMessage -Level $mappedLevel -Mode $LoggingMode
+}
+
+#region Helper Functions
+
+
+#region Error Handling
+function Handle-Error {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [System.Management.Automation.ErrorRecord]$ErrorRecord,
+        [string]$CustomMessage = "",
+        [string]$LoggingMode = "SilentMode"
+    )
+
+    try {
+        if ($PSVersionTable.PSVersion.Major -ge 7) {
+            $fullErrorDetails = Get-Error -InputObject $ErrorRecord | Out-String
+        } else {
+            $fullErrorDetails = $ErrorRecord.Exception | Format-List * -Force | Out-String
+        }
+
+        $errorMessage = if ($CustomMessage) {
+            "$CustomMessage - Exception: $($ErrorRecord.Exception.Message)"
+        } else {
+            "Exception Message: $($ErrorRecord.Exception.Message)"
+        }
+
+        Write-AppDeploymentLog -Message $errorMessage -Level Error -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Full Exception Details: $fullErrorDetails" -Level Debug -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Script Line Number: $($ErrorRecord.InvocationInfo.ScriptLineNumber)" -Level Debug -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Position Message: $($ErrorRecord.InvocationInfo.PositionMessage)" -Level Debug -Mode $LoggingMode
+    } 
+    catch {
+        # Fallback error handling in case of an unexpected error in the try block
+        Write-AppDeploymentLog -Message "An error occurred while handling another error. Original Exception: $($ErrorRecord.Exception.Message)" -Level Error -Mode $LoggingMode
+        Write-AppDeploymentLog -Message "Handler Exception: $($_.Exception.Message)" -Level Error -Mode $LoggingMode
+    }
+}
+#endregion Error Handling
+
+function Get-ParentScriptName {
+    [CmdletBinding()]
+    param ()
+
+    try {
+        # Get the current call stack
+        $callStack = Get-PSCallStack
+
+        # If there is a call stack, return the top-most script name
+        if ($callStack.Count -gt 0) {
+            foreach ($frame in $callStack) {
+                if ($frame.ScriptName) {
+                    $parentScriptName = $frame.ScriptName
+                    # Write-EnhancedLog -Message "Found script in call stack: $parentScriptName" -Level "INFO"
+                }
+            }
+
+            if (-not [string]::IsNullOrEmpty($parentScriptName)) {
+                $parentScriptName = [System.IO.Path]::GetFileNameWithoutExtension($parentScriptName)
+                return $parentScriptName
+            }
+        }
+
+        # If no script name was found, return 'UnknownScript'
+        Write-EnhancedLog -Message "No script name found in the call stack." -Level "WARNING"
+        return "UnknownScript"
+    }
+    catch {
+        Write-EnhancedLog -Message "An error occurred while retrieving the parent script name: $_" -Level "ERROR"
+        return "UnknownScript"
+    }
+}
+
+function Get-CurrentUser {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the current user context
+        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
+        $computerName = $env:COMPUTERNAME
+        
+        # Check if running as SYSTEM
+        if ($currentUser -like "*SYSTEM*" -or $currentUser -eq "NT AUTHORITY\SYSTEM") {
+            return @{
+                UserType = "SYSTEM"
+                UserName = "LocalSystem"
+                ComputerName = $computerName
+                FullUserContext = "SYSTEM-LocalSystem"
+            }
+        }
+        
+        # Extract domain and username
+        if ($currentUser.Contains('\')) {
+            $domain = $currentUser.Split('\')[0]
+            $userName = $currentUser.Split('\')[1]
+        } else {
+            $domain = $env:USERDOMAIN
+            $userName = $currentUser
+        }
+        
+        # Determine user type based on group membership
+        $userType = "User"
+        try {
+            $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
+            if ($isAdmin) {
+                $userType = "Admin"
+            }
+        }
+        catch {
+            # If we can't determine admin status, default to User
+            $userType = "User"
+        }
+        
+        # Sanitize names for file naming (remove invalid characters)
+        $userName = $userName -replace '[<>:"/\\|?*]', '_'
+        $userType = $userType -replace '[<>:"/\\|?*]', '_'
+        
+        return @{
+            UserType = $userType
+            UserName = $userName
+            ComputerName = $computerName
+            FullUserContext = "$userType-$userName"
+        }
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to get current user context: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        return @{
+            UserType = "Unknown"
+            UserName = "UnknownUser"
+            ComputerName = $env:COMPUTERNAME
+            FullUserContext = "Unknown-UnknownUser"
+        }
+    }
+}
+
+function Get-CallingScriptName {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the call stack
+        $callStack = Get-PSCallStack
+        
+        # Look for the actual calling script (not this script or logging functions)
+        $callingScript = "UnknownCaller"
+        
+        # Skip internal logging functions and Discovery script itself
+        $skipFunctions = @('Write-AppDeploymentLog', 'Write-EnhancedLog', 'Handle-Error', 'Get-CallingScriptName', 'Get-CurrentUser')
+        $skipScripts = @('Discovery', 'Discovery.ps1')
+        
+        # Start from index 1 to skip the current function
+        for ($i = 1; $i -lt $callStack.Count; $i++) {
+            $frame = $callStack[$i]
+            
+            # Check if this frame should be skipped
+            $shouldSkip = $false
+            
+            # Skip if it's one of our internal functions
+            if ($frame.Command -and $frame.Command -in $skipFunctions) {
+                $shouldSkip = $true
+            }
+            
+            # Skip if it's the Discovery script itself
+            if ($frame.ScriptName) {
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                if ($scriptName -in $skipScripts) {
+                    $shouldSkip = $true
+                }
+            }
+            
+            # If we shouldn't skip this frame, use it
+            if (-not $shouldSkip) {
+                if ($frame.ScriptName) {
+                    $callingScript = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                    break
+                }
+                elseif ($frame.Command -and $frame.Command -ne "<ScriptBlock>") {
+                    $callingScript = $frame.Command
+                    break
+                }
+            }
+        }
+        
+        # If we still haven't found a caller, determine the execution context
+        if ($callingScript -eq "UnknownCaller") {
+            # Check execution context
+            if ($callStack.Count -le 3) {
+                # Very short call stack suggests direct execution
+                $callingScript = "DirectExecution"
+            }
+            elseif ($MyInvocation.InvocationName -and $MyInvocation.InvocationName -ne "Get-CallingScriptName") {
+                # Use the invocation name if available
+                $callingScript = $MyInvocation.InvocationName
+            }
+            elseif ($PSCommandPath) {
+                # Check if we have a command path (script execution)
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($PSCommandPath)
+                if ($scriptName -and $scriptName -notin $skipScripts) {
+                    $callingScript = $scriptName
+                } else {
+                    $callingScript = "PowerShellExecution"
+                }
+            }
+            else {
+                # Check the host name to determine execution context
+                $hostName = $Host.Name
+                switch ($hostName) {
+                    "ConsoleHost" { $callingScript = "PowerShellConsole" }
+                    "Windows PowerShell ISE Host" { $callingScript = "PowerShell_ISE" }
+                    "ServerRemoteHost" { $callingScript = "RemoteExecution" }
+                    "Visual Studio Code Host" { $callingScript = "VSCode" }
+                    default { $callingScript = "PowerShellHost-$hostName" }
+                }
+            }
+        }
+        
+        return $callingScript
+    }
+    catch {
+        # In case of any error, provide a meaningful fallback
+        try {
+            $hostName = $Host.Name
+            return "ErrorFallback-$hostName"
+        }
+        catch {
+            return "ErrorFallback-Unknown"
+        }
+    }
+}
+
+
+#region Transcript Management Functions
+function Start-CiscoAppTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LogDirectory = "C:\ProgramData\CiscoSecureClient\Logs",
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-AppDeploymentLog -Message "Transcript not started - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $null
+        }
+        
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create directory structure: Logs/Transcript/{Date}/{ParentScript}
+        $transcriptDirectory = Join-Path -Path $LogDirectory -ChildPath "Transcript"
+        $fullTranscriptDirectory = Join-Path -Path $transcriptDirectory -ChildPath $dateFolder
+        $fullTranscriptDirectory = Join-Path -Path $fullTranscriptDirectory -ChildPath $parentScriptName
+        
+        if (-not (Test-Path -Path $fullTranscriptDirectory)) {
+            New-Item -ItemType Directory -Path $fullTranscriptDirectory -Force | Out-Null
+        }
+        
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        $transcriptPath = Join-Path -Path $fullTranscriptDirectory -ChildPath $transcriptFileName
+        
+        # Start transcript with error handling and suppress all console output
+        try {
+            Start-Transcript -Path $transcriptPath -ErrorAction Stop | Out-Null
+            Write-AppDeploymentLog -Message "Transcript started successfully at: $transcriptPath" -Level Information -Mode $LoggingMode
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Failed to start transcript at $transcriptPath" -LoggingMode $LoggingMode
+            return $null
+        }
+        
+        # Transcript rotation
+        try {
+            $transcriptFiles = Get-ChildItem -Path $fullTranscriptDirectory -Filter "*-*-*-*-$parentScriptName-transcript*.log" | Sort-Object LastWriteTime -Descending
+            if ($transcriptFiles.Count -gt 7) {
+                $filesToRemove = $transcriptFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                    Write-AppDeploymentLog -Message "Removed old transcript file: $($file.FullName)" -Level Debug -Mode $LoggingMode
+                }
+            }
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error during transcript file rotation" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptPath
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Start-CiscoAppTranscript function" -LoggingMode $LoggingMode
+        return $null
+    }
+}
+
+function Stop-CiscoAppTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-AppDeploymentLog -Message "Transcript not stopped - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $false
+        }
+        
+        # Check if transcript is running before attempting to stop
+        $transcriptRunning = $false
+        try {
+            # Try to stop transcript and suppress all console output
+            Stop-Transcript -ErrorAction Stop | Out-Null
+            $transcriptRunning = $true
+            Write-AppDeploymentLog -Message "Transcript stopped successfully." -Level Information -Mode $LoggingMode
+        }
+        catch [System.InvalidOperationException] {
+            # This is expected if no transcript is running
+            Write-AppDeploymentLog -Message "No active transcript to stop." -Level Debug -Mode $LoggingMode
+        }
+        catch {
+            # Other transcript-related errors
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error stopping transcript" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptRunning
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Stop-CiscoAppTranscript function" -LoggingMode $LoggingMode
+        return $false
+    }
+}
+
+function Get-TranscriptFilePath {
+    [CmdletBinding()]
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$TranscriptsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+    
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: Transcript/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+        
+        # Generate timestamp for unique transcript file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the transcript file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-transcript-{Timestamp}.log
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        
+        # Combine the full path
+        $transcriptFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $transcriptFileName
+        
+        return $transcriptFilePath
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to generate transcript file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-fallback-$timestamp.log"
+    }
+}
+#endregion Transcript Management Functions
+function Get-CSVLogFilePath {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [string]$LogsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: PSF/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+
+        # Generate timestamp for unique log file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the log file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-log-{Timestamp}.csv
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-$timestamp.csv"
+        
+        # Combine the full path
+        $csvLogFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $logFileName
+        
+        return $csvLogFilePath
+    }
+    catch {
+        Write-AppDeploymentLog -Message "Failed to generate CSV log file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-fallback-$timestamp.csv"
+    }
+}
+
+
+
+
+#endregion Helper Functions
+
+
+#endregion Logging Function
+
+# Export module members
+Export-ModuleMember -Function @(
+    'Write-AppDeploymentLog',
+    'Write-EnhancedLog',
+    'Handle-Error',
+    'Get-ParentScriptName',
+    'Get-CurrentUser',
+    'Get-CallingScriptName',
+    'Start-CiscoAppTranscript',
+    'Stop-CiscoAppTranscript',
+    'Get-TranscriptFilePath',
+    'Get-CSVLogFilePath'
+)
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/logging/logging.psm1.backup b/Win32Apps-Source/Cisco Secure Client/logging/logging.psm1.backup
new file mode 100644
index 0000000..953bc10
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/logging/logging.psm1.backup	
@@ -0,0 +1,811 @@
+#region Logging Function
+
+
+function Write-ActiveBarVulnLog {
+    [CmdletBinding()]
+    Param (
+        [Parameter(Mandatory = $true)]
+        [string]$Message,
+        [Parameter()]
+        [ValidateSet('Information', 'Warning', 'Error', 'Debug')]
+        [string]$Level = 'Information',
+        [Parameter()]
+        [ValidateSet('EnableDebug', 'SilentMode', 'Off')]
+        [string]$Mode = 'Off'
+    )
+
+    # Determine logging mode - check EnableDebug first, then parameter, then default to Off
+    $loggingMode = if ($EnableDebug) { 
+        'EnableDebug' 
+    } elseif ($Mode -ne 'Off') { 
+        $Mode 
+    } else { 
+        'Off' 
+    }
+
+    # Exit early if logging is completely disabled
+    if ($loggingMode -eq 'Off') {
+        return
+    }
+
+    # Enhanced caller information using improved logic from Write-EnhancedLog
+    $callStack = Get-PSCallStack
+    
+    # Simplified and corrected function name detection logic
+    $callerFunction = '<Unknown>'
+    if ($callStack.Count -ge 2) {
+        $caller = $callStack[1]
+        
+        # Use the same simple approach as Write-EnhancedLog that works correctly
+        if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+            # This is a function name
+            $callerFunction = $caller.Command
+        } else {
+            # This is either main script execution or a script file name - use MainScript
+            $callerFunction = 'MainScript'
+        }
+    }
+    
+    # Get parent script name
+    $parentScriptName = try {
+        Get-ParentScriptName
+    } catch {
+        "UnknownScript"
+    }
+    
+    # Get line number and script name for detailed logging
+    $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+    $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+        Split-Path -Leaf $callStack[1].ScriptName 
+    } else { 
+        $parentScriptName 
+    }
+
+    # Create enhanced caller information combining both approaches
+    $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+    $detailedCallerInfo = "[$scriptFileName`:$lineNumber $callerFunction]"
+
+    $timeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $fileLogMessage = "[$timeStamp] [$Level] $enhancedCallerInfo - $Message"
+    $consoleLogMessage = "[$Level] $enhancedCallerInfo - $Message" # No timestamp for console
+
+    #region Local File Logging
+    # Skip all file logging if DisableFileLogging is set
+    if ($script:DisableFileLogging) {
+        return
+    }
+    
+    # Use session-based paths if available, otherwise fall back to per-call generation
+    if ($script:SessionLogFilePath -and $script:SessionFullLogDirectory) {
+        $logFilePath = $script:SessionLogFilePath
+        $logDirectory = $script:SessionFullLogDirectory
+    } else {
+        # Fallback to old method if session variables aren't set
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        $logDirectory = "C:\ProgramData\ActiveBarVuln\Logs"
+        $fullLogDirectory = Join-Path -Path $logDirectory -ChildPath $dateFolder
+        $fullLogDirectory = Join-Path -Path $fullLogDirectory -ChildPath $parentScriptName
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.log"
+        $logFilePath = Join-Path -Path $fullLogDirectory -ChildPath $logFileName
+        $logDirectory = $fullLogDirectory
+    }
+    
+    if (-not (Test-Path -Path $logDirectory)) {
+        New-Item -ItemType Directory -Path $logDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+    }
+    
+    if (Test-Path -Path $logDirectory) {
+        Add-Content -Path $logFilePath -Value $fileLogMessage -ErrorAction SilentlyContinue
+        
+        # Log rotation for local files (keep max 7 files)
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $logFiles = Get-ChildItem -Path $logDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.log" | Sort-Object LastWriteTime -Descending
+            if ($logFiles.Count -gt 7) {
+                $filesToRemove = $logFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for log rotation
+        }
+    }
+    #endregion Local File Logging
+
+    #region Network Share CSV Logging
+    # Network logging: Only save CSV format logs under a parent job folder for better organization
+    try {
+        $hostname = $env:COMPUTERNAME
+        $jobName = "ActiveBarVuln"  # Parent job folder name
+        $networkBasePath = "\\AZR1PSCCM02\.logs\$jobName\$hostname"
+        
+        # Test network connectivity first
+        $networkAvailable = Test-Path "\\AZR1PSCCM02\.logs" -ErrorAction SilentlyContinue
+        
+        if ($networkAvailable) {
+            # Use session-based paths if available
+            if ($script:SessionDateFolder -and $script:SessionParentScript -and $script:SessionCSVFileName) {
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $script:SessionDateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionParentScript
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $script:SessionCSVFileName
+            } else {
+                # Fallback method
+                $dateFolder = Get-Date -Format "yyyy-MM-dd"
+                $parentScriptName = Get-ParentScriptName
+                $userContext = Get-CurrentUser
+                $callingScript = Get-CallingScriptName
+                $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+                
+                $fullNetworkCSVPath = Join-Path -Path $networkBasePath -ChildPath $dateFolder
+                $fullNetworkCSVPath = Join-Path -Path $fullNetworkCSVPath -ChildPath $parentScriptName
+                $networkCSVFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+                $networkCSVFile = Join-Path -Path $fullNetworkCSVPath -ChildPath $networkCSVFileName
+            }
+            
+            if (-not (Test-Path -Path $fullNetworkCSVPath)) {
+                New-Item -ItemType Directory -Path $fullNetworkCSVPath -Force -ErrorAction SilentlyContinue | Out-Null
+            }
+            
+            if (Test-Path -Path $fullNetworkCSVPath) {
+                # Create CSV entry for network logging
+                $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+                $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+                $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+                
+                # Get caller information
+                $callStack = Get-PSCallStack
+                $callerFunction = '<Unknown>'
+                if ($callStack.Count -ge 2) {
+                    $caller = $callStack[1]
+                    if ($caller.Command -and $caller.Command -notlike "*.ps1") {
+                        $callerFunction = $caller.Command
+                    } else {
+                        $callerFunction = 'MainScript'
+                    }
+                }
+                
+                $lineNumber = if ($callStack.Count -ge 2) { $callStack[1].ScriptLineNumber } else { 0 }
+                $scriptFileName = if ($callStack.Count -ge 2 -and $callStack[1].ScriptName) { 
+                    Split-Path -Leaf $callStack[1].ScriptName 
+                } else { 
+                    $parentScriptName 
+                }
+                
+                $enhancedCallerInfo = "[$parentScriptName.$callerFunction]"
+                
+                $networkCSVEntry = [PSCustomObject]@{
+                    Timestamp       = $timeStamp
+                    Level           = $Level
+                    ParentScript    = $parentScriptName
+                    CallingScript   = $callingScript
+                    ScriptName      = $scriptFileName
+                    FunctionName    = $callerFunction
+                    LineNumber      = $lineNumber
+                    Message         = $Message
+                    Hostname        = $env:COMPUTERNAME
+                    UserType        = $userContext.UserType
+                    UserName        = $userContext.UserName
+                    FullUserContext = $userContext.FullUserContext
+                    CallerInfo      = $enhancedCallerInfo
+                    JobName         = $jobName
+                    LogType         = "NetworkCSV"
+                }
+                
+                # Check if network CSV exists, if not create with headers
+                if (-not (Test-Path -Path $networkCSVFile)) {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -ErrorAction SilentlyContinue
+                } else {
+                    $networkCSVEntry | Export-Csv -Path $networkCSVFile -NoTypeInformation -Append -ErrorAction SilentlyContinue
+                }
+                
+                # Network CSV log rotation (keep max 5 files per machine per script)
+                try {
+                    $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+                    $networkCSVFiles = Get-ChildItem -Path $fullNetworkCSVPath -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+                    if ($networkCSVFiles.Count -gt 5) {
+                        $filesToRemove = $networkCSVFiles | Select-Object -Skip 5
+                        foreach ($file in $filesToRemove) {
+                            Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                        }
+                    }
+                }
+                catch {
+                    # Silent error handling for network CSV log rotation
+                }
+            }
+        }
+    }
+    catch {
+        # Silent error handling for network CSV logging - don't interfere with main script
+    }
+    #endregion Network Share CSV Logging
+
+    #region CSV Logging
+    try {
+        # Use session-based paths if available
+        if ($script:SessionCSVFilePath -and $script:SessionFullCSVDirectory) {
+            $csvLogPath = $script:SessionCSVFilePath
+            $csvDirectory = $script:SessionFullCSVDirectory
+        } else {
+            # Fallback method
+            $userContext = Get-CurrentUser
+            $callingScript = Get-CallingScriptName
+            $parentScriptName = Get-ParentScriptName
+            $dateFolder = Get-Date -Format "yyyy-MM-dd"
+            $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+            
+            $csvLogDirectory = "C:\ProgramData\ActiveBarVuln\Logs\CSV"
+            $fullCSVDirectory = Join-Path -Path $csvLogDirectory -ChildPath $dateFolder
+            $fullCSVDirectory = Join-Path -Path $fullCSVDirectory -ChildPath $parentScriptName
+            $csvFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-activity-$timestamp.csv"
+            $csvLogPath = Join-Path -Path $fullCSVDirectory -ChildPath $csvFileName
+            $csvDirectory = $fullCSVDirectory
+        }
+        
+        if (-not (Test-Path -Path $csvDirectory)) {
+            New-Item -ItemType Directory -Path $csvDirectory -Force -ErrorAction SilentlyContinue | Out-Null
+        }
+        
+        # Use session context if available, otherwise get fresh context
+        $userContext = if ($script:SessionUserContext) { $script:SessionUserContext } else { Get-CurrentUser }
+        $callingScript = if ($script:SessionCallingScript) { $script:SessionCallingScript } else { Get-CallingScriptName }
+        $parentScriptName = if ($script:SessionParentScript) { $script:SessionParentScript } else { Get-ParentScriptName }
+        
+        $csvEntry = [PSCustomObject]@{
+            Timestamp       = $timeStamp
+            Level           = $Level
+            ParentScript    = $parentScriptName
+            CallingScript   = $callingScript
+            ScriptName      = $scriptFileName
+            FunctionName    = $callerFunction
+            LineNumber      = $lineNumber
+            Message         = $Message
+            Hostname        = $env:COMPUTERNAME
+            UserType        = $userContext.UserType
+            UserName        = $userContext.UserName
+            FullUserContext = $userContext.FullUserContext
+            CallerInfo      = $enhancedCallerInfo
+        }
+        
+        # Check if CSV exists, if not create with headers
+        if (-not (Test-Path -Path $csvLogPath)) {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -ErrorAction SilentlyContinue
+        } else {
+            $csvEntry | Export-Csv -Path $csvLogPath -NoTypeInformation -Append -ErrorAction SilentlyContinue
+        }
+        
+        # CSV log rotation
+        try {
+            $parentScriptForFilter = if ($script:SessionParentScript) { $script:SessionParentScript } else { "Discovery" }
+            $csvFiles = Get-ChildItem -Path $csvDirectory -Filter "*-*-*-*-$parentScriptForFilter-activity*.csv" | Sort-Object LastWriteTime -Descending
+            if ($csvFiles.Count -gt 7) {
+                $filesToRemove = $csvFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                }
+            }
+        }
+        catch {
+            # Silent error handling for CSV log rotation
+        }
+    }
+    catch {
+        # Silent error handling for CSV logging
+    }
+    #endregion CSV Logging
+
+    #region Console Output (only in EnableDebug mode)
+    if ($loggingMode -eq 'EnableDebug') {
+        switch ($Level.ToUpper()) {
+            'ERROR' { Write-Host $consoleLogMessage -ForegroundColor Red }
+            'WARNING' { Write-Host $consoleLogMessage -ForegroundColor Yellow }
+            'INFORMATION' { Write-Host $consoleLogMessage -ForegroundColor White }
+            'DEBUG' { Write-Host $consoleLogMessage -ForegroundColor Gray }
+        }
+    }
+    #endregion Console Output
+}
+
+function Write-EnhancedLog {
+    [CmdletBinding()]
+    param (
+        [string]$Message,
+        [string]$Level = 'INFO',
+        [string]$LoggingMode = 'SilentMode'
+    )
+
+    # Get the PowerShell call stack to determine the actual calling function
+    $callStack = Get-PSCallStack
+    $callerFunction = if ($callStack.Count -ge 2) { $callStack[1].Command } else { '<Unknown>' }
+
+    # Get the parent script name
+    $parentScriptName = Get-ParentScriptName
+
+    # Map enhanced log levels to ActiveBar log levels
+    $mappedLevel = switch ($Level.ToUpper()) {
+        'CRITICAL' { 'Error' }
+        'ERROR'    { 'Error' }
+        'WARNING'  { 'Warning' }
+        'INFO'     { 'Information' }
+        'DEBUG'    { 'Debug' }
+        'NOTICE'   { 'Information' }
+        'IMPORTANT' { 'Information' }
+        'OUTPUT'   { 'Information' }
+        'SIGNIFICANT' { 'Information' }
+        'VERBOSE'  { 'Debug' }
+        'VERYVERBOSE' { 'Debug' }
+        'SOMEWHATVERBOSE' { 'Debug' }
+        'SYSTEM'   { 'Information' }
+        'INTERNALCOMMENT' { 'Debug' }
+        default    { 'Information' }
+    }
+
+    # Format message with caller information
+    $formattedMessage = "[$parentScriptName.$callerFunction] $Message"
+
+    # Use the existing Write-ActiveBarVulnLog function
+    Write-ActiveBarVulnLog -Message $formattedMessage -Level $mappedLevel -Mode $LoggingMode
+}
+
+#region Helper Functions
+
+
+#region Error Handling
+function Handle-Error {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [System.Management.Automation.ErrorRecord]$ErrorRecord,
+        [string]$CustomMessage = "",
+        [string]$LoggingMode = "SilentMode"
+    )
+
+    try {
+        if ($PSVersionTable.PSVersion.Major -ge 7) {
+            $fullErrorDetails = Get-Error -InputObject $ErrorRecord | Out-String
+        } else {
+            $fullErrorDetails = $ErrorRecord.Exception | Format-List * -Force | Out-String
+        }
+
+        $errorMessage = if ($CustomMessage) {
+            "$CustomMessage - Exception: $($ErrorRecord.Exception.Message)"
+        } else {
+            "Exception Message: $($ErrorRecord.Exception.Message)"
+        }
+
+        Write-ActiveBarVulnLog -Message $errorMessage -Level Error -Mode $LoggingMode
+        Write-ActiveBarVulnLog -Message "Full Exception Details: $fullErrorDetails" -Level Debug -Mode $LoggingMode
+        Write-ActiveBarVulnLog -Message "Script Line Number: $($ErrorRecord.InvocationInfo.ScriptLineNumber)" -Level Debug -Mode $LoggingMode
+        Write-ActiveBarVulnLog -Message "Position Message: $($ErrorRecord.InvocationInfo.PositionMessage)" -Level Debug -Mode $LoggingMode
+    } 
+    catch {
+        # Fallback error handling in case of an unexpected error in the try block
+        Write-ActiveBarVulnLog -Message "An error occurred while handling another error. Original Exception: $($ErrorRecord.Exception.Message)" -Level Error -Mode $LoggingMode
+        Write-ActiveBarVulnLog -Message "Handler Exception: $($_.Exception.Message)" -Level Error -Mode $LoggingMode
+    }
+}
+#endregion Error Handling
+
+function Get-ParentScriptName {
+    [CmdletBinding()]
+    param ()
+
+    try {
+        # Get the current call stack
+        $callStack = Get-PSCallStack
+
+        # If there is a call stack, return the top-most script name
+        if ($callStack.Count -gt 0) {
+            foreach ($frame in $callStack) {
+                if ($frame.ScriptName) {
+                    $parentScriptName = $frame.ScriptName
+                    # Write-EnhancedLog -Message "Found script in call stack: $parentScriptName" -Level "INFO"
+                }
+            }
+
+            if (-not [string]::IsNullOrEmpty($parentScriptName)) {
+                $parentScriptName = [System.IO.Path]::GetFileNameWithoutExtension($parentScriptName)
+                return $parentScriptName
+            }
+        }
+
+        # If no script name was found, return 'UnknownScript'
+        Write-EnhancedLog -Message "No script name found in the call stack." -Level "WARNING"
+        return "UnknownScript"
+    }
+    catch {
+        Write-EnhancedLog -Message "An error occurred while retrieving the parent script name: $_" -Level "ERROR"
+        return "UnknownScript"
+    }
+}
+
+function Get-CurrentUser {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the current user context
+        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
+        $computerName = $env:COMPUTERNAME
+        
+        # Check if running as SYSTEM
+        if ($currentUser -like "*SYSTEM*" -or $currentUser -eq "NT AUTHORITY\SYSTEM") {
+            return @{
+                UserType = "SYSTEM"
+                UserName = "LocalSystem"
+                ComputerName = $computerName
+                FullUserContext = "SYSTEM-LocalSystem"
+            }
+        }
+        
+        # Extract domain and username
+        if ($currentUser.Contains('\')) {
+            $domain = $currentUser.Split('\')[0]
+            $userName = $currentUser.Split('\')[1]
+        } else {
+            $domain = $env:USERDOMAIN
+            $userName = $currentUser
+        }
+        
+        # Determine user type based on group membership
+        $userType = "User"
+        try {
+            $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
+            if ($isAdmin) {
+                $userType = "Admin"
+            }
+        }
+        catch {
+            # If we can't determine admin status, default to User
+            $userType = "User"
+        }
+        
+        # Sanitize names for file naming (remove invalid characters)
+        $userName = $userName -replace '[<>:"/\\|?*]', '_'
+        $userType = $userType -replace '[<>:"/\\|?*]', '_'
+        
+        return @{
+            UserType = $userType
+            UserName = $userName
+            ComputerName = $computerName
+            FullUserContext = "$userType-$userName"
+        }
+    }
+    catch {
+        Write-ActiveBarVulnLog -Message "Failed to get current user context: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        return @{
+            UserType = "Unknown"
+            UserName = "UnknownUser"
+            ComputerName = $env:COMPUTERNAME
+            FullUserContext = "Unknown-UnknownUser"
+        }
+    }
+}
+
+function Get-CallingScriptName {
+    [CmdletBinding()]
+    param()
+    
+    try {
+        # Get the call stack
+        $callStack = Get-PSCallStack
+        
+        # Look for the actual calling script (not this script or logging functions)
+        $callingScript = "UnknownCaller"
+        
+        # Skip internal logging functions and Discovery script itself
+        $skipFunctions = @('Write-ActiveBarVulnLog', 'Write-EnhancedLog', 'Handle-Error', 'Get-CallingScriptName', 'Get-CurrentUser')
+        $skipScripts = @('Discovery', 'Discovery.ps1')
+        
+        # Start from index 1 to skip the current function
+        for ($i = 1; $i -lt $callStack.Count; $i++) {
+            $frame = $callStack[$i]
+            
+            # Check if this frame should be skipped
+            $shouldSkip = $false
+            
+            # Skip if it's one of our internal functions
+            if ($frame.Command -and $frame.Command -in $skipFunctions) {
+                $shouldSkip = $true
+            }
+            
+            # Skip if it's the Discovery script itself
+            if ($frame.ScriptName) {
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                if ($scriptName -in $skipScripts) {
+                    $shouldSkip = $true
+                }
+            }
+            
+            # If we shouldn't skip this frame, use it
+            if (-not $shouldSkip) {
+                if ($frame.ScriptName) {
+                    $callingScript = [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName)
+                    break
+                }
+                elseif ($frame.Command -and $frame.Command -ne "<ScriptBlock>") {
+                    $callingScript = $frame.Command
+                    break
+                }
+            }
+        }
+        
+        # If we still haven't found a caller, determine the execution context
+        if ($callingScript -eq "UnknownCaller") {
+            # Check execution context
+            if ($callStack.Count -le 3) {
+                # Very short call stack suggests direct execution
+                $callingScript = "DirectExecution"
+            }
+            elseif ($MyInvocation.InvocationName -and $MyInvocation.InvocationName -ne "Get-CallingScriptName") {
+                # Use the invocation name if available
+                $callingScript = $MyInvocation.InvocationName
+            }
+            elseif ($PSCommandPath) {
+                # Check if we have a command path (script execution)
+                $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($PSCommandPath)
+                if ($scriptName -and $scriptName -notin $skipScripts) {
+                    $callingScript = $scriptName
+                } else {
+                    $callingScript = "PowerShellExecution"
+                }
+            }
+            else {
+                # Check the host name to determine execution context
+                $hostName = $Host.Name
+                switch ($hostName) {
+                    "ConsoleHost" { $callingScript = "PowerShellConsole" }
+                    "Windows PowerShell ISE Host" { $callingScript = "PowerShell_ISE" }
+                    "ServerRemoteHost" { $callingScript = "RemoteExecution" }
+                    "Visual Studio Code Host" { $callingScript = "VSCode" }
+                    default { $callingScript = "PowerShellHost-$hostName" }
+                }
+            }
+        }
+        
+        return $callingScript
+    }
+    catch {
+        # In case of any error, provide a meaningful fallback
+        try {
+            $hostName = $Host.Name
+            return "ErrorFallback-$hostName"
+        }
+        catch {
+            return "ErrorFallback-Unknown"
+        }
+    }
+}
+
+
+#region Transcript Management Functions
+function Start-ActiveBarTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LogDirectory = "C:\ProgramData\ActiveBarVuln\Logs",
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-ActiveBarVulnLog -Message "Transcript not started - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $null
+        }
+        
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $parentScriptName = Get-ParentScriptName
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create directory structure: Logs/Transcript/{Date}/{ParentScript}
+        $transcriptDirectory = Join-Path -Path $LogDirectory -ChildPath "Transcript"
+        $fullTranscriptDirectory = Join-Path -Path $transcriptDirectory -ChildPath $dateFolder
+        $fullTranscriptDirectory = Join-Path -Path $fullTranscriptDirectory -ChildPath $parentScriptName
+        
+        if (-not (Test-Path -Path $fullTranscriptDirectory)) {
+            New-Item -ItemType Directory -Path $fullTranscriptDirectory -Force | Out-Null
+        }
+        
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        $transcriptPath = Join-Path -Path $fullTranscriptDirectory -ChildPath $transcriptFileName
+        
+        # Start transcript with error handling and suppress all console output
+        try {
+            Start-Transcript -Path $transcriptPath -ErrorAction Stop | Out-Null
+            Write-ActiveBarVulnLog -Message "Transcript started successfully at: $transcriptPath" -Level Information -Mode $LoggingMode
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Failed to start transcript at $transcriptPath" -LoggingMode $LoggingMode
+            return $null
+        }
+        
+        # Transcript rotation
+        try {
+            $transcriptFiles = Get-ChildItem -Path $fullTranscriptDirectory -Filter "*-*-*-*-$parentScriptName-transcript*.log" | Sort-Object LastWriteTime -Descending
+            if ($transcriptFiles.Count -gt 7) {
+                $filesToRemove = $transcriptFiles | Select-Object -Skip 7
+                foreach ($file in $filesToRemove) {
+                    Remove-Item -Path $file.FullName -Force -ErrorAction SilentlyContinue
+                    Write-ActiveBarVulnLog -Message "Removed old transcript file: $($file.FullName)" -Level Debug -Mode $LoggingMode
+                }
+            }
+        }
+        catch {
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error during transcript file rotation" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptPath
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Start-ActiveBarTranscript function" -LoggingMode $LoggingMode
+        return $null
+    }
+}
+
+function Stop-ActiveBarTranscript {
+    [CmdletBinding()]
+    param(
+        [string]$LoggingMode = "SilentMode"
+    )
+    
+    try {
+        # Check if file logging is disabled
+        if ($script:DisableFileLogging) {
+            Write-ActiveBarVulnLog -Message "Transcript not stopped - file logging is disabled" -Level Debug -Mode $LoggingMode
+            return $false
+        }
+        
+        # Check if transcript is running before attempting to stop
+        $transcriptRunning = $false
+        try {
+            # Try to stop transcript and suppress all console output
+            Stop-Transcript -ErrorAction Stop | Out-Null
+            $transcriptRunning = $true
+            Write-ActiveBarVulnLog -Message "Transcript stopped successfully." -Level Information -Mode $LoggingMode
+        }
+        catch [System.InvalidOperationException] {
+            # This is expected if no transcript is running
+            Write-ActiveBarVulnLog -Message "No active transcript to stop." -Level Debug -Mode $LoggingMode
+        }
+        catch {
+            # Other transcript-related errors
+            Handle-Error -ErrorRecord $_ -CustomMessage "Error stopping transcript" -LoggingMode $LoggingMode
+        }
+        
+        return $transcriptRunning
+    }
+    catch {
+        Handle-Error -ErrorRecord $_ -CustomMessage "Error in Stop-ActiveBarTranscript function" -LoggingMode $LoggingMode
+        return $false
+    }
+}
+
+function Get-TranscriptFilePath {
+    [CmdletBinding()]
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$TranscriptsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+    
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: Transcript/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+        
+        # Generate timestamp for unique transcript file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the transcript file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-transcript-{Timestamp}.log
+        $transcriptFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-$timestamp.log"
+        
+        # Combine the full path
+        $transcriptFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $transcriptFileName
+        
+        return $transcriptFilePath
+    }
+    catch {
+        Write-ActiveBarVulnLog -Message "Failed to generate transcript file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $TranscriptsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-transcript-fallback-$timestamp.log"
+    }
+}
+#endregion Transcript Management Functions
+function Get-CSVLogFilePath {
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory = $true)]
+        [string]$LogsPath,
+        [Parameter(Mandatory = $true)]
+        [string]$JobName,
+        [Parameter(Mandatory = $true)]
+        [string]$parentScriptName
+    )
+
+    try {
+        # Get current user context and calling script
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        
+        # Generate date folder (YYYY-MM-DD format)
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        
+        # Create the full directory path: PSF/{Date}/{ParentScript}
+        $fullDirectoryPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fullDirectoryPath = Join-Path -Path $fullDirectoryPath -ChildPath $parentScriptName
+        
+        # Ensure the directory exists
+        if (-not (Test-Path -Path $fullDirectoryPath)) {
+            New-Item -ItemType Directory -Path $fullDirectoryPath -Force | Out-Null
+        }
+
+        # Generate timestamp for unique log file
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        
+        # Create the log file name following the convention:
+        # {ComputerName}-{CallingScript}-{UserType}-{UserName}-{ParentScript}-log-{Timestamp}.csv
+        $logFileName = "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-$timestamp.csv"
+        
+        # Combine the full path
+        $csvLogFilePath = Join-Path -Path $fullDirectoryPath -ChildPath $logFileName
+        
+        return $csvLogFilePath
+    }
+    catch {
+        Write-ActiveBarVulnLog -Message "Failed to generate CSV log file path: $($_.Exception.Message)" -Level Error -Mode SilentMode
+        # Return a fallback path with user context
+        $userContext = Get-CurrentUser
+        $callingScript = Get-CallingScriptName
+        $timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
+        $dateFolder = Get-Date -Format "yyyy-MM-dd"
+        $fallbackPath = Join-Path -Path $LogsPath -ChildPath $dateFolder
+        $fallbackPath = Join-Path -Path $fallbackPath -ChildPath $parentScriptName
+        if (-not (Test-Path -Path $fallbackPath)) {
+            New-Item -ItemType Directory -Path $fallbackPath -Force | Out-Null
+        }
+        return Join-Path -Path $fallbackPath -ChildPath "$($userContext.ComputerName)-$callingScript-$($userContext.UserType)-$($userContext.UserName)-$parentScriptName-log-fallback-$timestamp.csv"
+    }
+}
+
+
+
+
+#endregion Helper Functions
+
+
+#endregion Logging Function
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/test-get-products.ps1 b/Win32Apps-Source/Cisco Secure Client/test-get-products.ps1
new file mode 100644
index 0000000..bfdcef4
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/test-get-products.ps1	
@@ -0,0 +1,116 @@
+# Load the functions without running the main script
+$ErrorActionPreference = 'Stop'
+
+# Define the logging function
+function Write-Log {
+    param([string]$Message, [string]$Level = 'Info')
+    Write-Host "[$Level] $Message"
+}
+
+# Define the Get-CiscoInstalledProducts function
+function Get-CiscoInstalledProducts {
+    Write-Log "Searching for installed Cisco Secure Client components..."
+    
+    $InstalledProducts = @()
+    
+    # Known product codes for version 5.1.10.233
+    $KnownProducts = @(
+        @{
+            Name = "Cisco Secure Client - Diagnostics and Reporting Tool"
+            Code = "{B68CDB22-0490-4275-9645-ECF202869592}"
+            Order = 1
+        },
+        @{
+            Name = "Cisco Secure Client - Umbrella"
+            Code = "{51DAD0BB-84FA-4942-A00C-D4014529D6A5}"
+            Order = 2
+        },
+        @{
+            Name = "Cisco Secure Client - AnyConnect VPN"
+            Code = "{A39D1E16-8CCD-44EC-9ADF-33C04A3F590F}"
+            Order = 3
+        }
+    )
+    
+    # Check registry for installed components
+    $RegistryPaths = @(
+        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
+        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
+    )
+    
+    foreach ($Path in $RegistryPaths) {
+        if (Test-Path $Path) {
+            $Items = Get-ChildItem -Path $Path -ErrorAction SilentlyContinue
+            
+            foreach ($Item in $Items) {
+                $App = Get-ItemProperty -Path $Item.PSPath -ErrorAction SilentlyContinue
+                
+                if ($App.DisplayName -like "*Cisco Secure Client*" -or $App.DisplayName -like "*Cisco AnyConnect*") {
+                    # Check if it's a known product
+                    $KnownProduct = $KnownProducts | Where-Object { $_.Code -eq $Item.PSChildName }
+                    
+                    if ($KnownProduct) {
+                        $InstalledProducts += @{
+                            Name = $KnownProduct.Name
+                            Code = $KnownProduct.Code
+                            Order = $KnownProduct.Order
+                            Version = $App.DisplayVersion
+                        }
+                    }
+                    else {
+                        # Unknown Cisco product
+                        $InstalledProducts += @{
+                            Name = $App.DisplayName
+                            Code = $Item.PSChildName
+                            Order = 99  # Uninstall unknown products last
+                            Version = $App.DisplayVersion
+                        }
+                    }
+                    
+                    Write-Log "Found: $($App.DisplayName) v$($App.DisplayVersion)"
+                }
+            }
+        }
+    }
+    
+    Write-Host "`nBefore sorting:"
+    Write-Host "InstalledProducts count: $($InstalledProducts.Count)"
+    Write-Host "InstalledProducts type: $($InstalledProducts.GetType().Name)"
+    
+    # Sort by order (uninstall in reverse order of installation)
+    # PowerShell 5.1 compatibility: ensure we only return hashtables
+    $SortedProducts = @()
+    foreach ($Product in $InstalledProducts) {
+        if ($Product -is [hashtable]) {
+            $SortedProducts += $Product
+        }
+    }
+    
+    Write-Host "`nAfter filtering:"
+    Write-Host "SortedProducts count: $($SortedProducts.Count)"
+    
+    # Ensure we always return an array, even with single item
+    if ($SortedProducts.Count -eq 0) {
+        return @()
+    } elseif ($SortedProducts.Count -eq 1) {
+        return @($SortedProducts[0])
+    } else {
+        return @($SortedProducts | Sort-Object -Property { $_['Order'] })
+    }
+}
+
+# Test the function
+$products = Get-CiscoInstalledProducts
+
+Write-Host "`nFinal result:"
+Write-Host "Type: $($products.GetType().Name)"
+Write-Host "Count: $($products.Count)"
+
+foreach ($p in $products) {
+    Write-Host "`nProduct:"
+    Write-Host "  Type: $($p.GetType().Name)"
+    if ($p -is [hashtable]) {
+        Write-Host "  Name: $($p['Name'])"
+        Write-Host "  Code: $($p['Code'])"
+    }
+}
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/test-output.ps1 b/Win32Apps-Source/Cisco Secure Client/test-output.ps1
new file mode 100644
index 0000000..3f57c1a
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/test-output.ps1	
@@ -0,0 +1,5 @@
+# Test output length
+$output = & powershell -ExecutionPolicy Bypass -File check.ps1 2>&1
+Write-Host "Output length: $($output.Length)"
+Write-Host "Output empty: $($null -eq $output -or $output.Length -eq 0)"
+Write-Host "Exit code: $LASTEXITCODE"
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/test-output2.ps1 b/Win32Apps-Source/Cisco Secure Client/test-output2.ps1
new file mode 100644
index 0000000..aeab857
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/test-output2.ps1	
@@ -0,0 +1,5 @@
+# Test exact output
+$output = & powershell -ExecutionPolicy Bypass -File check.ps1 2>&1
+Write-Host "Output: [$output]"
+Write-Host "Output length: $($output.Length)"
+Write-Host "Exit code: $LASTEXITCODE"
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/test-reg.ps1 b/Win32Apps-Source/Cisco Secure Client/test-reg.ps1
new file mode 100644
index 0000000..e69de29
diff --git a/Win32Apps-Source/Cisco Secure Client/test-services.ps1 b/Win32Apps-Source/Cisco Secure Client/test-services.ps1
new file mode 100644
index 0000000..9a500a2
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/test-services.ps1	
@@ -0,0 +1 @@
+Get-Service -Name 'csc_*', 'vpnagent', 'acwebsecagent' -ErrorAction SilentlyContinue | Select-Object Name, Status
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/test-uninstall-debug.ps1 b/Win32Apps-Source/Cisco Secure Client/test-uninstall-debug.ps1
new file mode 100644
index 0000000..9d92006
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/test-uninstall-debug.ps1	
@@ -0,0 +1,32 @@
+# Debug script to check what's in the registry
+$RegistryPaths = @(
+    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
+    "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
+)
+
+$CiscoProducts = @()
+
+foreach ($Path in $RegistryPaths) {
+    if (Test-Path $Path) {
+        $Items = Get-ChildItem -Path $Path -ErrorAction SilentlyContinue
+        
+        foreach ($Item in $Items) {
+            $App = Get-ItemProperty -Path $Item.PSPath -ErrorAction SilentlyContinue
+            
+            if ($App.DisplayName -like "*Cisco Secure Client*" -or $App.DisplayName -like "*Cisco AnyConnect*") {
+                Write-Host "Found: $($App.DisplayName)"
+                Write-Host "  Code: $($Item.PSChildName)"
+                Write-Host "  Type: $($Item.GetType().Name)"
+                $CiscoProducts += @{
+                    Name = $App.DisplayName
+                    Code = $Item.PSChildName
+                }
+            }
+        }
+    }
+}
+
+Write-Host "`nTotal found: $($CiscoProducts.Count)"
+foreach ($p in $CiscoProducts) {
+    Write-Host "Product: $($p['Name']) - Code: $($p['Code'])"
+}
\ No newline at end of file
diff --git a/Win32Apps-Source/Cisco Secure Client/uninstall.ps1 b/Win32Apps-Source/Cisco Secure Client/uninstall.ps1
new file mode 100644
index 0000000..7cf5054
--- /dev/null
+++ b/Win32Apps-Source/Cisco Secure Client/uninstall.ps1	
@@ -0,0 +1,321 @@
+<#
+.SYNOPSIS
+    Uninstalls Cisco Secure Client components.
+
+.DESCRIPTION
+    This script uninstalls Cisco Secure Client components in reverse order:
+    1. DART component
+    2. Umbrella component
+    3. Core VPN component
+    
+    Designed for Intune Win32 app deployment.
+
+.NOTES
+    Version:        1.0
+    Creation Date:  2025-01-12
+    Purpose:        Intune Win32 App Uninstallation Script
+    Compatibility:  PowerShell 5.1
+#>
+
+#region Script Configuration
+$LogPath = "$env:ProgramData\Microsoft\IntuneManagementExtension\Logs"
+$LogFile = Join-Path $LogPath "CiscoSecureClient_Uninstall_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
+#endregion
+
+#region Logging Functions
+function Write-Log {
+    param(
+        [Parameter(Mandatory=$true)]
+        [string]$Message,
+        
+        [Parameter(Mandatory=$false)]
+        [ValidateSet('Info','Warning','Error')]
+        [string]$Level = 'Info'
+    )
+    
+    $TimeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+    $LogMessage = "$TimeStamp [$Level] $Message"
+    
+    # Write to log file
+    Add-Content -Path $LogFile -Value $LogMessage -Force
+    
+    # Also write to console for Intune
+    switch ($Level) {
+        'Warning' { Write-Warning $Message }
+        'Error' { Write-Error $Message }
+        default { Write-Output $Message }
+    }
+}
+#endregion
+
+#region Uninstallation Functions
+function Stop-CiscoServices {
+    Write-Log "Stopping Cisco services..."
+    
+    $CiscoServices = @(
+        "csc_umbrellaagent",
+        "vpnagent",
+        "acwebsecagent"
+    )
+    
+    foreach ($ServiceName in $CiscoServices) {
+        $Service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
+        if ($Service -and $Service.Status -eq 'Running') {
+            Write-Log "Stopping service: $ServiceName"
+            Stop-Service -Name $ServiceName -Force -ErrorAction SilentlyContinue
+            Start-Sleep -Seconds 2
+        }
+    }
+}
+
+function Stop-CiscoProcesses {
+    Write-Log "Stopping Cisco processes..."
+    
+    $CiscoProcesses = @(
+        "vpnui",
+        "vpnagent",
+        "csc_umbrellaagent",
+        "acwebsecagent"
+    )
+    
+    foreach ($ProcessName in $CiscoProcesses) {
+        $Processes = Get-Process -Name $ProcessName -ErrorAction SilentlyContinue
+        if ($Processes) {
+            Write-Log "Stopping process: $ProcessName"
+            $Processes | Stop-Process -Force -ErrorAction SilentlyContinue
+            Start-Sleep -Seconds 1
+        }
+    }
+}
+
+function Uninstall-CiscoComponent {
+    param(
+        [Parameter(Mandatory=$true)]
+        [string]$ProductName,
+        
+        [Parameter(Mandatory=$true)]
+        [string]$ProductCode
+    )
+    
+    Write-Log "Uninstalling $ProductName..."
+    
+    # Sanitize product name for log file
+    $LogFileName = $ProductName -replace '[^\w\-\.]', '_'
+    $UninstallLogFile = Join-Path $LogPath "${LogFileName}_Uninstall_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
+    $ArgumentList = "/x `"$ProductCode`" /qn /norestart /l*v `"$UninstallLogFile`""
+    
+    $Process = Start-Process -FilePath "msiexec.exe" -ArgumentList $ArgumentList -Wait -PassThru
+    
+    if ($Process.ExitCode -eq 0) {
+        Write-Log "$ProductName uninstalled successfully."
+        return $true
+    }
+    elseif ($Process.ExitCode -eq 3010) {
+        Write-Log "$ProductName uninstalled successfully but requires a reboot." -Level Warning
+        return $true
+    }
+    else {
+        Write-Log "$ProductName uninstallation failed with exit code: $($Process.ExitCode)" -Level Error
+        return $false
+    }
+}
+
+function Get-CiscoInstalledProducts {
+    Write-Log "Searching for installed Cisco Secure Client components..."
+    
+    $InstalledProducts = @()
+    
+    # Known product codes for version 5.1.10.233
+    $KnownProducts = @(
+        @{
+            Name = "Cisco Secure Client - Diagnostics and Reporting Tool"
+            Code = "{B68CDB22-0490-4275-9645-ECF202869592}"
+            Order = 1
+        },
+        @{
+            Name = "Cisco Secure Client - Umbrella"
+            Code = "{51DAD0BB-84FA-4942-A00C-D4014529D6A5}"
+            Order = 2
+        },
+        @{
+            Name = "Cisco Secure Client - AnyConnect VPN"
+            Code = "{A39D1E16-8CCD-44EC-9ADF-33C04A3F590F}"
+            Order = 3
+        }
+    )
+    
+    # Check registry for installed components
+    $RegistryPaths = @(
+        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
+        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
+    )
+    
+    foreach ($Path in $RegistryPaths) {
+        if (Test-Path $Path) {
+            $Items = Get-ChildItem -Path $Path -ErrorAction SilentlyContinue
+            
+            foreach ($Item in $Items) {
+                $App = Get-ItemProperty -Path $Item.PSPath -ErrorAction SilentlyContinue
+                
+                if ($App.DisplayName -like "*Cisco Secure Client*" -or $App.DisplayName -like "*Cisco AnyConnect*") {
+                    # Check if it's a known product
+                    $KnownProduct = $KnownProducts | Where-Object { $_.Code -eq $Item.PSChildName }
+                    
+                    if ($KnownProduct) {
+                        $InstalledProducts += @{
+                            Name = $KnownProduct.Name
+                            Code = $KnownProduct.Code
+                            Order = $KnownProduct.Order
+                            Version = $App.DisplayVersion
+                        }
+                    }
+                    else {
+                        # Unknown Cisco product - validate that we have a proper GUID as product code
+                        if ($Item.PSChildName -match "^\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\}$") {
+                            $InstalledProducts += @{
+                                Name = $App.DisplayName
+                                Code = $Item.PSChildName
+                                Order = 99  # Uninstall unknown products last
+                                Version = $App.DisplayVersion
+                            }
+                        } else {
+                            Write-Log "Skipping registry entry with invalid product code format: $($App.DisplayName) [Code: $($Item.PSChildName)]" -Level Warning
+                        }
+                    }
+                    
+                    Write-Log "Found: $($App.DisplayName) v$($App.DisplayVersion)"
+                }
+            }
+        }
+    }
+    
+    # Sort by order (uninstall in reverse order of installation)
+    # PowerShell 5.1 compatibility: ensure we only return hashtables
+    $SortedProducts = @()
+    foreach ($Product in $InstalledProducts) {
+        if ($Product -is [hashtable]) {
+            $SortedProducts += $Product
+        }
+    }
+    
+    # Ensure we always return an array, even with single item
+    if ($SortedProducts.Count -eq 0) {
+        return @()
+    } elseif ($SortedProducts.Count -eq 1) {
+        return @($SortedProducts[0])
+    } else {
+        return @($SortedProducts | Sort-Object -Property { $_['Order'] })
+    }
+}
+#endregion
+
+#region Main Uninstallation Logic
+try {
+    # Create log directory if it doesn't exist
+    if (-not (Test-Path $LogPath)) {
+        New-Item -ItemType Directory -Path $LogPath -Force | Out-Null
+    }
+    
+    Write-Log "=== Cisco Secure Client Uninstallation Started ==="
+    
+    # Check for administrator privileges
+    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
+        Write-Log "Script must be run with administrator privileges." -Level Error
+        exit 1
+    }
+    
+    # Stop services and processes
+    Stop-CiscoServices
+    Stop-CiscoProcesses
+    
+    # Get installed Cisco products
+    $InstalledProducts = Get-CiscoInstalledProducts
+    
+    if ($InstalledProducts.Count -eq 0) {
+        Write-Log "No Cisco Secure Client components found to uninstall."
+        exit 0
+    }
+    
+    Write-Log "Found $($InstalledProducts.Count) component(s) to uninstall:"
+    foreach ($Product in $InstalledProducts) {
+        if ($Product -and $Product['Name']) {
+            Write-Log "  - $($Product['Name']) v$($Product['Version']) [Code: $($Product['Code'])]"
+        } else {
+            Write-Log "  - Invalid entry detected (missing name/code data)"
+        }
+    }
+    
+    # Uninstall each component
+    $FailedUninstalls = @()
+    $ValidProducts = @()
+    $SkippedProducts = 0
+    
+    foreach ($Product in $InstalledProducts) {
+        # Ensure we have valid data
+        if (-not $Product -or -not $Product['Name'] -or -not $Product['Code']) {
+            $SkippedProducts++
+            if ($Product -and $Product['Name']) {
+                Write-Log "Skipping invalid product entry: $($Product['Name']) (missing product code)" -Level Warning
+            } elseif ($Product -and $Product['Code']) {
+                Write-Log "Skipping invalid product entry: Code $($Product['Code']) (missing product name)" -Level Warning  
+            } else {
+                Write-Log "Skipping invalid product entry: Completely malformed registry data" -Level Warning
+            }
+            continue
+        }
+        
+        $ValidProducts += $Product
+    }
+    
+    if ($SkippedProducts -gt 0) {
+        Write-Log "Skipped $SkippedProducts invalid registry entries. Proceeding with $($ValidProducts.Count) valid components."
+    }
+    
+    # Process valid products
+    foreach ($Product in $ValidProducts) {
+        Write-Log "Uninstalling: $($Product['Name'])"
+        $Success = Uninstall-CiscoComponent -ProductName $Product['Name'] -ProductCode $Product['Code']
+        
+        if (-not $Success) {
+            $FailedUninstalls += $Product['Name']
+        }
+        
+        # Wait between uninstalls
+        Start-Sleep -Seconds 3
+    }
+    
+    # Clean up remaining folders if all components uninstalled successfully
+    if ($FailedUninstalls.Count -eq 0) {
+        Write-Log "Cleaning up remaining folders..."
+        
+        $FoldersToRemove = @(
+            "${env:ProgramFiles}\Cisco\Cisco Secure Client",
+            "${env:ProgramFiles(x86)}\Cisco\Cisco Secure Client",
+            "${env:ProgramFiles}\Cisco\Cisco AnyConnect Secure Mobility Client",
+            "${env:ProgramFiles(x86)}\Cisco\Cisco AnyConnect Secure Mobility Client",
+            "${env:ProgramData}\Cisco\Cisco Secure Client",
+            "${env:ProgramData}\Cisco\Cisco AnyConnect Secure Mobility Client"
+        )
+        
+        foreach ($Folder in $FoldersToRemove) {
+            if (Test-Path $Folder) {
+                Write-Log "Removing folder: $Folder"
+                Remove-Item -Path $Folder -Recurse -Force -ErrorAction SilentlyContinue
+            }
+        }
+        
+        Write-Log "=== Cisco Secure Client Uninstallation Completed Successfully ==="
+        exit 0
+    }
+    else {
+        Write-Log "=== Uninstallation Failed ===" -Level Error
+        Write-Log "Failed to uninstall: $($FailedUninstalls -join ', ')" -Level Error
+        exit 1
+    }
+}
+catch {
+    Write-Log "Unexpected error during uninstallation: $_" -Level Error
+    Write-Log "Stack Trace: $($_.ScriptStackTrace)" -Level Error
+    exit 1
+}
+#endregion
\ No newline at end of file
diff --git a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/Check.ps1 b/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/Check.ps1
deleted file mode 100644
index c3d71a0..0000000
--- a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/Check.ps1
+++ /dev/null
@@ -1,25 +0,0 @@
-# Define possible TeamViewer paths
-$teamViewerPaths = @(
-    "C:\Program Files\TeamViewer\TeamViewer.exe",
-    "C:\Program Files (x86)\TeamViewer\TeamViewer.exe"
-)
-
-# Set timeout parameters
-$timeout = New-TimeSpan -Minutes 3
-$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
-
-while ($stopwatch.Elapsed -lt $timeout) {
-    foreach ($path in $teamViewerPaths) {
-        if (Test-Path $path) {
-            Write-Output "Found TeamViewer at: $path"
-            exit 0
-        }
-    }
-    
-    # Wait 10 seconds before next check
-    Start-Sleep -Seconds 10
-}
-
-# If we get here, TeamViewer wasn't found within the timeout period
-Write-Output "TeamViewer not found after 3 minutes of checking"
-exit 1
\ No newline at end of file
diff --git a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/Install.ps1 b/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/Install.ps1
deleted file mode 100644
index f4a7a7f..0000000
--- a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/Install.ps1
+++ /dev/null
@@ -1,43 +0,0 @@
-# Get the directory where the script is located
-$scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
-
-# Resolve paths for MSI and settings files
-$msiPath = Join-Path -Path $scriptPath -ChildPath "TV.msi"
-$settingsFilePath = Join-Path -Path $scriptPath -ChildPath "s.tvopt"
-
-# Verify files exist
-if (-not (Test-Path $msiPath)) {
-    Write-Error "TeamViewer MSI file not found at: $msiPath"
-    exit 1
-}
-
-if (-not (Test-Path $settingsFilePath)) {
-    Write-Error "TeamViewer settings file not found at: $settingsFilePath"
-    exit 1
-}
-
-# Install TeamViewer
-Start-Process -FilePath "MSIEXEC.EXE" -ArgumentList "/i", $msiPath, "/qn", "CUSTOMCONFIGID=he26pyq", "SETTINGSFILE=$settingsFilePath" -Wait
-Start-Sleep -Seconds 30
-
-# Possible TeamViewer installation paths
-$teamViewerPaths = @(
-    "C:\Program Files\TeamViewer\TeamViewer.exe",
-    "C:\Program Files (x86)\TeamViewer\TeamViewer.exe"
-)
-
-# Find the actual TeamViewer path
-$teamViewerExe = $null
-foreach ($path in $teamViewerPaths) {
-    if (Test-Path $path) {
-        $teamViewerExe = $path
-        break
-    }
-}
-
-if ($teamViewerExe) {
-    Start-Process -FilePath $teamViewerExe -ArgumentList "assignment", "--id", "0001CoABChA0Wtyw41UR74SOzFGxK_rXEigIACAAAgAJACbSLLKpBBA6xZ-LyQnQTR-eZS-k2LbZwnYA3hzgn3SyGkDPy2YN1c_GAI_NPqig6Pj2KlsEx8tWXmtGjlI2edd2S45EsUzHcwJ7NxQ8FYG76qUp2Y4MyeLXBJ5zKbYzGP2uIAEQ9-LB8g0="
-} else {
-    Write-Error "TeamViewer executable not found in any of the expected locations"
-    exit 1
-}
\ No newline at end of file
diff --git a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/Uninstall.ps1 b/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/Uninstall.ps1
deleted file mode 100644
index abb6c14..0000000
--- a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/Uninstall.ps1
+++ /dev/null
@@ -1 +0,0 @@
-msiexec /x "{9A9ED08E-912E-4749-B713-C3775EDFBA61}" /qn
\ No newline at end of file
diff --git a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/s.tvopt b/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/s.tvopt
deleted file mode 100644
index 67b6ac7..0000000
--- a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/s.tvopt
+++ /dev/null
@@ -1,250 +0,0 @@
-Windows Registry Editor Version 5.00
-
-[HKEY_LOCAL_MACHINE\SOFTWARE\TeamViewer]
-"Always_Online"=dword:00000001
-"Proxy_Type"=dword:00000001
-"Proxy_IP"=hex(1):00,00
-"ProxyUsername"=hex(1):00,00
-"ProxyPassword"=hex(1):00,00
-"LanOnly"=dword:00000000
-"General_DirectLAN"=dword:00000000
-"Wol_Mode"=dword:00000000
-"Wol_IP"=hex(1):00,00
-"Wol_Port"=dword:00000000
-"Wol_Neighbors"=hex(7):00,00
-"Wol_ForceUpdate"=dword:00000001
-"AutorecordRemoteControlEnforced"=dword:00000000
-"Security_WinLogin"=dword:00000000
-"Security_PasswordStrength"=dword:00000001
-"Blacklist"=hex(7):00,00
-"Whitelist"=hex(7):00,00
-"BlacklistBuddy"=hex(7):00,00
-"WhitelistBuddy"=hex(7):00,00
-"BlacklistCompany"=hex(7):00,00
-"WhitelistCompany"=hex(7):00,00
-"BlacklistBuddyAccountID"=hex(3):88,44,d7,0a,b2,96,2a,3d,63,16,3c,ff,e4,15,04,fb
-"WhitelistBuddyAccountID"=hex(3):88,44,d7,0a,b2,96,2a,3d,63,16,3c,ff,e4,15,04,fb
-"BlacklistCompanyID"=hex(3):92,70,b4,c8,e9,3d,13,e0,7e,43,d3,8b,64,65,41,cd,40,3f,b0,6d,86,b7,62,8f,cf,f8,3c,d5,e0,7a,89,73
-"WhitelistCompanyID"=hex(3):12,df,44,cf,6e,81,32,d5,1f,c1,47,8e,1a,fc,73,89,84,2e,03,21,05,3b,7d,87,91,c1,bd,3b,86,6c,85,6f
-"UseWhitelist"=dword:00000000
-"Apply_Blacklist_Or_Whitelist_On_Meeting"=dword:00000000
-"RemoteMonitoring_Activated"=dword:00000001
-"Security_Disableshutdown"=dword:00000000
-"HideOnlineStateOfTV"=dword:00000000
-"ACFullAccessOnLoginScreen"=dword:00000000
-"AutoUpdateMode"=dword:00000000
-"UpdateCheckInterval"=dword:00000000
-"UpdateChannel"=dword:00000001
-"IsPreviewVersion"=dword:00000000
-"ChatToThisMachine"=dword:00000001
-"Logging"=dword:00000001
-"LogIncomingConnections"=dword:00000001
-"LogOutgoingConnections"=dword:00000001
-"Security_AcceptIncoming"=dword:00000001
-"CustomRouter"=hex(1):00,00
-"ServerPasswordAES"=hex(3):88,44,d7,0a,b2,96,2a,3d,63,16,3c,ff,e4,15,04,fb
-"useUDP"=dword:00000001
-"Security_Adminrights"=dword:00000001
-"OptionsPasswordHash"=hex:01,03,01,40,00,00,00,3b,7a,36,02,b2,34,da,95,a2,5c,ba,08,cf,5b,00,2f,05,ef,71,ef,d3,d8,7c,83,0d,6b,34,1d,55,7f,44,c7,c8,af,61,70,49,f9,7b,b5,68,52,cc,9c,a2,98,a9,50,08,45,da,c9,42,de,4a,a0,69,d7,18,4b,20,49,95,c6,02,10,00,00,00,0f,08,84,8f,ac,d2,03,8b,71,d0,89,c3,9a,79,20,39,03,04,00,00,00,10,27,00,00
-
-[HKEY_CURRENT_USER\SOFTWARE\TeamViewer]
-"Autostart_GUI"=dword:00000001
-"MinimizeToTray"=dword:00000001
-"Remote_QualityMode"=dword:00000000
-"Remote_Colors"=dword:00000008
-"Remote_Compression"=dword:00000064
-"Remote_UseHooks"=dword:00000001
-"Remote_DisableGuiAnimations"=dword:00000001
-"Remote_RemoveWallpaper"=dword:00000001
-"Remote_RemoteCursor"=dword:00000000
-"Remote_UseVideoCodec"=dword:00000001
-"AutorecordRemoteControl"=dword:00000000
-"ConfirmRecordingRemoteControl"=dword:00000001
-"SendWindowsKeys"=dword:00000000
-"ClientTabs"=dword:00000001
-"Pres_QualityMode"=dword:00000001
-"Pres_Colors"=dword:00000020
-"Pres_Compression"=dword:0000005a
-"Pres_UseHooks"=dword:00000001
-"Pres_DisableGuiAnimations"=dword:00000001
-"Pres_RemoveWallpaper"=dword:00000001
-"Pres_UseVideoCodec"=dword:00000001
-"PresentationPassword"=hex(1):00,00
-"AutorecordPresentation"=dword:00000000
-"ConfirmRecordingMeeting"=dword:00000001
-"MeetingMode"=dword:00000000
-"CustomInvitationText"=hex(1):00,00
-"CustomInvitationTextP"=hex(1):00,00
-"CustomInvitationSubject"=hex(1):00,00
-"CustomInvitationSubjectP"=hex(1):00,00
-"ConferenceSelection"=dword:00000001
-"CustomConferenceText"=hex(1):00,00
-"SelectedLanguage"=hex(1):00,00
-"MainWindowSmallModeActivated"=dword:00000001
-"AutoHideServerControl"=dword:00000000
-"Remote_BlackScreen"=dword:00000000
-"CachePasswords"=dword:00000001
-"InactiveTime"=dword:00000000
-"DisableCaptureBlt"=dword:00000000
-"SessionRecorderDirectory"=hex(1):00,00
-"LockRemoteComputer"=dword:00000002
-"ClipboardSync"=dword:00000001
-"ClipboardSyncExtended"=dword:00000001
-"ClipboardSyncPrefill"=dword:00000001
-"ChangeDynamicPassword"=dword:00000000
-"DeactivatedDynamicPassword"=dword:00000000
-"DisableDragAndDrop"=dword:00000000
-"DisableDirectXScreenRendering"=dword:00000000
-
-[HKEY_LOCAL_MACHINE\SOFTWARE\TeamViewer\DefaultSettings]
-"Autostart_GUI"=dword:00000001
-"MinimizeToTray"=dword:00000001
-"Remote_QualityMode"=dword:00000000
-"Remote_Colors"=dword:00000008
-"Remote_Compression"=dword:00000064
-"Remote_UseHooks"=dword:00000001
-"Remote_DisableGuiAnimations"=dword:00000001
-"Remote_RemoveWallpaper"=dword:00000001
-"Remote_RemoteCursor"=dword:00000000
-"Remote_UseVideoCodec"=dword:00000001
-"AutorecordRemoteControl"=dword:00000000
-"ConfirmRecordingRemoteControl"=dword:00000001
-"SendWindowsKeys"=dword:00000000
-"ClientTabs"=dword:00000001
-"Pres_QualityMode"=dword:00000001
-"Pres_Colors"=dword:00000020
-"Pres_Compression"=dword:0000005a
-"Pres_UseHooks"=dword:00000001
-"Pres_DisableGuiAnimations"=dword:00000001
-"Pres_RemoveWallpaper"=dword:00000001
-"Pres_UseVideoCodec"=dword:00000001
-"PresentationPassword"=hex(1):00,00
-"AutorecordPresentation"=dword:00000000
-"ConfirmRecordingMeeting"=dword:00000001
-"MeetingMode"=dword:00000000
-"CustomInvitationText"=hex(1):00,00
-"CustomInvitationTextP"=hex(1):00,00
-"CustomInvitationSubject"=hex(1):00,00
-"CustomInvitationSubjectP"=hex(1):00,00
-"ConferenceSelection"=dword:00000001
-"CustomConferenceText"=hex(1):00,00
-"SelectedLanguage"=hex(1):00,00
-"MainWindowSmallModeActivated"=dword:00000001
-"AutoHideServerControl"=dword:00000000
-"Remote_BlackScreen"=dword:00000000
-"CachePasswords"=dword:00000001
-"InactiveTime"=dword:00000000
-"DisableCaptureBlt"=dword:00000000
-"SessionRecorderDirectory"=hex(1):00,00
-"LockRemoteComputer"=dword:00000002
-"ClipboardSync"=dword:00000001
-"ClipboardSyncExtended"=dword:00000001
-"ClipboardSyncPrefill"=dword:00000001
-"ChangeDynamicPassword"=dword:00000000
-"DeactivatedDynamicPassword"=dword:00000000
-"DisableDragAndDrop"=dword:00000000
-"DisableDirectXScreenRendering"=dword:00000000
-
-[HKEY_CURRENT_USER\SOFTWARE\TeamViewer\MultiMedia]
-"RemoteAudioReceiveEnabled"=dword:00000001
-"RemoteAudioSendEnabled"=dword:00000000
-
-[HKEY_LOCAL_MACHINE\SOFTWARE\TeamViewer\DefaultSettings\MultiMedia]
-"RemoteAudioReceiveEnabled"=dword:00000001
-"RemoteAudioSendEnabled"=dword:00000000
-
-[HKEY_CURRENT_USER\SOFTWARE\TeamViewer\InteractionDefaults]
-"Meeting_ID_InteractionDefaultsType"=dword:00000000
-"Meeting_ID_Custom_ChatAccess"=dword:00000000
-"Meeting_ID_Custom_VideoAccess"=dword:00000000
-"Meeting_ID_Custom_AudioAccess"=dword:00000000
-"Meeting_ID_Custom_WhiteboardAccess"=dword:00000000
-"Meeting_ID_Custom_MarkerAccess"=dword:00000000
-"Meeting_ID_Custom_SeeAllParticipantsAccess"=dword:00000000
-"Meeting_ID_Custom_ShareFilesAccess"=dword:00000000
-
-[HKEY_LOCAL_MACHINE\SOFTWARE\TeamViewer\DefaultSettings\InteractionDefaults]
-"Meeting_ID_InteractionDefaultsType"=dword:00000000
-"Meeting_ID_Custom_ChatAccess"=dword:00000000
-"Meeting_ID_Custom_VideoAccess"=dword:00000000
-"Meeting_ID_Custom_AudioAccess"=dword:00000000
-"Meeting_ID_Custom_WhiteboardAccess"=dword:00000000
-"Meeting_ID_Custom_MarkerAccess"=dword:00000000
-"Meeting_ID_Custom_SeeAllParticipantsAccess"=dword:00000000
-"Meeting_ID_Custom_ShareFilesAccess"=dword:00000000
-
-[HKEY_CURRENT_USER\SOFTWARE\TeamViewer\AccessControl]
-"AC_Pres_Autostart"=dword:00000001
-"AC_Client_Custom_ChangeDirAllowed"=dword:00000000
-"AC_AllowOutgoingConnections"=dword:00000001
-"AC_Client_AccessControlType"=dword:00000000
-"AC_Client_Custom_AllowPartnerViewDesktop"=dword:00000000
-"AC_Client_Custom_RemoteControlAccess"=dword:00000000
-"AC_Client_Custom_FileTransferAccess"=dword:00000000
-"AC_Client_Custom_AllowVPN"=dword:00000000
-"AC_Client_Custom_DisableRemoteImput"=dword:00000000
-"AC_Client_Custom_ControlRemoteTV"=dword:00000000
-"AC_Client_Custom_DisableRemoteInputAtStart"=dword:00000000
-"AC_Client_Custom_ShareMyFiles"=dword:00000000
-"AC_Client_Custom_ShareFilesWithMe"=dword:00000000
-"AC_Client_Custom_AllowToPrintOnMyPrinters"=dword:00000000
-"AC_Client_Custom_AllowToPrintOnRemotePrinters"=dword:00000000
-"AC_Client_Custom_AllowExecuteScripts"=dword:00000000
-"Meeting_AC_AccessControlType"=dword:00000000
-"Meeting_AC_Custom_HostAMeetingAccess"=dword:00000000
-"Meeting_AC_Custom_JoinAMeetingAccess"=dword:00000000
-"Meeting_AC_Custom_ControlRemoteComputersAccess"=dword:00000000
-"Meeting_AC_Custom_ControlThisComputersAccess"=dword:00000000
-"Meeting_AC_Custom_RecordMeetingAccess"=dword:00000000
-"Meeting_AC_Custom_ShareMyFilesAccess"=dword:00000000
-"Meeting_AC_Custom_ShareFilesWithMeAccess"=dword:00000000
-
-[HKEY_LOCAL_MACHINE\SOFTWARE\TeamViewer\DefaultSettings\AccessControl]
-"AC_Pres_Autostart"=dword:00000001
-"AC_Client_Custom_ChangeDirAllowed"=dword:00000000
-"AC_AllowOutgoingConnections"=dword:00000001
-"AC_Client_AccessControlType"=dword:00000000
-"AC_Client_Custom_AllowPartnerViewDesktop"=dword:00000000
-"AC_Client_Custom_RemoteControlAccess"=dword:00000000
-"AC_Client_Custom_FileTransferAccess"=dword:00000000
-"AC_Client_Custom_AllowVPN"=dword:00000000
-"AC_Client_Custom_DisableRemoteImput"=dword:00000000
-"AC_Client_Custom_ControlRemoteTV"=dword:00000000
-"AC_Client_Custom_DisableRemoteInputAtStart"=dword:00000000
-"AC_Client_Custom_ShareMyFiles"=dword:00000000
-"AC_Client_Custom_ShareFilesWithMe"=dword:00000000
-"AC_Client_Custom_AllowToPrintOnMyPrinters"=dword:00000000
-"AC_Client_Custom_AllowToPrintOnRemotePrinters"=dword:00000000
-"AC_Client_Custom_AllowExecuteScripts"=dword:00000000
-"Meeting_AC_AccessControlType"=dword:00000000
-"Meeting_AC_Custom_HostAMeetingAccess"=dword:00000000
-"Meeting_AC_Custom_JoinAMeetingAccess"=dword:00000000
-"Meeting_AC_Custom_ControlRemoteComputersAccess"=dword:00000000
-"Meeting_AC_Custom_ControlThisComputersAccess"=dword:00000000
-"Meeting_AC_Custom_RecordMeetingAccess"=dword:00000000
-"Meeting_AC_Custom_ShareMyFilesAccess"=dword:00000000
-"Meeting_AC_Custom_ShareFilesWithMeAccess"=dword:00000000
-
-[HKEY_LOCAL_MACHINE\SOFTWARE\TeamViewer\AccessControl]
-"AC_Server_AccessControlType"=dword:00000000
-"AC_Server_Custom_AllowPartnerViewDesktop"=dword:00000000
-"AC_Server_Custom_RemoteControlAccess"=dword:00000000
-"AC_Server_Custom_FileTransferAccess"=dword:00000000
-"AC_Server_Custom_AllowVPN"=dword:00000000
-"AC_Server_Custom_DisableRemoteImput"=dword:00000000
-"AC_Server_Custom_ControlRemoteTV"=dword:00000000
-"AC_Server_Custom_AllowMeToDownloadFromFileBox"=dword:00000000
-"AC_Server_Custom_AllowMeToUploadToFileBox"=dword:00000000
-"AC_Server_Custom_AllowToPrintOnMyPrinters"=dword:00000000
-"AC_Server_Custom_AllowToPrintOnRemotePrinters"=dword:00000000
-"AC_Server_Custom_AllowExecuteScripts"=dword:00000000
-
-[HKEY_CURRENT_USER\SOFTWARE\TeamViewer\MsgBoxDontShow]
-"PasswordOnSessionEnd"=dword:00000001
-
-[HKEY_LOCAL_MACHINE\SOFTWARE\TeamViewer\DefaultSettings\MsgBoxDontShow]
-"PasswordOnSessionEnd"=dword:00000001
-
-[HKEY_LOCAL_MACHINE\SOFTWARE\TeamViewer\Temp]
-"SecurityPasswordExported"=hex:86,f5,c7,ef,c7,ce,60,01,75,95,48,9c,5e,62,37,bc,68,48,06,90,7c,30,24,42,12,f7,ba,14,a9,1f,95,32,1d,99,03,b1,97,53,cf,4a,6d,6e,e5,33,90,ab,0e,78,e1,6e,f9,0f,b0,59,4f,50,55,fa,bb,fd,16,c7,c7,91
-
diff --git a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/teamviewer-icon-7.png b/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/teamviewer-icon-7.png
deleted file mode 100644
index fe3b595..0000000
Binary files a/Win32Apps-Source/TeamViewer_Host_LITEv4/Windows/teamviewer-icon-7.png and /dev/null differ
diff --git a/Win32Apps-Source/TeamViewer_Host_LITEv4/macOS/README.md b/Win32Apps-Source/TeamViewer_Host_LITEv4/macOS/README.md
deleted file mode 100644
index 8b0a4af..0000000
--- a/Win32Apps-Source/TeamViewer_Host_LITEv4/macOS/README.md
+++ /dev/null
@@ -1 +0,0 @@
-check the https://github.com/aollivierre/JAMF/tree/main/apps/TeamViewerv4 for the latest version 
\ No newline at end of file
diff --git a/docs/How-It-Works-Summary.txt b/docs/How-It-Works-Summary.txt
new file mode 100644
index 0000000..d02e47b
--- /dev/null
+++ b/docs/How-It-Works-Summary.txt
@@ -0,0 +1,40 @@
+Summary
+
+  Based on my analysis of the Intune-Win32-Deployer project, here's how it works:
+
+  Folder Structure
+
+  - Win32Apps-Source: Place your applications here. Each app needs its own folder with:
+    - install.ps1 - Installation script
+    - uninstall.ps1 - Uninstallation script
+    - check.ps1 - Detection script (returns 0 if installed)
+    - config.json - App-specific configuration
+    - Any other required files (executables, configs, etc.)
+
+  Authentication Methods
+
+  The script supports both authentication methods:
+  1. Certificate-based authentication (preferred) - Uses a .pfx certificate with TenantID, ClientId, and certificate password
+  2. Interactive authentication (fallback) - Browser-based login when certificate auth fails
+
+  How to Set Up
+
+  1. Create a folder in secrets/ with your tenant name
+  2. Add secrets.json with:
+  {
+    "TenantID": "your-tenant-id",
+    "ClientId": "your-app-registration-id",
+    "CertPassword": "your-cert-password"
+  }
+  3. Place your certificate (.pfx file) in the same tenant folder
+
+  Workflow
+
+  1. Script prompts you to select a tenant from available folders in secrets/
+  2. Attempts certificate authentication first
+  3. Falls back to interactive if certificate fails
+  4. Scans Win32Apps-Source for applications
+  5. Packages each app using Microsoft's IntuneWinAppUtil.exe
+  6. Uploads to Intune
+
+  I've created documentation in /docs/How-It-Works.md with complete details about the folder structure, authentication methods, required files, and usage tips.
\ No newline at end of file
diff --git a/docs/How-It-Works.md b/docs/How-It-Works.md
new file mode 100644
index 0000000..57cd3f0
--- /dev/null
+++ b/docs/How-It-Works.md
@@ -0,0 +1,145 @@
+# Intune Win32 Deployer - How It Works
+
+## Overview
+The Intune Win32 Deployer is a PowerShell-based tool that automates the packaging and deployment of Win32 applications to Microsoft Intune. The main script (`Intune-Win32-Deployer-ALPHAv1.ps1`) orchestrates the entire process.
+
+## Folder Structure
+
+### 1. **Win32Apps-Source**
+This is where you place your applications that need to be packaged and deployed. Each application should be in its own folder with the following structure:
+
+```
+Win32Apps-Source/
+ΓööΓöÇΓöÇ AppName/
+    Γö£ΓöÇΓöÇ install.ps1      # Installation script
+    Γö£ΓöÇΓöÇ uninstall.ps1    # Uninstallation script  
+    Γö£ΓöÇΓöÇ check.ps1        # Detection script
+    Γö£ΓöÇΓöÇ config.json      # App-specific configuration
+    ΓööΓöÇΓöÇ [other files]    # Any other files needed for the app
+```
+
+### 2. **Win32Apps-Gallery**
+This folder contains pre-packaged applications that have been successfully deployed. These serve as templates and examples for creating new packages.
+
+### 3. **Win32Apps-published**
+Applications that have been published to Intune are stored here for reference.
+
+### 4. **secrets/**
+This directory contains tenant-specific authentication information:
+```
+secrets/
+ΓööΓöÇΓöÇ TenantName/
+    Γö£ΓöÇΓöÇ secrets.json     # Contains TenantID, ClientId, CertPassword
+    ΓööΓöÇΓöÇ certificate.pfx  # Certificate for authentication
+```
+
+### 5. **resources/**
+Contains utility files and templates:
+- `IntuneWinAppUtil.exe` - Microsoft's tool for creating .intunewin packages
+- `template/` - Templates for different app types (custom, winget, chocolatey)
+
+## Authentication Methods
+
+The script supports two authentication methods:
+
+### 1. **Certificate-Based Authentication (Preferred)**
+- Uses a certificate (.pfx file) stored in the secrets folder
+- Requires:
+  - `TenantID`
+  - `ClientId` (App Registration ID)
+  - `CertPassword`
+  - Certificate file (.pfx)
+- Non-interactive, suitable for automation
+
+### 2. **Interactive Authentication (Fallback)**
+- Falls back to interactive login if certificate authentication fails
+- Requires manual sign-in through browser
+- Uses the TenantID from secrets.json
+
+## Workflow
+
+1. **Script Initialization**
+   - Relaunches in PowerShell 5 if running in PowerShell 7
+   - Sets up logging (PSFramework and transcript)
+   - Loads required modules
+
+2. **Authentication**
+   - Prompts user to select a tenant folder from `secrets/`
+   - Loads authentication details from `secrets.json`
+   - Attempts certificate-based authentication first
+   - Falls back to interactive authentication if needed
+
+3. **Environment Setup**
+   - Initializes the Win32 environment
+   - Cleans up old .intunewin files
+   - Prepares necessary paths
+
+4. **App Processing**
+   - Scans the `Win32Apps-Source` directory (or configured directory)
+   - For each application folder found:
+     - Reads the app's `config.json`
+     - Packages the app using IntuneWinAppUtil.exe
+     - Creates the Intune deployment package
+     - Uploads to Intune
+
+## Required Files for Each App
+
+### 1. **install.ps1**
+The installation script that will be executed to install the application.
+
+### 2. **uninstall.ps1**
+The uninstallation script for removing the application.
+
+### 3. **check.ps1**
+Detection script that determines if the application is installed. Should return exit code 0 if installed.
+
+### 4. **config.json**
+Application-specific configuration containing:
+```json
+{
+  "PackageName": "APP001-AppName",
+  "PackageUniqueGUID": "unique-guid-here",
+  "Version": 1,
+  "PackageExecutionContext": "SYSTEM" | "User",
+  "ID": "DisplayName",
+  "Publisher": "Publisher Name",
+  "AppVersion": "1.0.0",
+  "InstallExperience": "system" | "user",
+  "RestartBehavior": "suppress" | "force" | "basedOnReturnCode" | "allow",
+  "PSADT": "true" | "false"
+}
+```
+
+## Key Configuration Files
+
+### 1. **config.json** (Root)
+Main configuration file containing default values for all apps.
+
+### 2. **Modules.json**
+Defines PowerShell modules to be loaded, including required modules from PSGallery.
+
+### 3. **scopes.json**
+Defines Microsoft Graph API scopes required for the application.
+
+## Tips for Usage
+
+1. **Prepare Your Apps**: Place your application files in the `Win32Apps-Source` folder with the required structure.
+
+2. **Set Up Authentication**: 
+   - Create a folder in `secrets/` with your tenant name
+   - Add `secrets.json` with your authentication details
+   - Place your certificate (.pfx) file in the same folder
+
+3. **Test First**: Use a test tenant or a small subset of apps before deploying to production.
+
+4. **Check Logs**: The script creates detailed logs in `C:\Logs\PSF` and `C:\Logs\Transcript`.
+
+5. **PSADT Support**: For applications using PowerShell App Deployment Toolkit, set `"PSADT": "true"` in the app's config.json.
+
+## Common Issues
+
+1. **Authentication Failures**: Ensure your certificate is valid and the app registration has the necessary permissions.
+
+2. **Missing Files**: Each app folder must contain at minimum: install.ps1, uninstall.ps1, check.ps1, and config.json.
+
+3. **PowerShell Version**: The script automatically handles PowerShell version requirements by relaunching in PS5 if needed.
\ No newline at end of file
diff --git a/test-icon-path.ps1 b/test-icon-path.ps1
new file mode 100644
index 0000000..c1c2173
--- /dev/null
+++ b/test-icon-path.ps1
@@ -0,0 +1,8 @@
+# Test script to check icon path handling
+
+$Repo_Path = "C:\Code\Intune-Win32-Deployer"
+$imagePath = Join-Path -Path $Repo_Path -ChildPath "resources\template\winget\winget-managed.png"
+
+Write-Host "Repo_Path: $Repo_Path"
+Write-Host "imagePath: $imagePath"
+Write-Host "Path exists: $(Test-Path -Path $imagePath)"
\ No newline at end of file
